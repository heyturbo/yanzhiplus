<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project TS</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1/crypto-js.js"></script>
    <style>
        /* @import url('https://fonts.loli.net/css2?family=Noto+Serif+SC:wght@400;700&display=swap'); */

        body {
            font-family: 'Noto Serif SC', sans-serif;
            display: flex;
            flex-direction: column;
            margin: 0;
            padding: 5px;
            color: #6f391c;
            align-items: center;
            font-size: 14px;
        }

        #petOverview {
            display: none; /* 默认隐藏 */
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            height: 100%;
            background-color: rgb(26 72 47 / 95%);
            background-image: url(https://pic.imgdb.cn/item/66bb97abd9c307b7e974cff5.png);
            background-size: cover;
            overflow-y: scroll;
            z-index: 1000;
        }
        .close-button {
            display: flex;
            /* width: 100%; */
            background-color: hsl(0deg 0% 100% / 0%);
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            padding: 5px 10px;
            flex-direction: row-reverse;
            font-size: 20px;
        }
        .pet-container {
            background-image: url(https://pic.imgdb.cn/item/66bb8916d9c307b7e95f8f5a.jpg);
            border-radius: 10px;
            margin: 10px 10px 20px 10px;
            padding: 10px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            color: white;
            border: 1px solid white;
            background-size: cover;
        }
        .pet-header {
            display: flex;
            flex-direction: row;
            justify-content: space-between;
            background: rgb(0 0 0 / 40%);
            border-radius: 10px;
            padding: 10px;
            text-shadow: -1px -1px 0 black,  
                         1px -1px 0 black,
                        -1px  1px 0 black,
                         1px  1px 0 black;
        }
        .pet-header h2 {
            margin: 0;
            font-size: 18px;
        }
        .pet-status {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            flex-direction: row;
            border-radius: 10px;
        }
        .pet-status div {
            width: 50%;
            text-align: center;
            display: flex;
            justify-content: space-between;
            flex: 0.4;
            align-items: center;
        }
        .pet-progress {
            width: 100%;
            height: 15px;
            background-color: #63434c;
            border: 1px solid #5e5060;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 10px;
            margin-bottom: 10px;
            box-shadow: inset -1px 1px 5px 1px rgba(0, 0, 0, 0.5);
        }
        .pet-progress div {
            height: 100%;
            width: 0%;
            background: linear-gradient(to bottom, #71A291, #8EBB85, #A1CC80, #8EBB85, #71A291);
            box-shadow: 1px 0 5px 2px rgba(0, 0, 0, 0.5);
        }
        .pet-buttons {
            display: flex;
            justify-content: space-between;
        }
        .pet-buttons button {
            flex: 0.15;
            background: linear-gradient(to top, #115570, #20c3af);
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-size: 14px;
            border: 1px solid hsl(0deg 0% 100% / 70%);
            box-shadow: 0 0 20px 0px rgba(0, 0, 0, 0.5);
        }
        .pet-buttons button:active {
            background-color: #004373;
        }
        #iframeContainer {
            display: none;
            width: 100%;
            height: 100%;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 9999;
        }
    .item-text-container {
        margin-left: 2px;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        font-size: 12px;
        align-items: flex-start;
        background-image: url(https://pic.imgdb.cn/item/663885620ea9cb14033e4f6e.png);
        background-repeat: repeat;
        background-size: contain;
        padding: 1px;
        border: 1px solid black;
        width: 100%;
        height: 43px;
    }

    .item-text-top {
        padding: 0px;
        background: #393226;
        color: #DD9C35;
        box-shadow: 0px 0px 0px 1px #514D41;
        width: 100%;
        height: 21px;
        text-overflow: ellipsis;
        overflow: hidden;
        text-align: left;
    }
    
    .item-text-bottom {
        background: #393226;
        color:rgb(255 255 255 / 90%);
        box-shadow: 0px 0px 0px 1px #514D41;
        height: 18px;
        width: 100%;
        text-align: left;
        overflow: hidden;
    }

    .general-window-background {
        display: block;
        z-index: 1000;
        background: #6f391c;
        border-radius: 2px;
        color: #92341c;
        background-repeat: repeat;
        background-size: auto;
        border: 1px solid black;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 360px;
        padding: 1px;
    }

#wuxing-open-button {
    margin: 20px;
    padding: 10px 20px;
    background-color: #3498db;
    color: #ffffff;
    border: none;
    border-radius: 5px;
    cursor: pointer;
}

#wuxing-display {
    display: none; /* 默认隐藏 */
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: white;
    width: 90%;
    max-height: 660px;
    overflow-y: auto;
    z-index: 9999;
    background: #B07638;
    padding: 2px;
    box-shadow: inset 0px 0px 3px 1px #92341C;
    border: 1px solid black;
}

#wuxing-header {
    display: flex;
    padding: 5px;
    gap: 60px;
    justify-content: space-around;
    align-items: center;
    text-align: center;
    background-image: url(https://pic.imgdb.cn/item/66bf32d9d9c307b7e9995d58.png);
    background-repeat: repeat;
    background-size: contain;
    color: #E3A73B;
    cursor: pointer;
    box-shadow: inset 0px 1px 2px 0px #E3A73B;
    border: 1px solid black;
}

#wuxing-container {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 10px 5px;
    max-height: 240px;
    justify-items: center;
    align-content: space-around;
    border: 1px solid #87431f;
    padding: 10px;
    overflow-y: scroll;
    border-radius: 2px;
    margin: 5px;
    min-height: 50px;
    margin-top: 5px;
    border-width: 10px;
    border-style: solid;
    border-color: transparent;
    border-image: url(https://pic.imgdb.cn/item/66c2f34cd9c307b7e9be06c0.png) 40 / 1 / 0 round;
}

#equipped-container {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 10px 5px;
    max-height: 200px;
    justify-items: center;
    align-content: space-around;
    border: 1px solid #87431f;
    padding: 10px;
    overflow-y: scroll;
    border-radius: 2px;
    margin: 5px;
    min-height: 50px;
    margin-top: 5px;
    border-width: 10px;
    border-style: solid;
    border-color: transparent;
    border-image: url(https://pic.imgdb.cn/item/66c2f34cd9c307b7e9be06c0.png) 40 / 1 / 0 round;
}
        
.wuxing-item {
    position: relative;
    width: 45px;
    height: 45px;
    background-size: cover;
    cursor: pointer;
    font-size: 10px;
    border: 1px solid white; /* 默认边框颜色 */
    box-shadow: 0px 0px 0px 1px black;
}

.wuxing-item.equipped {
    filter: brightness(50%); /* 装备后变暗 */
}

.red-border {
    border-color: red;
}

.green-border {
    border-color: green;
}

.blue-border {
    border-color: blue;
}

.orange-border {
    border-color: orange;
}

.purple-border {
    border-color: purple;
}

.wuxing-info {
    position: absolute;
    bottom: 0;
    background-color: rgba(0, 0, 0, 0.8);
    color: white;
    width: 45px;
    text-align: center;
    height: 20px;
    font-size: 8px;
}

#amulet-details {
    border: 1px solid #87431f;
    padding: 10px;
    height: 180px;
    border-radius: 2px;
    line-height: 18px;
    background: rgb(0 0 0 / 20%);
    color: #ffffff;
}
        
        /* 防止 "pull-to-refresh" 行为 */
        @media screen and (pointer: coarse) {
        @supports (-webkit-backdrop-filter: blur(1px)) {
            /* Safari 16+ */
            @supports (overscroll-behavior-y: none) {
                html {
                    min-height: 100.3%;
        overscroll-behavior-y: none;
                }
            }
            /* Safari 9-15 */
        @supports (not (overscroll-behavior-y: none)) {
                html {
                    height: 100%;
        overflow: hidden;
                }
                body {
                    margin: 0px;
                    max-height: 100%; /* or `height: calc(100% - 16px);` if body has default margin */
                    overflow: auto;
                    -webkit-overflow-scrolling: touch;
                }
            }
        }
    }
        /* Chrome 63+ */
            body {
            overscroll-behavior-y: none;
        }
        /* styles.css */
        #loadingOverlay, #unlockOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgb(0 0 0);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 24px;
            flex-direction: column;
            cursor: not-allowed;
        }

        #baiyinOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgb(0 0 0 / 0%); /* 半透明背景 */
            z-index: 9999; /* 置顶 */
            display: none; /* 初始隐藏 */
            cursor: not-allowed; /* 显示禁止操作的光标 */
        }
        
        #loadingText {
            color: white;
            font-size: 20px;
            margin-bottom: 20px;
        }
        
        #progressBarContainer {
            width: 80%;
            background: #ddd;
            border-radius: 25px;
        }
        
        #progressBar {
            width: 0%;
            height: 30px;
            background: #4caf50;
            border-radius: 25px;
        }

        /* 顶部栏样式 */
        .top-bar {
            width: 90%;
            margin: 5px 5px;
            padding: 5px;
            background-color: rgb(255 255 255 / 41%);
            display: flex;
            justify-content: space-around;
            align-items: center;
            border-radius: 10px;
            flex-direction: row;
            flex-wrap: nowrap;
            border: 1px groove white;
        }
        
        .top-bar div {
            display: flex;
            font-size: 12px;
            color: #5d4201;
            align-items: center;
            flex-direction: column;
        }
        
        .top-bar img {
            width: 40px;
            height: 40px;
            border: 1px solid #6f391c;
        }
        
        /* 底部栏样式 */
        .bottom-bar {
            width: 90%;
            margin: 5px 5px;
            padding: 5px;
            background-color: rgb(255 255 255 / 40%);
            border: 1px solid rgba(0, 0, 0, 0.1);
            /* box-shadow: 0 0px 5px rgba(0, 0, 0, 0.1); */
            display: flex;
            border-radius: 10px;
            flex-direction: row;
            flex-wrap: nowrap;
            justify-content: space-between;
            border: 1px groove white;
        }
        
        .bottom-bar div {
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: center;
        }
        
        .bottom-bar img {
            width: 45px;
            height: 45px;
        }
        .core-area {
            background-color: hwb(0deg 100% 0% / 95%);
            display: flex;
            border-radius: 10px;
            justify-content: center;
            width: 90%;
            padding: 5px;
            margin: 5px 0px 5px 0px;
            flex-direction: column;
            background-image: url(https://pic.imgdb.cn/item/66d324a9d9c307b7e97a8e72.png);
            background-size: cover;
            background-position: center;
            border: 1px groove aliceblue;
        }
        .core-area-for-skills {
            width: 90%;
            margin: 15px 0px 5px 0px;
            padding: 5px;
            background-color: hsl(0deg 0% 100% / 40%);
            display: flex;
            flex-direction: column;
            align-items: center;
            border-radius: 10px;
            border: 1px groove white;
        }
        .button-row {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0px 10px;
            margin: 0px 0px;
            justify-items: center;
        }
        
        .button-row button {
            flex: auto;
            margin: 0px;
            padding: 0px; /* 去掉内边距以适应按钮大小 */
            background-color: transparent; /* 背景色设为透明以显示背景图片 */
            color: transparent; /* 隐藏按钮文本 */
            border: none;
            cursor: pointer;
            background-size: contain; /* 背景图像保持比例缩放 */
            background-position: center; /* 背景图像居中 */
            background-repeat: no-repeat; /* 防止背景图像平铺 */
            width: 65px; /* 根据需要调整宽度 */
            height: 40px; /* 根据需要调整高度 */
        }
        
        /* 为每个按钮设置不同的背景图片 */
        #guideButton {
            background-image: url('https://pic.imgdb.cn/item/66616fec5e6d1bfa05b013ec.png');
        }
        
        #drawerButton {
            background-image: url('https://pic.imgdb.cn/item/66616feb5e6d1bfa05b01312.png');
        }
        
        #attributeButton {
            background-image: url('https://pic.imgdb.cn/item/66616feb5e6d1bfa05b01297.png');
        }
        
        #shopButton {
            background-image: url('https://pic.imgdb.cn/item/66616fea5e6d1bfa05b0121c.png');
        }
        
        #treasureButton {
            background-image: url('https://pic.imgdb.cn/item/66616fea5e6d1bfa05b0117c.png');
        }
        
        #jinnangButton {
            background-image: url('https://pic.imgdb.cn/item/66616fe95e6d1bfa05b0103d.png');
        }
        
        #fightingButton {
            background-image: url('https://pic.imgdb.cn/item/6661a26a5e6d1bfa05edacf1.png');
        }
        
        #lotteryButton {
            background-image: url('https://pic.imgdb.cn/item/666466225e6d1bfa05b95973.png');
        }

        #missionButton {
            background-image: url('https://pic.imgdb.cn/item/667eeb54d9c307b7e94edd35.png');
        }
        
        #summonButton {
            background-image: url('https://pic.imgdb.cn/item/667eec26d9c307b7e95150b5.png');
        }
        
        #divineButton {
            background-image: url('https://pic.imgdb.cn/item/66bdfe39d9c307b7e998dba2.png');
        }
        
        #workButton {
            background-image: url('https://pic.imgdb.cn/item/66bdfe39d9c307b7e998db6b.png');
        }
        .core-area .skills {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            padding: 0px 0px;
            gap: 5px 5px;
            width: 100%;
        }
        .advancement-container {
            display: flex;
            gap: 20px;
            flex-direction: row;
            justify-content: space-evenly;
            background-image: url(https://gd-hbimg.huaban.com/fd730cf6da92e721e4b42157c4d33fb543d9a986fc917-bTarH2_fw1200);
            background-size: cover;
            border-radius: 10px 10px 10px 10px;
            align-items: center;
            font-size: 12px;
            color: aliceblue;
        }
        .advancement-series {
            padding: 5px;
            margin: 5px;
            border-radius: 5px;
            font-size: 12px;
            background: transparent;
            color: #f1f9ff;
            border: 1px solid #155173;
            box-shadow: 0px 0px 2px 0px rgb(191 198 204);
            cursor: pointer;
        }
        .aquire-skill-advancement-panel {
          width: 90%;
          box-shadow: 0 0px 6px 2px rgb(0 0 0 / 40%);
          padding: 1px 2px 2px 2px;
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          display: block;
          background: #6f391c;
          border-radius: 2px;
          color: #92341c;
        }
        .skill-detail-panel {
          font-size: 14px;
          width: 100%;
          display: flex;
          flex-direction: column;
          gap: 10px;
          height: 80px;
          justify-content: center;
        }
        .skill-detail {
        width: 100%;
        display: flex;
        gap: 20px;
        flex-direction: row;
        flex-wrap: wrap;
        align-items: center;
        justify-content: space-around;
        }
        .panel-top, .panel-middle, .panel-bottom {
          margin-bottom: 10px;
          max-height: 200px;
          overflow-y: scroll;
          display: flex;
          font-size: 14px;
          gap: 10px;
          flex-direction: column;
          justify-content: flex-start;
          border: 1px solid #6f391c;
          padding: 10px;
          border-radius: 2px;
          width: 95%;
          align-items: center;
        }

        .panel-middle button,
        .panel-bottom button,
        .skill-detail-panel button {
          border: 1px solid #6F391C;
          background: linear-gradient(to bottom, #E47F47, #CE6633, #963D1C);
          box-shadow: inset 0px 0px 2px 1px #87431F;
          font-size: 12px;
          border-radius: 5px;
          color: #F9DE9B;
          padding: 4px 6px;
          cursor: pointer;
          transition: transform 0.1s, box-shadow 0.1s;
          width: 60px;
        }
        
        .applied-skill {
          display: flex;
          justify-content: space-between;
          align-items: center;
          gap: 20px;
          width: 100%;
          flex-direction: row;
        }
        .core-area .skills div {
            padding: 5px;
            margin: 5px 0px;
            text-align: center;
            border-radius: 5px;
            font-size: 12px;
            box-shadow: 0px 0px 1px 1px rgb(200 255 255);
            box-sizing: border-box;
            cursor: pointer;
            background-color: hsl(202deg 64% 33% / 70%);
            color: #b6ffff;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }
        .core-area .skills .s-skill {
            border: 1px solid #e8f3ee;
            background-color: hsl(202deg 50% 40% / 70%);
            box-shadow: inset 0px 0px 10px 0px hsl(202 53% 84% / 1);
        }
        .core-area .skills .ss-skill {
            border: 2px solid #e8f2ed;
            box-shadow: 0px 0px 4px 1px #e2e8e3;
            background-color: hsl(190deg 60% 55% / 50%);
            font-weight: bold;
        }
        .core-area .skills .sss-skill {
            border: 2px double #e8f3ee;
            box-shadow: 0px 0px 5px 2px rgb(0 0 0 / 50%);
            background-color: hwb(211deg 0% 56% / 60%);
            font-weight: bold;
            color: #f1f8ff;
            text-shadow: 0 0 5px gold;
        }
        .bottom-bar .info {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            margin: 5px;
            font-size: 14px;
            gap: 5px;
            width: 200px;
            align-items: center;
        }
        .bottom-bar .info div {
        height: 20px;
        }
        .description-box {
            margin: 5px;
            padding: 10px;
            width: 89%;
            background-color: hsl(0deg 0% 100% / 39%);
            border-radius: 10px;
            text-align: left;
            border: 1px groove aliceblue;
            font-size: 14px;
            color: #6f391c;
        }
        .treasure-description-box {
            gap: 4px;
            display: flex;
            flex-direction: column;
            padding: 10px 20px 0px 20px;
            margin: 0px 5px;
            min-height: 80px;
            align-items: stretch;
            border: 1px solid #834a0f;
            box-shadow: 0px 0px 0px 1px #7e5a2f;
            color: black;
            font-size: 16px;
        }
        .jinnang-description-box {
            gap: 4px;
            display: flex;
            flex-direction: column;
            padding: 10px 20px 0px 20px;
            margin: 0px 5px;
            min-height: 80px;
            align-items: stretch;
            border: 1px solid #834a0f;
            box-shadow: 0px 0px 0px 1px #7e5a2f;
            color: black;
            font-size: 14px;
        }
        .pet-selector {
            width: 80px;
            padding: 4px;
            border-radius: 10px;
            text-align: center;
        }
        .pet-selector select {
            padding: 2px;
            font-size: 14px;
            border-radius: 5px;
            background-color: hsl(0deg 0% 100% / 40%);
            border: 1px solid #ccc;
            width: 100%;
            color: #6f391c;
            text-align: center;
        }
        .battle-pet-selector {
            padding: 5px;
            background-color: rgba(0,0,0,0.6);
            margin-bottom: 5px;
            border-radius: 10px;
            text-align: center;
            color: white;
            display: none;
        }
        .battle-pet-selector select {
            font-size: 16px;
            color: #ffffff;
            border-radius: 5px;
            background-color: #ffffff75;
            border: 1px solid #ccc;
            width: 100%;
        }
        .pet-image {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .pet-image img {
            width: 180px;
            height: 180px;
            border-radius: 10px;
            box-shadow: 0px 0px 2px 0px #003670;
            cursor: pointer;
        }
        .info-card {
            display: none;
            width: 90%;
            margin: 10px 0;
            padding: 10px;
            background-color: #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            border-radius: 10px;
        }
        .info-card.active {
            display: block;
        }
        .info-card {
            width: 100%;
            background-color: #e0e0e0;
            border-radius: 5px;
            overflow: hidden;
            margin-bottom: 10px;
        }
        .info-card div {
            height: 20px;
            background-color: #e4bb5c;
            text-align: right;
            padding-right: 5px;
            color: white;
            border-radius: 5px;
        }

        .quality-bar-container {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 5px;
            position: relative;
            padding: 0px 5px;
        }
        #quality-pill-num-1, #quality-pill-num-2, #quality-pill-num-3, #quality-pill-num-4, #quality-pill-num-5 {
            position: absolute;
            top: 10px;
            left: 95%;
            transform: translateX(-50%);
            color: white;
            font-size: 16px;
            font-weight: bold;
            pointer-events: none; /* 确保数字不会干扰鼠标事件 */
        }
        
        
        .progress-bar {
        }
        .progress-bar div {
            height: 20px;
            background-color: #e4bb5c;
            text-align: right;
            padding-right: 5px;
            color: white;
        }
        .quality-drawer {
            position: fixed;
            bottom: 0;
            width: 100%;
            background-color: #ffffff;
            box-shadow: 0 -2px 4px rgba(0,0,0,0.1);
            border-radius: 10px 10px 0 0;
            transform: translateY(100%);
            transition: transform 0.3s;
        }
        .quality-drawer.open {
            transform: translateY(0);
        }
        .drawer-toggle {
            padding: 5px;
            text-align: center;
            background-image: url(https://pic.imgdb.cn/item/66bf32d9d9c307b7e9995d58.png);
            background-repeat: repeat;
            background-size: contain;
            color: #E3A73B;
            cursor: pointer;
            box-shadow: inset 0px 1px 2px 0px #E3A73B;
            border: 1px solid black;
        }
        .quality-info {
            display: none;
        }
        .quality-info.open {
            display: block;
            \: repeat;
            background: #B07638;
            padding: 4px;
            box-shadow: inset 0px 0px 3px 1px #92341C;
            border: 1px solid black;
        }
        .quality-info .progress-bar {
            width: 100%;
            background-color: #30482C;
            overflow: hidden;
            font-size: 14px;
            height: 100%;
            color: #EFEFF0;
            box-shadow: inset 0px 0px 2px 2px #111919;
        }
        .quality-info .progress-bar div {
            height: 10px;
            background: linear-gradient(to bottom, #34773D, #34773D, #69E055, #69E055, #34773D, #34773D);
            text-align: right;
            color: white;
        }
        /* 商店抽屉的样式优化 */
        .shop-drawer {
            position: fixed;
            bottom: 0;
            width: 100%;
            background-color: #fff;
            box-shadow: 0 -2px 4px rgba(0,0,0,0.1);
            border-radius: 10px 10px 0 0;
            transition: transform 0.3s;
            transform: translateY(100%);
        }
        .shop-drawer.open {
            transform: translateY(0);
        }
        .shop-info {
            display: none;
            padding: 4px;
        }
        .shop-info.open {
            display: block;
            background-image: url(https://pic.imgdb.cn/item/663885620ea9cb14033e4f6e.png);
            background-repeat: repeat;
            background-size: auto;
            border: 1px solid black;
        }
        .shop-items {
            display: grid;
            margin: 0px;
            font-size: 12px;
            grid-template-columns: repeat(3, 1fr);
            gap: 2px;
            overflow-x: hidden;
        }
        .shop-item {
            text-align: center;
            cursor: pointer;
            border: 1px solid rgb(136 80 18);
            di's'padding: disp;
            di'speak: dis';
            display: flex;
            flex-direction: row;
            justify-content: flex-start;
            padding: 4px;
            align-items: center;
        }
        .shop-item.selected {
            border-color: rgb(255 255 255 / 90%);
            box-shadow: inset 0px 0px 0px 2px red;
        }
        .shop-bar {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
            flex-direction: row;
            flex-wrap: wrap;
            margin-bottom: 10px;
        }
        .shop-bar button {
            border: 1px solid #6F391C;
            background: linear-gradient(to bottom, #E47F47, #CE6633, #963D1C);
            box-shadow: inset 0px 0px 2px 1px #87431F;
            font-size: 14px;
            border-radius: 5px;
            color: #F9DE9B;
            padding: 4px 6px;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.1s;
        }
        .scalping-display {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            background: rgb(0 0 0 / 80%);
            padding: 2px;
            border-radius: 2px;
            color: #87431f;
            font-size: 16px;
            height: 100%;
            background-image: url('https://pic.imgdb.cn/item/66ea60acf21886ccc04b6877.jpg');
            background-position: center;
            background-size: cover;
            background-repeat: no-repeat;
            z-index: 9999;
        }
        .scalping-head-button {
            background: transparent;
            color: #fff;
            box-shadow: 0px 0px 2px 1px #6f391c;
        }
        .scalping-container {
            width: 95%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            background-image: url(https://pic.imgdb.cn/item/663885620ea9cb14033e4f6e.png);
            background-repeat: repeat;
            background-size: auto;
            border: 1px solid black;
            padding: 5px;
            justify-content: space-between;
        }
        .select-gadgets {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 95%;
            max-height: 80%;
            background-color: rgba(0, 0, 0, 0.8);
            color: #6f391c;
            border-radius: 2px;
            justify-content: center;
            flex-direction: column;
            align-items: center;
            background-image: url(https://pic.imgdb.cn/item/663885620ea9cb14033e4f6e.png);
            background-repeat: repeat;
            background-size: auto;
            border: 1px solid #6f391c;
        }
        
        .scalping-top-bar {
            font-weight: bold;
            width: 95%;
            overflow: hidden;
            display: flex;
            margin-bottom: 0px;
            flex-direction: row;
            justify-content: space-around;
            align-items: center;
            color: white;
            background: rgb(57, 87, 89);
            box-shadow: rgb(30, 46, 47) 0px 0px 5px 2px inset;
            height: 45px;
        }
        .scalping-asset-area {
            width: 95%;
            display: flex;
            flex-direction: row;
            justify-content: space-around;
            border: 2px solid #87431f;
            align-items: center;
            flex-wrap: nowrap;
            height: 55px;
        }
        .scalping-middle-wrap {
            width: 100%;
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: flex-start;
            gap: 10px;
        }
        .scalping-detail-list {
            width: 45%;
            display: flex;
            border-radius: 2px;
            flex-direction: column;
            align-items: center;
            border: 2px solid #6f391c;
            padding: 2px;
            min-height: 100px;
        }
        
        .scalping-warehouse {
            width: 45%;
            display: flex;
            flex-direction: column;
            align-items: center;
            border: 2px solid #6f391c;
            min-height: 100px;
            padding: 2px;
        }
        
        .scalping-bottom-area {
            display: flex;
            justify-content: space-between;
            width: 95%;
            padding: 5px;
            height: 40px;
            align-items: center;
        }

        .stock-panel {
            display: flex;
        }
        
        .quality-info button:active {
            background-color: #074b02;
        }
        .quality-info button {
            border: 1px solid #6F391C;
            background: linear-gradient(to bottom, #E47F47, #CE6633, #963D1C);
            box-shadow: inset 0px 0px 2px 1px #87431F;
            font-size: 12px;
            border-radius: 5px;
            color: #F9DE9B;
            padding: 2px 6px;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.1s;
            margin: 2px;
        }
        .shop-bar button:active {
            background-color: #064701;
        }
        .shop-timer {
            display: flex;
            align-items: center;
            font-size: 12px;
        }
        .shop-timer button {
            border: 1px solid #6F391C;
            background: linear-gradient(to bottom, #E47F47, #CE6633, #963D1C);
            box-shadow: inset 0px 0px 2px 1px #87431F;
            font-size: 14px;
            border-radius: 5px;
            color: #F9DE9B;
            padding: 4px 6px;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.1s;
        }
        .shop-timer button:active {
            background-color: #064701;
        }
        .attribute-info button {
            margin: 0px 2px;
            border: 1px solid #6F391C;
            background: linear-gradient(to bottom, #E47F47, #CE6633, #963D1C);
            box-shadow: inset 0px 0px 2px 1px #87431F;
            font-size: 12px;
            border-radius: 5px;
            color: #F9DE9B;
            padding: 0px 6px;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.1s;
        }
        .attribute-info button:active {
            background-color: #064701;
        }
        
        /* 属性面板样式 */
        .attribute-drawer {
            position: fixed;
            bottom: 0;
            width: 100%;
            background-color: #fff;
            box-shadow: 0 -2px 4px rgba(0,0,0,0.1);
            border-radius: 10px 10px 0 0;
            transition: transform 0.3s;
            transform: translateY(100%);
        }
        .attribute-drawer.open {
            transform: translateY(0);
        }
        .attribute-info {
            display: none;
            padding: 4px;
        }
        .attribute-info.open {
            display: block;
            background: #B07638;
            padding: 4px;
            box-shadow: inset 0px 0px 3px 1px #92341C;
            border: 1px solid black;
        }
        .attribute-info .progress-bar {
            width: 100%;
            overflow: hidden;
            display: flex;
            margin-bottom: 0px;
            flex-direction: row;
            justify-content: space-between;
            align-items: center;
            color: white;
            background: rgb(57, 87, 89);
            box-shadow: rgb(30, 46, 47) 0px 0px 5px 2px inset;
            padding: 2px 4px;
        }
        .attribute-info .progress-bar div {
            height: 20px;
            background-color: #e4bb5c;
            text-align: right;
            padding-right: 5px;
            color: white;
            border-radius: 5px;
        }
        .attributes-container {
            display: flex;
             /* 使两个子容器分布在容器的两边 */
             /* 调整两列之间的间距 */
            font-size: 14px;
            flex-direction: row;
            justify-content: space-between;
            min-height: 300px;
            background-image: url(https://pic.imgdb.cn/item/66a89fd8d9c307b7e9f8bbf3.gif);
            background-size: cover;
            margin-bottom: 10px;
            margin-top: 5px;
        }
        .progress-bars {
            display: flex;
            gap: 5px; /* 调整每个条目之间的间距 */
            flex-direction: column;
            justify-content: space-between;
            min-width: 150px;
            padding: 10px;
        }
        .secondary-attributes {
            
             /* 调整每个条目之间的间距 */
            flex-wrap: nowrap;
            display: flex;
            gap: 5px;
            flex-direction: column;
            justify-content: space-between;
            width: 170px;
            padding: 10px;
            align-items: center;
        }
        .image-frame {
            display: flex;
            /* 设置图片框的尺寸，可以根据需要调整 */
            width: 140px;
            padding: 60px 0px;
            height: 140px;
             /* 添加边框 */
            margin: 0px; /* 在容器内垂直居中 */
            top: 50%;
            left: 50%;
            align-items: center;
            flex-wrap: nowrap;
            flex-direction: column;
        }
        .attributes-container .increase-btn {
            background-color: #0a8c00; /* 绿色 */
            border: none;
            color: #fff;
            padding: 1px 5px;
            text-align: justify;
            text-decoration: none;
            display: flow;
            font-size: 12px;
            gap: 0px;
            margin: 0px 0px 0px 0px;
            cursor: pointer;
            border-radius: 5px;
        }    
        
        .attributes-container .increase-btn:hover {
            background-color: #45a049; /* 深绿色 */
        }

        .quality-container {
            display: flex;
             /* 使两个子容器分布在容器的两边 */
            gap: 2px; /* 调整两列之间的间距 */
            padding: 2px;
            width: 100%;
            flex-direction: row;
            justify-content: space-between;
        }
        
        .quality-details {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            padding: 5px;
             /* 调整每个条目之间的间距 */
            font-size: 14px;
            width: 95%;
            align-items: center;
            justify-items: start;
        }
        .image-frame img {
            max-width: 100%;
            max-height: 100%;
        }
        .button-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px 0px; /* 调整按钮之间的间距 */
            align-items: stretch;
            justify-items: stretch;
            margin-bottom': 1';
            margin: 10px 0px 10px 0px;
        }
        .button-grid button {
            /* 你可以在这里添加更多的样式来定制按钮的外观 */
            border: 1px solid #6F391C;
            background: linear-gradient(to bottom, #E47F47, #CE6633, #963D1C);
            box-shadow: inset 0px 0px 2px 1px #87431F;
            font-size: 12px;
            border-radius: 5px;
            color: #F9DE9B;
            padding: 6px 2px;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.1s;
        }
        .treasure-drawer {
            position: fixed;
            bottom: 0;
            width: 100%;
            background-color: #fff;
            box-shadow: 0 -2px 4px rgba(0,0,0,0.1);
            border-radius: 10px 10px 0 0;
            transform: translateY(100%);
            transition: transform 0.3s;
        }
        .treasure-drawer.open {
            transform: translateY(0);
            display: block;
            background: #B07638;
            box-shadow: inset 0px 0px 3px 1px #92341C;
            border: 1px solid black;
        }
        .treasure-info {
            display: none;
            padding: 5px;
        }
        .treasure-info.open {
            display: block;
            padding: 2px;
            border-radius: 2px;
            background-color: #DFBF6E;
            color: #92341c;
            background-image: url(https://pic.imgdb.cn/item/663885620ea9cb14033e4f6e.png);
            background-repeat: repeat;
            background-size: auto;
            border: 1px solid black;
        }
        .treasure-bar {
            display: flex;
            justify-content: space-around;
            margin: 5px;
            border: 1px solid black;
            padding: 4px;
            box-shadow: 0px 0px 0px 1px #7e5a2f;
        }
        .reward-box {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            background-color: #f1f0f0;
            background-image: url(https://pic.imgdb.cn/item/66a3499ed9c307b7e9501161.png);
            background-size: cover;
            background-position: center;
            text-align: center;
            justify-content: center;
            margin: 15px 5px;
            padding: 40px 30px 30px 30px;
            min-height: 220px;
            border: 1px solid black;
            box-shadow: 0px 0px 0px 1px #7e5a2f;
        }
        .reward-box img {
            width: 45px;
            height: 45px;
        }
        .treasure-action {
            display: flex;
            justify-content: space-around;
            margin-top: 15px;
            margin-bottom: 15px;
        }
        .treasure-action button, .scalping-container button {
            border: 1px solid #6F391C;
            background: linear-gradient(to bottom, #E47F47, #CE6633, #963D1C);
            box-shadow: inset 0px 0px 2px 1px #87431F;
            font-size: 14px;
            border-radius: 5px;
            color: #F9DE9B;
            padding: 4px 6px;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.1s;
        }
        .treasure-action button:active {
            background-color: #064701;
        }
        .wuxing-action {
            display: flex;
            justify-content: space-around;
            width: 100%;
        }
        .wuxing-action button {
            border: 1px solid #6F391C;
            background: linear-gradient(to bottom, #E47F47, #CE6633, #963D1C);
            box-shadow: inset 0px 0px 2px 1px #87431F;
            font-size: 14px;
            border-radius: 5px;
            color: #F9DE9B;
            padding: 4px 6px;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.1s;
            flex: 0.2;
        }
        .wuxing-action button:active {
            background-color: #064701;
        }
        .transform-pet-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.3);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .transform-pet-modal {
            width: 95%;
            position: relative;
            border-radius: 2px;
            background-color: #DFBF6E;
            color: #92341c;
            background-image: url(https://pic.imgdb.cn/item/663885620ea9cb14033e4f6e.png);
            background-repeat: repeat;
            background-size: auto;
            border: 1px solid black;
            padding: 0px 1px 0px 1px;
            box-shadow: inset 0px 0px 2px 1px #92341c;
        }
        
        .transform-pet-title {
            text-align: center;
            padding: 5px;
            background-image: url(https://pic.imgdb.cn/item/66bf32d9d9c307b7e9995d58.png);
            background-repeat: repeat;
            background-size: contain;
            color: #E3A73B;
            cursor: pointer;
            box-shadow: inset 0px -1px 2px 0px #E3A73B, 0px -1px 5px 1px #8D5325;
            border: 1px solid black;
            margin: 0;
            font-size: 16px;
        }
        
        .transform-pet-close-button {
            position: absolute;
            top: 3px;
            right: 5px;
            cursor: pointer;
            font-size: 18px;
            color: white;
            background: linear-gradient(to bottom, #DBBA89,#84522C,#7C3411,#AC4B1D,#C85E24);
            width: 22px;
            height: 22px;
            text-align: center;
            border-radius: 2px;
            border: 1px solid #977025;
            box-shadow: 0px 0px 0px 1px #321C0C,inset 0px 0px 0px 1px #321C0C;
        }
        
        .transform-pet-specializations {
            display: flex;
            flex-direction: column;
            box-shadow: inset 0px 0px 0px 2px #6f391c;
            width: 100%;
        }
        
        .transform-pet-spec {
            display: flex;
            flex-flow: row;
            color: #92341c;
            border-bottom: 2px solid #6f391c;
            flex-direction: row;
            width: 100%;
            align-content: space-around;
            flex-wrap: wrap;
        }
        
        .transform-pet-spec-icon {
            width: 50px;
            height: 50px;
            margin-right: 5px;
            margin-left: 5px;
            border: 1px solid rgba(0, 0, 0, 0.8);
        }
        
        .transform-pet-spec-info {
            text-align: left;
            flex-grow: 1;
            font-size: 14px;
            height: 100%;
            padding: 10px;
            width: 100%;
            display: flex;
            gap: 0px 20px;
            flex-direction: row;
            flex-wrap: wrap;
            justify-content: flex-start;
            align-items: center;
        }
        
        .transform-pet-spec-description {
            font-size: 14px;
        }
        
        .transform-pet-buttons {
            display: flex;
            gap: 10px 0px;
            justify-content: space-between;
            flex-direction: row;
            width: 100%;
        }
        
        .transform-pet-button {
            border: 1px solid #6F391C;
            background: linear-gradient(to bottom, #E47F47, #CE6633, #963D1C);
            box-shadow: inset 0px 0px 2px 1px #87431F;
            font-size: 14px;
            border-radius: 5px;
            color: #F9DE9B;
            padding: 4px 6px;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.1s;
            flex: 0.2;
        }

        
        /* 锦囊抽屉样式 */
        .jinnang-drawer {
            position: fixed;
            bottom: 0;
            width: 100%;
            background-color: #e0b352;
            box-shadow: 0 -2px 4px rgba(0,0,0,0.1);
            transform: translateY(100%);
            transition: transform 0.3s;
            align-content: center;
        }
        .jinnang-drawer.open {
            transform: translateY(0);
            background: #6f391c;
            border-radius: 2px;
            color: #92341c;
            background-image: url(https://pic.imgdb.cn/item/663885620ea9cb14033e4f6e.png);
            background-repeat: repeat;
            background-size: auto;
            border: 1px solid black;
        }
        .jinnang-info {
            padding: 5px;
            justify-items: center;
        }
        .jinnang-info.open {
            display: block;
        }
        .jinnang-reward {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 2px 2px;
            justify-content: center;
            margin-top: 5px;
            font-size: 12px;
            justify-items: stretch;
            align-items: center;
        }
        .jinnang-reward img {
            width: 40px;
            height: 40px;
        }
        .red-text {
            color: #0bd200;
        }
        .gold-text {
            color: hsl(4 96% 70% / 1);
        }
        .blue-text {
            color: #51b5fd;
        }
        .message-box {
            display: none;
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #fff;
            padding: 10px;
            border: 1px solid #ccc;
            z-index: 1000;
            text-align: center; /* 中心对齐 */
            border-radius: 5px; /* 圆角 */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); /* 添加阴影 */
        }
        
        .message-box button {
            margin-top: 10px; /* 按钮与文本之间的间距 */
            padding: 5px 10px; /* 按钮内边距 */
            background-color: #0a8c00; /* 按钮背景颜色 */
            color: white; /* 按钮文本颜色 */
            border: none; /* 去除边框 */
            border-radius: 3px; /* 按钮圆角 */
            cursor: pointer; /* 鼠标指针样式 */
        }
        
        .message-box button:hover {
            background-color: #0056b3; /* 按钮悬停颜色 */
        }
        
        /* lottery.css */
        .lottery-drawer {
            position: fixed;
            margin: 0px 0px 0px 0px;
            padding: 20px 0px 0px 0px;
            bottom: 0px;
            width: 95%;
            background-color: rgb(255 255 255 / 90%);
            
             /* 图片平铺 */
             /* 保持原图大小 */
             /* 背景固定 */
            box-shadow: 0 -2px 4px rgba(0,0,0,0.1);
            border-radius: 10px 10px 0 0;
            transform: translateY(100%);
            transition: transform 0.3s;
            max-height: 90%;
            overflow-y: auto;
            background-image: url(https://pic.imgdb.cn/item/66ceec7fd9c307b7e9851687.gif);
            background-size: contain;
            background-repeat: no-repeat;
            display: flex;
            background-position: center;
            flex-direction: column;
        }
        
        .lottery-drawer.open {
            transform: translateY(0);
        }

        .lottery-section {
            padding: 5px 0px 10px 0px;
            display: flex;
            flex-direction: row;
            align-items: center;
            flex-wrap: wrap;
            align-content: space-around;
            justify-content: space-evenly;
        }
        
        .lottery-top {
            margin-bottom: 0px;
            display: flex;
        }
        .lottery-middle {
            margin-bottom: 0px;
            width: 100%;
            align-items: center;
        }
        .lottery-bottom {
            margin-bottom: 0px;
            width: 100%;
        }
        .lottery-footer {
            margin-bottom: 10px;
            width: 100%;
            display: flex;
        }
        .lottery-box {
            border: 1px solid #e0e0e0;
            border-radius: 5px;
            padding: 0px;
            margin: 5px 0;
            text-align: justify;
            background-color: #f9f9f9;
            font-weight: bold;
        }
        .lottery-number-box {
            font-weight: bold;
            width: 100%;
        }
        .lottery-number-box {
            border-radius: 5px;
            margin: 15px 0;
            text-align: center;
            background-color: hwb(0deg 98% 2% / 50%);
        }
        
        .lottery-number-box {
            display: flex;
            grid-template-columns: repeat(auto-fit, minmax(40px, 1fr));
            gap: 5px;
            padding: 0px;
            flex-direction: row;
            align-items: center;
            justify-content: center;
        }
        
        #lotteryNumberButtons button {
            margin: 5px;
            gap: 2px;
            padding: 5px;
            background-color: #ff1100;
            border-radius: 50%;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
        }
        
        #lotteryNumberButtons button:hover {
            background-color: #6a0700;
        }
        
        .lottery-controls {
            display: flex;
            justify-content: center;
            gap: 0px 10px;
            padding: 5px;
            flex-direction: row;
        }
        
        .lottery-footer button {
            width: 21%;
            display: flex;
            margin-top: 5px;
            background-color: #0a8c00;
            padding: 5px;
            color: rgb(255 255 255 / 90%);
            font-size: 16px;
            justify-content: center;
            border-radius: 10px;
        }
        
        .lottery-footer button:hover {
            background-color: #086600;
        }
        /* lottery.css */
        .lottery-controls button {
            padding: 2px 10px;
            margin: 2px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.3s;
        }
        
        .lottery-controls #lotteryBetButton {
            background-color: #0056b3;
            color: white;
        }
        
        .lottery-controls #lotteryBetButton:hover {
            background-color: #003670;
            transform: scale(1.05);
        }
        
        .lottery-controls #lotteryIncreaseBet {
            background-color: #0a8c00;
            color: white;
        }
        
        .lottery-controls #lotteryIncreaseBet:hover {
            background-color: #064701;
            transform: scale(1.05);
        }
        .lottery-controls #lotteryIncreaseThousandBet {
            background-color: #0a8c00;
            color: white;
        }
        
        .lottery-controls #lotteryIncreaseTenBet:hover {
            background-color: #064701;
            transform: scale(1.05);
        }
        .lottery-controls #lotteryRuleButton {
            background-color: #0056b3;
            color: white;
        }
        
        .lottery-controls #lotteryRuleButton:hover {
            background-color: #003670;
            transform: scale(1.05);
        }
        .lottery-controls #lotteryDecreaseBet {
            background-color: #dc3545;
            color: white;
        }
        
        .lottery-controls #lotteryDecreaseBet:hover {
            background-color: #841520;
            transform: scale(1.05);
        }
        /* lottery.css */
        .highlight {
            animation: highlight 1s ease-in-out;
        }
        
        @keyframes highlight {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.5);
            }
        }
        /* lottery.css */
        .modal {
            position: fixed;
            display: none;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.4);
        }
        
        .modal-content {
            background-color: rgb(255 255 255 / 90%);
            /* margin: 15% auto; */
            padding: 10px;
            border: 1px solid #888;
            width: 90%;
            max-width: 600px;
            border-radius: 10px;
        }
        
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }
        
        .close:hover,
        .close:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }
        .battle-system-drawer {
            display: none;
            position: fixed;
            right: 0px;
            top: 0;
            height: 100%;
            width: 100%;
            background: url('https://pic.imgdb.cn/item/66bc6806d9c307b7e987b92d.webp') no-repeat center center;
            background-size: cover;
            color: white;
            box-shadow: inset 0px 0 5px 1px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            overflow-y: auto;
            padding: 0px 0px 0px 0px;
        }
        
        #battle-system-drawer.show {
            display: block; /* 动画触发时显示 */
            animation: sliceIn 1s ease forwards;
        }
        
        @keyframes sliceIn {
            0% {
                clip-path: inset(0 50% 0 50%);
                opacity: 0;
            }
            50% {
                clip-path: inset(0 0 0 0);
                opacity: 1;
            }
            100% {
                clip-path: inset(0 0 0 0);
                opacity: 1;
            }
        }
        
        .battle-system-drawer-toggle {
            font-size: 24px;
            cursor: pointer;
            padding: 0px 0px 0px 0px;
            text-align: left;
        }
        
        .battle-system-content {
            display: flex;
            flex-direction: column;
            padding: 5px;
            width: 100%;
            justify-content: space-between;
        }
        
        .battle-system-info-wrapper {
            display: flex;
            width: 100%;
            flex-direction: row;
            flex-wrap: nowrap;
            gap: 2px;
        }
        
        .battle-system-pet-info, .battle-system-enemy-info {
            border: 1px solid #ccc;
            padding: 5px;
            margin-bottom: 10px;
            font-size: 12px;
            flex: 1;
            display: flex;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 5px;
            line-height: 14px;
            min-height50%: 5;
            flex-direction: column;
        }
        /* 非暴击时，快速渐进渐出 */
        .normal-hit-animation {
            animation: fadeInOut 300ms ease-in-out forwards;
        }
        
        /* 暴击时，震荡效果 */
        .critical-hit-animation {
            animation: shake 300ms ease-in-out forwards;
        }
        
        /* 生命恢复，向上渐出 */
        .heal-animation {
            animation: healMoveUp 300ms ease-in-out forwards;
        }
        
        /* 定义动画：渐进渐出 */
        @keyframes fadeInOut {
            0% {
                opacity: 0;
                transform: scale(0.8);
            }
            50% {
                opacity: 1;
                transform: scale(1);
            }
            100% {
                opacity: 0;
                transform: scale(1.2);
            }
        }
        
        /* 定义动画：震荡效果 */
        @keyframes shake {
            0% {
                transform: translateX(0);
            }
            25% {
                transform: translateX(-5px);
            }
            50% {
                transform: translateX(5px);
            }
            75% {
                transform: translateX(-5px);
            }
            100% {
                transform: translateX(0);
            }
        }
        
        /* 定义动画：向上渐出 */
        @keyframes healMoveUp {
            0% {
                opacity: 0;
                transform: translateY(20px);
            }
            50% {
                opacity: 1;
                transform: translateY(0);
            }
            100% {
                opacity: 0;
                transform: translateY(-20px);
            }
        }
        .frozen-effect {
            background-color: linear-gradient(to bottom, #477AD6, #8FF1FD, #477AD6);
            text-align: center;
        }
        .player-damage-display {
            color: #f6ff00;
            position: absolute;
            top: 10%;
            left: 65%;
            font-size: 24px;
            font-weight: bold;
            font-style: italic;
            text-shadow: 0 0 2px black;
        }

        .enemy-damage-display {
            color: #f6ff00;
            position: absolute;
            top: 10%;
            left: 15%;
            font-size: 24px;
            font-weight: bold;
            font-style: italic;
            z-index: 9999;
        }

        .player-extra-damage-display {
            color: #f6ff00;
            position: absolute;
            top: 7%;
            left: 65%;
            font-size: 24px;
            font-weight: bold;
            font-style: italic;
            text-shadow: 0 0 2px black;
            z-index: 9999;
        }

        .enemy-extra-damage-display {
            color: #f6ff00;
            position: absolute;
            top: 7%;
            left: 15%;
            font-size: 24px;
            font-weight: bold;
            font-style: italic;
        }
        
        .battle-system-log {
            border: 1px solid #ccc;
            padding: 5px;
            margin-bottom: 0px;
            max-height: 380px;
            overflow-y: clip;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 5px;
            width: 97%;
        }
                /* 直接针对日志内容的样式 */
        #log {
            display: block;
            unicode-bidi: isolate;
            overflow-y: auto;
            max-height: 75%;
            line-height: 20px;
        }

        /* 日志条目的样式 */
        #log p {
            margin: 0;
            padding: 2px 0;
        }
        
        .battle-system-actions {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 10px 5px;
            width: 100%;
            margin-top: 10px;
            flex-direction: row;
            flex-wrap: nowrap;
        }
        
        .battle-system-actions button {
            padding: 5px;
            cursor: pointer;
            border: 1px solid #ffffff;
            width: 100%;
            background-color: rgb(0 0 0 / 60%);
            color: #ffffff;
            font-size: 14px;
            text-align: center;
            border-radius: 5px;
            transition: background-color 0.3s;
            font-family: 'Noto Serif SC', sans-serif;
        }
        
        .battle-system-actions button:hover {
            background-color: #00367080;
        }
        #drug-system-actions {
            padding: 5px;
            cursor: pointer;
            border: 1px solid #ffffff;
            width: 100%;
            background-color: #0a8c00;
            color: #ffffff;
            font-size: 14px;
            text-align: center;
            border-radius: 5px;
            transition: background-color 0.3s;
        }
        #drug-system-actions button {
            padding: 5px;
            cursor: pointer;
            border: 1px solid #ffffff;
            width: 100%;
            background-color: #0a8c00;
            color: #ffffff;
            font-size: 14px;
            text-align: center;
            border-radius: 5px;
            transition: background-color 0.3s;
        }
        
        #drug-system-actions button:hover {
            background-color: #064701;
        }
        #visualEffectsContainer {
            position: relative;
            width: 95%;
            height: 0px;
        }
        @keyframes critical-hit {
            0% {
                border: 5px solid red;
            }
            100% {
                border: 1px solid rgb(255 255 255 / 0%);
            }
        }
        
        .battle-system-log.critical-hit {
            animation: critical-hit 0.3s forwards;
        }
        
        .visual-effect {
            position: absolute;
            width: 50px;
            height: 50px;
            background-color: rgb(0 0 0 / 0%);
            border-radius: 50%;
            opacity: 0;
            transform: scale(0);
            transition: transform 0.5s ease, opacity 0.5s ease;
        }
        .battleOverlay {
            display: none; /* 默认不显示 */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0);
            z-index: 9999; /* 确保遮罩在最顶层 */
            justify-content: center;
            align-items: center;
        }

        .battleOverlayContainer {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: space-between;
            align-items: stretch;
            background-color: transparent;
            flex-direction: column;
        }
        
#visualEffectsContainer {
    position: relative;
    width: 50%;
    pointer-events: none; /* 确保特效不影响页面其他交互 */
    height: 0%;
}

.visual-effect {
    position: absolute;
    width: 100px;
    height: 100px;
    opacity: 0;
    transform: scale(0);
    transition: opacity 0.3s, transform 0.3s;
    background-size: cover;
    background-repeat: no-repeat;
    background-position: center;
    z-index: 9999;
}

.general-visual-effect {
    position: absolute;
    width: 200px;
    height: 200px;
    opacity: 0;
    transform: scale(0);
    transition: opacity 0.3s, transform 0.3s;
    background-size: contain;
    background-repeat: no-repeat;
    background-position: center;
}

#generalEffect {
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    z-index: 0;
}
        
#playerEffect {
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    opacity: 0.9;
}

#enemyEffect {
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    opacity: 0.9;
}

.show-effect {
    opacity: 1;
    transform: scale(1);
    display:block;
}

        .status-display {
            font-size: 14px;
            color: #ff0000;
            font-weight: bold;
            height: 5px;
            margin-bottom: 10px;
        }
        #battle-spirit-modal {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            width: 80%;
            border: 2px solid #ccc;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            z-index: 9999;
            border-radius: 10px;
        }
        
        #battle-spirit-modal .modal-content {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        #battle-spirit-modal button {
            background: #a70b00;
            border-color: #fff;
            color: white;
            font-size: 14px;
            ga'padding: gap';
            border-radius: 5px;
            margin: 0px 5px 5px 0px;
            padding: 5px;
        }
        .ascension-skill-modal {
            display: none; /* 默认隐藏 */
            position: fixed;
            z-index: 1;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgb(0,0,0);
            background-color: rgba(0,0,0,0.4);
        }

        .saveAndLoadGameState {
            border: 1px solid #6F391C;
            background: linear-gradient(to bottom, #E47F47, #CE6633, #963D1C);
            box-shadow: inset 0px 0px 2px 1px #87431F;
            font-size: 14px;
            border-radius: 5px;
            color: #F9DE9B;
            padding: 2px 8px;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.1s;
        }
    
        .saveAndLoadGameState:hover {
            background-color: #ffd700; /* Slightly darker gold */
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
        }
    
        .saveAndLoadGameState:active {
            transform: scale(0.95);
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
        }
        
        .ascension-modal-content {
            background-color: rgb(0 0 0 / 40%);
            padding: 20px;
            border: 1px solid #888;
            width: 85%;
            top: 50%;
            left: 50%;
            position: absolute;
            transform: translate(-50%, -50%);
        }
        
        .ascension-close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }
        
        .ascension-close:hover,
        .ascension-close:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }
        
        .ascension-header {
            display: flex;
            align-items: center;
        }
        
        .ascension-icon {
            width: 75px;
            height: 75px;
        }
        
        .ascension-info {
            margin-left: 20px;
        }
        
        .ascension-body {
            margin-top: 20px;
        }
        
        .ascension-footer {
            margin-top: 20px;
            display: flex;
            justify-content: space-between;
        }
        
        .ascension-button {
            padding: 5px;
            font-size: 16px;
            color: white;
            cursor: pointer;
            border-radius: 10px;
            background-color: #003670;
            border-color: #ccc;
        }
        
        .ascension-skill-button {
            margin: 10px;
            padding: 10px;
            font-size: 16px;
            cursor: pointer;
        }


        
.drug-modal .modal {
    display: none;
    position: fixed;
    z-index: 1;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    overflow: auto;
    background-color: rgb(0, 0, 0);
    background-color: rgba(0, 0, 0, 0.4);
    padding-top: 60px;
}

.drug-modal .modal-content {
    background-color: rgb(0 0 0 / 60%);
    font-size: 14px;
    align-items: center;
    padding: 20px;
    border: 1px solid #888;
    display: flex;
    width: 80%;
    height: 500px;
    flex-direction: column;
    flex-wrap: wrap;
    justify-content: space-evenly;
    gap: 10px;
    top: 50%;
    position: absolute;
    left: 50%;
    transform: translate(-50%, -50%);
}

.drug-modal .use-button,
.drug-modal .close-button {
    background-color: #088c01; /* 绿色背景 */
     /* 无边框 */
    color: #fff; /* 白色文字 */
    padding: 2px 10px; /* 内边距 */
    text-align: center; /* 文字居中 */
    margin-top: 10px;
    margin-bottom: 10px;
    text-decoration: none; /* 无下划线 */
    display: flex; /* 行内块元素 */
    font-size: 16px; /* 字体大小 */
     /* 外边距 */
    cursor: pointer; /* 鼠标指针 */
    border-radius: 10px; /* 圆角边框 */
    border-color: white;
}

.drug-modal .use-button:hover,
.drug-modal .close-button:hover {
    background-color: #064701; /* 深绿色背景 */
}

.drug-modal .drug-grid {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 10px;
}

.drug-modal .drug-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    cursor: pointer;
}

.drug-modal .drug-description {
    margin: 0px 0px;
    font-size: 14px;
    width: 100%;
}
.drawer-container {
    padding: 2px;
    border-radius: 2px;
    background-color: #DFBF6E;
    color: #92341c;
    background-image: url(https://pic.imgdb.cn/item/663885620ea9cb14033e4f6e.png);
    background-repeat: repeat;
    background-size: auto;
    border: 1px solid black;
}
/* 通用弹出面板样式 */
.mission-popup-panel, .summon-popup-panel, .pet-shop-popup-panel {
    height: 500px;
    z-index: 1000;
    /* display: none; */

/* 召唤面板特定样式 */
.summon-popup-panel {
    width: 80%;
    height: 45%;
    font-size: 14px;
    background-color: rgba(0, 0, 0, 0.8);
    color: #ffffff;
    border-radius: 10px;
}

.summon-close-button {
    float: right;
    margin: -40px -10px 10px 10px;
}

.summon-area {
    height: 240px;
    display: flex;
    align-items: center;
    justify-content: space-around;
    padding: 10px;
    background-color: rgba(0, 0, 0, 0.8);
    margin-bottom: 20px;
    margin-top: 20px;
    flex-direction: column;
}

.summon-area
    img {
    max-width: 300px;
    max-height: 240px;
}

.stamp-quantity {
    text-align: center;
    font-size: 14px;
    font-weight: bold;
}

.summon-button-area {
    display: flex;
    justify-content: space-between;
    margin: 40px 0px 0px 0px;
}

.summon-button {
    flex: auto;
    margin: 0px 5px;
    background-color: #0a8c00;
    color: white;
    border-radius: 10px;
    border-color: white;
    font-size: 14px;
}

/* 宠物商店特定样式 */
.pet-shop-popup-panel {
    width: 80%;
    height: 90%;
    border-radius: 10px;
    background-color: rgba(0, 0, 0, 0.8);
    color: #ffffff;
}

.pet-shop-close-button {
    float: right;
    margin: -40px -10px 10px 10px;
}

.shop-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 2px 2px;
    justify-content: center;
    margin-top: 5px;
    font-size: 12px;
    justify-items: stretch;
    align-items: center;
}

.shop-item {
    text-align: center;
    :;
    padding: 5px;
}

.shop-item
    img {
    width: 40px;
    height: 40px;
}

.pet-shop-button {
    width: 100%;
    margin: 0px 0px 10px 0px;
    background-color: #0a8c00;
    color: white;
    border-radius: 10px;
    font-size: 14px;
    border-color: white;
}
        .container {
    text-align: center;
    padding: 10px;
    border-radius: 10px;
    font-size: 12px;
    margin: 30px 0px 0px 0px;
    }
        .container
    p {
            margin: 10px 0;
    font-size: 1.2em;
    font-weight: bold;
        }
        .container
    p::before, .container p::after {
            content: "*";
    margin: 0 5px;
        }
            /* 添加必要的样式，并加上唯一标识 petArms 前缀 */
        .petArms-window {
    position: fixed;
    background-color: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 10px;
    border-radius: 10px;
    z-index: 1000;
    width: 80%;
    height: 80%;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    overflow-y: auto;
    display: grid;
    grid-template-columns: repeat(1, 1fr);
    gap: 10px;
        }

        .petArms-red-text {
    color: red;
        }

        .petArms-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    background-color: rgba(255, 255, 255, 0.1);
    padding: 10px;
    border-radius: 5px;
        }

        .petArms-item
    img {
            width: 45px;
    height: 45px;
        }

        .petArms-close-button {
    position: absolute;
    top: 10px;
    right: 10px;
        }
        .locked {
    background-color: gray;
    color: white;
        }
    .info-header {
    display: flex;
    align-items: center;
    width: 100%;
    border: 1px solid #ccc;
    padding: 5px;
    margin-bottom: 10px;
}
    
.drug-grid-container {
    height: 240px;
    overflow-y: scroll;
    margin-top: 20px;
}
    
.avatar {
    width: 25px;
    height: 25px;
    margin-right: 10px;
}

.info-text {
    flex-grow: 1;
}
   </style>
</head>
<body>
    <div id="loadingOverlay">
        <div id="loadingText">加载中... 0%</div>
        <div id="progressBarContainer">
            <div id="progressBar"></div>
        </div>
    </div>
    <div id="baiyinOverlay"></div>
    <div id="unlockOverlay" style="display: none;">
        <div style="font-size:16px; margin:10px; ">请输入解锁密令(联系QQ：1060028177)</div>
        <input type="password" id="unlockCode" />
        <div style="display:flex;">
            <button id="unlockButton"style="margin: 20px;font-size: 16px;border-radius: 5px;background: green;color: white;">解锁</button>
            <button onclick="guestPlay()"style="margin: 20px;font-size: 16px;border-radius: 5px;background: green;color: white;">试玩</button>
        </div>
        <div id="errorMessage" style="color: red; display: none;">密令错误，请重试。</div>
    </div>
    <div id="petOverview">
        <!-- 关闭按钮 -->
        <button class="close-button" onclick="togglePetOverview()">关闭</button>
        <!-- Pet containers will be dynamically generated here -->
    </div>
    <!-- 五行符管理界面 -->
    <div id="wuxing-display" style="display: flex;flex-direction: column;justify-content: space-between;">
        <div id="wuxing-header">
            <h3 style="margin:0;" onclick="infoWuxingFu()">玩法</h3>
            <p style="margin:0;" id="wuxing-fragments">五行碎片: 0</p>
            <button style="background: transparent;color: white;" id="wuxing-close-button">X</button>
        </div>
        <div class="drawer-container"id="wuxingguanli-container">
            <div id="equipped-container"></div>
            <div id="applied-effects" style="width: 100%;text-align: center;font-size: 12px;font-weight: bold;">当前无五行符效果生效</div>
            <div id="wuxing-container"></div>
            <div id="amulet-details"></div>
        </div>
    </div>
    <div class="core-area-for-skills">
        <div class="buttons" style="width: 100%;">
            <div class="button-row">
                <button id="guideButton" onclick="showGuide()">玩法</button>
                <button id="missionButton" onclick="showMissionPanel()">任务</button>
                <button id="summonButton" onclick="showSummonPanel()">召唤</button>
                <button id="drawerButton" onclick="toggleDrawer()">资质</button>
                <button id="attributeButton" onclick="toggleAttributeDrawer()">属性</button>
                <button id="shopButton" onclick="toggleShop()">商店</button> 
                <button id="treasureButton" onclick="toggleTreasureDrawer()">宝箱</button>
                <button id="jinnangButton" onclick="toggleJinnangDrawer()">锦囊</button>
                <button id="fightingButton" onclick="toggleFightingDrawer()">战斗</button>
                <button id="lotteryButton" onclick="toggleLotteryDrawer()">彩票</button>
                <button id="divineButton" onclick="divinePage()">通灵</button>
                <button id="workButton" onclick="workPage()">打工</button>
            </div>
        </div>
    </div>
    <div class="core-area">
        <div class="advancement-container">
            <button id="advancement-learn" onclick="openAquireSkillAdvancementPanel()" class="advancement-series">领悟加成</button>
            <div id="fullscreenBtn" style="cursor: pointer;">参战宠物技能区域</div>
            <button id="advancement-apply" onclick="infoAdvancement()" class="advancement-series">领悟说明</button>
        </div>
        <div id="skill-advancement-panel" class="aquire-skill-advancement-panel" style="display: none;">
        <div class="drawer-toggle" onclick="openAquireSkillAdvancementPanel()">技能加成</div>
          <div style="padding: 10px;background-image: url(https://pic.imgdb.cn/item/663885620ea9cb14033e4f6e.png);background-repeat: repeat;background-size: auto;border: 1px solid black;">
          <div class="panel-top" style="overflow: hidden;display: flex;margin-bottom: 10px;flex-direction: row;justify-content: space-between;align-items: center;color: white;background: rgb(57, 87, 89);box-shadow: rgb(30, 46, 47) 0px 0px 5px 2px inset;">
            <div>亲密度: <span id="intimacy"></span></div>
            <div>集中值: <span id="attention"></span></div>
            <div>学习度: <span id="learning-value"></span></div>
          </div>
          <div class="panel-middle" style="display: flex;flex-direction: row;justify-content: space-between;">
            <div>技能点:<span id="skill-points"></span></div>
            <button id="aquire-skill-btn">领悟</button>
            <button id="reset-skill-btn">重置</button>
          </div>
          <div class="panel-bottom" id="applied-skills-list" style="height:200px;"></div>
          <div class="skill-detail-panel" id="advancement-detail-panel" style="overflow: hidden;margin-bottom: 0px;align-items: center;background: #e4bb5c;border: 1px solid #6f391c;border-radius: 2px;font-weight: bold;"></div>
        </div>
        </div>
        <div class="skills" id="skills-area"></div>
    </div>
    <div class="top-bar">
        <div>
            <img src="https://pic.imgdb.cn/item/66541c01d9c307b7e9208aea.png" alt="高级悟性丹">
            <div>悟性丹</div>
            <div><span id="high-grade-pill">100</span></div>
        </div>
        <div>
            <img src="https://pic.imgdb.cn/item/66541c01d9c307b7e9208add.png" alt="万化灵丹">
            <div>万化灵丹</div>
            <div><span id="transmutation-pill">20</span></div>
        </div>
        <div>
            <img src="https://pic.imgdb.cn/item/6654a944d9c307b7e9ca6423.png" alt="神兽还童丹">
            <div>还童丹</div>
            <div><span id="reborn-pill">20</span></div>
        </div>
        <div>
            <img src="https://pic.imgdb.cn/item/6655a92ad9c307b7e9c04265.png" alt="还童金丹">
            <div>还童金丹</div>
            <div><span id="golden-reborn-pill">5</span></div>
        </div>
        <div>
            <img src="https://pic.imgdb.cn/item/665ef0855e6d1bfa055800f4.png" alt="冰魄还童丹">
            <div>冰魄丹</div>
            <div><span id="bingpo-reborn-pill">5</span></div>
        </div>
        <div>
            <img src="https://pic.imgdb.cn/item/6654a944d9c307b7e9ca63f5.png" alt="资质重生丹">
            <div>资质金丹</div>
            <div><span id="quality-pill">20</span></div>
        </div>
        <div>
            <img src="https://pic.imgdb.cn/item/66556068d9c307b7e9681672.png" alt="灵异金丹">
            <div>灵异丹</div>
            <div><span id="miraculous-pill">1</span></div>
        </div>
    </div>
    <div class="quality-drawer" id="quality-drawer">
        <div class="drawer-toggle" onclick="toggleDrawer()">宠物资质</div>
        <div class="quality-info" id="quality-info">
            <div class="drawer-container">
                <div class="quality-container">
                    <div class="quality-details">
                        <div style="display: flex;gap: 10px;flex-direction: row;align-items: center;width: 100%;justify-content: flex-start;">名称: <span id="quality-name">小金牛</span></div>
                        <div style="display: flex;gap: 10px;flex-direction: row;align-items: center;width: 100%;justify-content: center;">品质: <span id="quality-tier">普通</span></div>
                        <div style="display: flex;gap: 10px;flex-direction: row;align-items: center;width: 100%;justify-content: flex-end;">成长率: <span id="quality-growth-rate">100%</span></div>
                        <div style="display: flex;gap: 10px;flex-direction: row;align-items: center;width: 100%;justify-content: flex-start;">变异: <span id="quality-mutated">未变异</span></div>
                        <div style="display: flex;gap: 10px;flex-direction: row;align-items: center;width: 100%;justify-content: center;">进化等级: <span id="evolution-level">0</span></div>
                        <div style="display: flex;gap: 10px;flex-direction: row;align-items: center;width: 100%;justify-content: flex-end;">当前悟性: <span id="current-wisdom">0</span></div>
                    </div>
                </div>
                <div class="quality-bar-container">
                    <div class="progress-bar">
                        耐力: <span id="endurance-current">1100</span><span id="endurance-pill-bonus"></span> / <span id="endurance-max">2200</span>
                        <div id="endurance-bar" style="width: 50%;"></div>
                    </div>
                    <div id="quality-pill-num-1">0</div>
                    <img id="quality-pill-1" src="https://pic.imgdb.cn/item/66caa91ad9c307b7e97841c0.png" style="width:35px;height:35px;border:1px solid #92341c;" alt="Quality-Pill-1">
                </div>
                <div class="quality-bar-container">
                    <div class="progress-bar">
                        智力: <span id="intelligence-current">1150</span><span id="intelligence-pill-bonus"></span> / <span id="intelligence-max">2250</span>
                        <div id="intelligence-bar" style="width: 50%;"></div>
                    </div>
                    <div id="quality-pill-num-2">0</div>
                    <img id="quality-pill-2" src="https://pic.imgdb.cn/item/66caa91ad9c307b7e97841c0.png" style="width:35px;height:35px;border:1px solid #92341c;" alt="Quality-Pill-2">
                </div>
                <div class="quality-bar-container">
                    <div class="progress-bar">
                        强壮: <span id="strength-current">1150</span><span id="strength-pill-bonus"></span> / <span id="strength-max">2250</span>
                        <div id="strength-bar" style="width: 50%;"></div>
                    </div>
                    <div id="quality-pill-num-3">0</div>
                    <img id="quality-pill-3" src="https://pic.imgdb.cn/item/66caa91ad9c307b7e97841c0.png" style="width:35px;height:35px;border:1px solid #92341c;" alt="Quality-Pill-3">
                </div>
                <div class="quality-bar-container">
                    <div class="progress-bar">
                        敏捷: <span id="agility-current">1100</span><span id="agility-pill-bonus"></span> / <span id="agility-max">2200</span>
                        <div id="agility-bar" style="width: 50%;"></div>
                    </div>
                    <div id="quality-pill-num-4">0</div>
                    <img id="quality-pill-4" src="https://pic.imgdb.cn/item/66caa91ad9c307b7e97841c0.png" style="width:35px;height:35px;border:1px solid #92341c;" alt="Quality-Pill-4">
                </div>
                <div class="quality-bar-container">
                    <div class="progress-bar">
                        信仰: <span id="faith-current">1150</span><span id="faith-pill-bonus"></span> / <span id="faith-max">2250</span>
                        <div id="faith-bar" style="width: 50%;"></div>
                    </div>
                    <div id="quality-pill-num-5">0</div>
                    <img id="quality-pill-5" src="https://pic.imgdb.cn/item/66caa91ad9c307b7e97841c0.png" style="width:35px;height:35px;border:1px solid #92341c;" alt="Quality-Pill-5">
                </div>
                <div class="button-grid">
                    <button onclick="rebornPet()">普通还童</button>
                    <button onclick="trainQuality()">一键还童</button>
                    <button onclick="useGoldenRebornPill()">还童金丹</button>
                    <button onclick="useBingpoRebornPill()">冰魄还童</button>
                    <button onclick="mutatePet()">变异宠物</button>
                    <button onclick="enhanceQuality()">更新资质</button>
                    <button onclick="evolvePet()">进化宠物</button>
                    <button onclick="awakenPet()">觉醒宠物</button>
                    <button onclick="hallucinatePet()">幻化提升</button> 
                    <button onclick="jumpToAttribute()">查看属性</button>
                </div>
                <div id="message-box" class="message-box">
                    <span id="message-text"></span>
                    <button onclick="closeMessage()">关闭</button>
                </div>
            </div>
        </div>
    </div>
    <div class="attribute-drawer" id="attribute-drawer">
        <div class="drawer-toggle" onclick="toggleAttributeDrawer()">属性</div>
        <div class="attribute-info" id="attribute-info">
            <div class="drawer-container">
                <div class="attributes-container">
                    <div class="progress-bars">
                        <div class="progress-bar">
                            等级: <span id="pet-level">1</span><button onclick="absorbExperience()">+</button>
                        </div>
                        <div class="progress-bar">
                            品质: <span id="attribute-tier"></span><button onclick="infoPinzhi()">?</button>
                        </div>
                        <div class="progress-bar">
                            幻化: <span id="hallucination-level">0</span><button onclick="fastHallucinatePet()">+</button>
                        </div>
                        <div class="progress-bar">
                            成长率: <span id="attribute-growth-rate"></span><button onclick="infoChengzhanglv()">?</button>
                        </div>
                        <div class="progress-bar">
                            寿命: <span id="attribute-life-span"></span><button onclick="infoShouming()">?</button>
                        </div>
                        <div class="progress-bar">
                            潜力点: <span id="remaining-points-display"></span><button onclick="infoQianlidian()">?</button>
                        </div>
                        <div class="progress-bar">
                            耐力: <span id="attribute-endurance"></span><span id="bonusAttribute-endurance"></span><button class="increase-btn" onclick="increaseBonusAttribute('endurance')">+</button>
                        </div>
                        <div class="progress-bar">
                            智力: <span id="attribute-intelligence"></span><span id="bonusAttribute-intelligence"></span><button class="increase-btn" onclick="increaseBonusAttribute('intelligence')">+</button>
                        </div>
                        <div class="progress-bar">
                            强壮: <span id="attribute-strength"></span><span id="bonusAttribute-strength"></span><button class="increase-btn" onclick="increaseBonusAttribute('strength')">+</button>
                        </div>
                        <div class="progress-bar">
                            敏捷: <span id="attribute-agility"></span><span id="bonusAttribute-agility"></span><button class="increase-btn" onclick="increaseBonusAttribute('agility')">+</button>
                        </div>
                        <div class="progress-bar">
                            信仰: <span id="attribute-faith"></span><span id="bonusAttribute-faith"></span><button class="increase-btn" onclick="increaseBonusAttribute('faith')">+</button>
                        </div>
                    </div>
                    <div class="secondary-attributes">
                            <div class="progress-bar">
                                觉醒: <span id="awaken-status">未觉醒</span><button onclick="infoJuexing()">?</button>
                            </div>
                            <div class="progress-bar">
                                飞升: <span id="ascension-status">未飞升</span><button onclick="infoFeisheng()">?</button>
                            </div>
                            <div class="progress-bar">
                                <button onclick="togglePetOverview()">评分</button><span id="skill-score">0</span><button onclick="infoPingfen()">?</button>
                            </div>
                            <div class="progress-bar">
                                <button onclick="infoXiuwei()">修为</button><span id="player-cultivation">0</span><button onclick="upgradePlayerCultivation()">+</button>
                            </div>
                            <div class="progress-bar">
                                <button onclick="infoWuxing()">悟性</button><span id="attribute-wisdom"></span><button onclick="upgradeWisdom()">+</button>
                            </div>
                            <div id="secondary-attributes-panel" style="gap: 4px;display: flex;flex-direction: column;width: 100%;background: rgb(57, 87, 89);box-shadow: rgb(30, 46, 47) 0px 0px 5px 2px inset;color: #77CFBA;padding: 4px;cursor:pointer;">
                                <div style="display: flex;flex-direction: row;justify-content: space-between;gap: 5px;align-items: center;">生命值: <span style="color: white;width: 60px;text-align: center;" id="secondary-health"></span> <span id="secondary-health-bonus"></span></div>
                                <div style="display: flex;flex-direction: row;justify-content: space-between;gap: 5px;align-items: center;">法力值: <span style="color: white;width: 60px;text-align: center;" id="secondary-mana"></span> <span id="secondary-mana-bonus"></span></div>
                                <div style="display: flex;flex-direction: row;justify-content: space-between;gap: 5px;align-items: center;">物理攻: <span style="color: white;width: 60px;text-align: center;" id="secondary-physical-attack"></span> <span id="secondary-physical-attack-bonus"></span></div>
                                <div style="display: flex;flex-direction: row;justify-content: space-between;gap: 5px;align-items: center;">物理防: <span style="color: white;width: 60px;text-align: center;" id="secondary-physical-defense"></span> <span id="secondary-physical-defense-bonus"></span></div>
                                <div style="display: flex;flex-direction: row;justify-content: space-between;gap: 5px;align-items: center;">法术攻: <span style="color: white;width: 60px;text-align: center;" id="secondary-magic-attack"></span> <span id="secondary-magic-attack-bonus"></span></div>
                                <div style="display: flex;flex-direction: row;justify-content: space-between;gap: 5px;align-items: center;">法术防: <span style="color: white;width: 60px;text-align: center;" id="secondary-magic-defense"></span> <span id="secondary-magic-defense-bonus"></span></div>
                                <div style="display: flex;flex-direction: row;justify-content: space-between;gap: 5px;align-items: center;">速度值: <span style="color: white;width: 60px;text-align: center;" id="secondary-speed"></span> <span id="secondary-speed-bonus"></span></div>
                            </div>
                    </div>
                </div>
                <div class="button-grid">
                    <button onclick="trainAttributes()">金子培养</button>
                    <button onclick="trainSkills()">洗练技能</button>
                    <button onclick="upgradeWisdomTo()">一键提悟</button>
                    <button onclick="useSupremeWisdomPill()">超级提悟</button>
                    <button onclick="ascend()">飞升突破</button>
                    <button onclick="transformPet()">属性专精</button>
                    <button id="petArms" onclick="handlePetArmsClick()">宠物武装</button>
                    <button onclick="petCollection()">宠物图鉴</button>
                    <button onclick="showBiography()">解锁传记</button>
                    <button onclick="jumpToQuality()">查看资质</button>
                </div>
            </div>
        </div>
    </div>
    <div class="shop-drawer" id="shop-drawer">
        <div class="drawer-toggle" onclick="toggleShop()">商店<span id="discount-detail"></span><span id="shop-timer">05:00</span></div>
        <div class="shop-info" id="shop-info">
            <div id="shop-info-container"style="max-height: 400px;overflow-y: scroll;margin-bottom: 20px;">
                <div class="shop-items" id="shop-items">
                    <!-- 商店商品展示区 -->
                </div>
            </div>
            <div id="shop-description" class="jinnang-description-box">点击可以查看其详情和描述，每个物品的售价因其稀有程度而有所不同。</div>
            <div class="shop-bar">
                <button onclick="buyItem()">购买道具</button>
                <button onclick="sellPet()">宠物市场</button>
                <button id="bless-gift-button" onclick="claimBlessGift()">新手礼包</button>
                <button onclick="openScalping()">倒买倒卖</button>
                <button onclick="refreshShop()">刷新商品</button>
            </div>
        </div>
    </div>
    <div class="scalping-display" id="scalping-display" style="display:none;">
        <div id="scalping-head" class="drawer-toggle" style="font-weight:bold;padding:5px;width:95%;height:20px;display: flex;flex-direction: row;justify-content: space-between;align-items: center;"><button id="scalping-description" class="scalping-head-button" onclick="showInfoScalping()" style="margin-left:5px;">?</button><div>自由经商（积分：<span id="scalping-score">0</span>）</div><button id="close-scalping-button" onclick="openScalping(true)" class="scalping-head-button" style="margin-right:5px">x</button></div>
        <div class="scalping-container" id="scalping-container">
            <div style="width: 100%;display: flex;flex-direction: column;align-items: center;gap: 10px;margin-top: 5px;" id="scalping-upper-area">
                <div class="scalping-top-bar" id="scalping-top-bar">
                    <div>📅 时间已过:</div>
                    <div>第<span id="current-selling-week">1</span>周/<span id="max-selling-week">52</span>周</div>
                    <div style="display: flex;flex-direction: column;font-size: 14px;">
                        <div>🏆 声望：<span id="player-reputation" style="cursor:pointer;">0</span></div>
                        <div style="cursor: pointer;">🏄‍♂️ 精力：<span id="player-energy">100</span></div>
                    </div>
                </div>
                <div class="scalping-asset-area" id="scalping-asset-area">
                    <div style="display: flex;flex-direction: column;gap: 5px;font-weight: bold;">
                        <div>💵 现金流：<span id="current-cash">0</span></div>
                        <div>🗃 总资产：<span id="net-asset">0</span></div>
                    </div>
                    <div id="scalping-gadgets-container" style="font-size: 12px;font-weight: bold;">
                        <div style="margin-top: 5px;margin-bottom: 5px;display: flex;gap: 2px;flex-direction: row;align-items: center;">
                            <button id="add-scalping-gadgets" onclick="selectSaclpingGadgets()">经商法宝</button>
                            <div id="applied-scalping-gadgets" style="display: flex;gap: 2px;flex-direction: row;flex-wrap: nowrap;">
                                <!-- 动态生成法宝 -->
                            </div>
                        </div>
                        <div id="gadgets-selector" class="select-gadgets" style="display:none;padding: 0px 10px;">
                            <div id="gadgets-selector-head" class="drawer-toggle" style="font-weight:bold;width: 100%;height: 10px;display: flex;flex-direction: row;justify-content: space-between;align-items: center;font-size: 16px;padding: 10px;"><div>v1.1</div>经商法宝<button onclick="closeGagdetsPanel()">x</button></div>
                            <div style="display:flex;width: 95%;justify-content: center;align-items: center;font-size:16px;padding: 5px;flex-direction: row;gap: 20px;">
                            <p>选择你所拥有的法宝</p>
                            <button id="exchange-gadgets" onclick="exchangeGadgets()">兑换法宝</button>
                            </div>
                            <div id="selected-gadgets" style="max-height: 420px;padding: 10px;overflow-y: scroll;min-height: 300px;border: 2px double #87431f;margin-bottom: 20px;width:95%">
                                <!-- 遍历法宝并在此处显示 -->
                            </div>
                        </div>
                        <div id="gadget-store-panel" class="select-gadgets" style="display:none;">
                            <div id="gadgets-store-head" class="drawer-toggle" style="font-weight:bold;padding:0px;width:100%;height:30px;display: flex;flex-direction: row;justify-content: space-between;align-items: center;font-size:16px;"><div>v1.1</div>兑换法宝<button id="close-gagdet-store">x</button></div>
                            <div style="display:flex;font-size: 16px;flex-direction: row;justify-content: center;align-items: center;width:100%;">
                            <p>你可以使用经商积分点击图标兑换法宝</p>
                            </div>
                            <div id="gadget-items" style="max-height: 480px;padding: 10px;overflow-y: scroll;">
                                <!-- 此处函数生成 -->
                            </div>
                        </div>
                    </div>
                    <div><button id="add-investment" onclick="increaseInverstment()">增加投资</button></div>
                </div>
                <div class="scalping-middle-wrap" id="scalping-middle-wrap">
                    <div class="scalping-detail-list" id="market-info">
                        <strong style="height: 30px;display: flex;align-items: center;">市场<button id="select-item-to-display" onclick="generateItemToDisplay()" style="margin-left:5px;font-weight: bolder;padding: 0px 2px;">＋</button></strong>
                        <div id="scalping-item-info-container" style="width: 100%;gap: 10px;display: flex;flex-direction: column;">
                            <div style="display: flex;width: 100%;flex-direction: row;justify-content: space-around;">
                                <div>货物</div>
                                <div>价格</div>
                            </div>
                        <div id="scalping-item-info" style="padding: 5px;border-top: 2px solid #6f391c;background-image: url(https://pic.imgdb.cn/item/66da9042d9c307b7e9e14b2b.png);color: white;max-height: 300px;overflow-y: scroll;">
                            <!-- 动态生成商品 -->
                        </div>
                        </div>
                    </div>
                    <div class="scalping-warehouse" id="warehouse-info">
                        <strong style="height: 30px;display: flex;align-items: center;">仓库(<span id="used-warehouse-capacity">0</span>/<span id="max-warehouse-capacity">100</span>)<button id="enlarge-warehouse-button" style="margin-left:5px;font-weight: bolder;padding: 0px 2px;">＋</button></strong>
                        <div id="warehouse-item-info-container" style="width: 100%;gap: 10px;display: flex;flex-direction: column;">
                            <div style="display: flex;width: 100%;flex-direction: row;justify-content: space-around;">
                                <div>货物</div>
                                <div>均价</div>
                                <div>数量</div>
                            </div>
                            <div id="warehouse-item-info" style="padding: 5px;border-top: 2px solid #6f391c;background-image: url(https://pic.imgdb.cn/item/66da9042d9c307b7e9e14b2b.png);color: white;max-height: 300px;overflow-y: scroll;">
                                <!-- 动态生成仓库商品 -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div style="width: 100%;display: flex;flex-direction: column;align-items: center;align-content: space-between;flex-wrap: wrap;">
                <div class="scalping-bottom-area" id="stock-area" style="border-radius: 5px;color: white;width: 95%;padding: 5px;">
                    <div style="display: flex;align-items: center;flex-direction: row;"><button id="open-stock-button" onclick="openStockPanel()">投资股票</button></div>
                    <div id="stock-info-display" style="display:flex;font-size: 14px;text-wrap: nowrap;overflow: hidden;background: rgb(57, 87, 89);box-shadow: rgb(30, 46, 47) 0px 0px 5px 2px inset;color: white;width: 75%;align-items: center;flex-direction: row;padding: 5px;justify-content: center;">当前没有投资任何股票</div>
                    <div class= "stock-panel" id="stock-panel" style="display:none">
                        <!-- 动态生成股票信息 -->
                    </div>
                </div>
                <div class="scalping-bottom-area" id="scalping-bottom-area">
                    <div><button id="quit-scalping" onclick="quitScalping()">提前退市</button></div>
                    <div><button id="relax-byweek" style="display: none">休息两周</button></div>
                    <div><button id="enter-next-week" onclick="refreshSaleWeek()">刷新一周</button></div>
                </div>
            </div>
        </div>
    </div>
    <div id="iframeContainer">
        <button id="openDivineZiwei" onclick="openDivineZiwei()" style="padding: 4px;position: absolute;z-index: 1000;right: 85%;top: 4%;border: none;background: transparent;border-radius: 5px;box-shadow: 0px 0px 5px 0 black;font-weight: bold;font-size: 16px;color:white;cursor: pointer;">紫薇</button>
        <button onclick="closeDivineShuixian()" style="padding: 10px;position: absolute;z-index: 1000;right: 4%;top: 3%;border: none;font-size: 24px;color: white;background: transparent;cursor: pointer;">X</button>
        <iframe id="iframe" style="z-index: 1;border: none;width: 100%;height: 100%;position: absolute;flex: 1;left: 50%;top: 50%;transform: translate(-50%, -50%);display: flex;flex-direction: row;justify-content: flex-end;background-color:rgb(0 0 0 / 40%);font-size: 16px;"></iframe>
    </div>
    <div class="treasure-drawer" id="treasure-drawer">
        <div class="drawer-toggle" onclick="toggleTreasureDrawer()">宝箱</div>
        <div class="treasure-info" id="treasure-info">
            <div class="treasure-bar">
            <div style= "display: flex; flex-direction: column; align-items: center; gap: 10px;">
                <img src="https://pic.imgdb.cn/item/66bf56dad9c307b7e9cc0f91.png" style="width:45px;height:45px;border: 1px solid black;" onclick="selectTreasure('经验宝箱')">
                <div style="font-size: 14px;">经验宝箱</div>
            </div>
            <div style= "display: flex; flex-direction: column; align-items: center; gap: 10px;">
                <img src="https://pic.imgdb.cn/item/66bf56d9d9c307b7e9cc0f80.png" style="width:45px;height:45px;border: 1px solid black;" onclick="selectTreasure('奇馈宝箱')">
                <div style="font-size: 14px;">奇馈宝箱</div>
            </div>
            <div style= "display: flex; flex-direction: column; align-items: center; gap: 10px;">
                <img src="https://pic.imgdb.cn/item/66bf56d9d9c307b7e9cc0f6c.png" style="width:45px;height:45px;border: 1px solid black;" onclick="selectTreasure('灵魂宝箱')">
                <div style="font-size: 14px;">灵魂宝箱</div>
            </div>
            <div style= "display: flex; flex-direction: column; align-items: center; gap: 10px;">
                <img src="https://pic.imgdb.cn/item/66bf56d9d9c307b7e9cc0f5d.png" style="width:45px;height:45px;border: 1px solid black;" onclick="selectTreasure('武神仙葫')">
                <div style="font-size: 14px;">武神仙葫</div>
            </div>
            <div style= "display: flex; flex-direction: column; align-items: center; gap: 10px;">
                <img src="https://pic.imgdb.cn/item/66c4cb80d9c307b7e92a8dd2.png" style="width:45px;height:45px;border: 1px solid black;" onclick="selectTreasure('五行仙葫')">
                <div style="font-size: 14px;">五行仙葫</div>
            </div>
            <div style= "display: flex; flex-direction: column; align-items: center; gap: 10px;">
                <img src="https://pic.imgdb.cn/item/66bf56d9d9c307b7e9cc0f3b.png" style="width:45px;height:45px;border: 1px solid black;" onclick="selectTreasure('至尊仙葫')">
                <div style="font-size: 14px;">至尊仙葫</div>
            </div>
            </div>
            <div id="treasure-reward" class="reward-box"></div>
            <div id="generalEffect" class="general-visual-effect"></div>
            <div id="treasure-description" class="treasure-description-box">连续开启宝箱无需点击“取出道具”，每次开启宝箱会自动帮你收集至背包。</div>
            <div class="treasure-action">
                <button onclick="openTreasure()">开启宝箱</button>
                <button onclick="openTenthTreasure()">十连开启</button>
                <button onclick="collectTreasure()">取出道具</button>
                <button onclick="openDivineShuixian()">模拟通灵</button>
            </div>
        </div>
    </div>
    <div class="jinnang-drawer" id="jinnang-drawer">
        <div class="drawer-toggle" onclick="toggleJinnangDrawer()"><span id="jinnang-capacity">2000</span></div>
        <div class="jinnang-info" id="jinnang-info">
            <div id="jinnang-reward-container" style="min-height:100px; max-height:300px; overflow-y:scroll; margin-bottom:10px">
                <div class="jinnang-reward" id="jinnang-reward"></div>
            </div>
        </div>
        <div id="jinnang-description" class="jinnang-description-box">点击可以查看其描述或出售，每个物品的售价因其稀有程度而有所不同。</div>
        <div class="treasure-action">
            <button onclick="sellItem()">出售道具</button>
            <button onclick="useAssignedItem()">使用道具</button>
            <button onclick="useAllItems()">批量使用</button>
            <button onclick="deleteItems()">丢弃道具</button>
            <button onclick="openWuxingDisplay()">五行面板</button>
        </div>
    </div>

    <div class="lottery-drawer" id="lotteryDrawer">        
        <div class="lottery-section lottery-top">
            <div class="lottery-box" id="lotteryPrizePool">奖池: 无上限奖池</div>
            <div class="lottery-box" id="lotteryBetCount">投注数: 0</div>
            <div class="lottery-box" id="lotteryBetAmount">投注金: 0</div>
        </div>
        <div class="lottery-section lottery-middle">
            <div class="lottery-number-box" id="lotteryDrawResults">开奖区: </div>
            <div class="lottery-number-box" id="lastSelectedNumbers">上次选号: </div>
            <div class="lottery-number-box" id="lotteryAvailableNumbers" style="display: flex;flex-direction: column;">备选区: 
                <div id="lotteryNumberButtons"></div>
            </div>
            <div class="lottery-controls">
                <button id="lotteryBetButton">投注</button>
                <button id="lotteryIncreaseBet">+500</button>
                <button id="lotteryIncreaseThousandBet">+1000</button>
                <button id="lotteryDecreaseBet">-1</button>
                <button id="lotteryRuleButton">规则</button>
                <!-- 规则信息框 -->
                <div id="lotteryRuleModal" class="modal">
                    <div class="modal-content">
                        <span class="close">&times;</span>
                        <div id="ruleContent"></div>
                    </div>
                </div>
            </div>
        </div>
        <div class="lottery-section lottery-bottom">
            <div class="lottery-number-box" id="lotterySelectedNumbers">已选: </div>
            <div class="lottery-box" id="lotteryResultAmount">奖金区: 0</div>
        </div>
        <div class="lottery-section lottery-footer">
            <button id="lotteryClaimPrize">领取奖金</button>
            <button id="closeLottry" onclick="toggleLotteryDrawer()">我不玩了</button>
        </div>
    </div>
    <div id="fightingDrawer" class="battle-system-drawer">
        <div class="battle-system-content">
            <div id="battleOverlay" class="battleOverlay">
                <div class="battleOverlayContainer">
                    <img id="battleOverlayImage" src="" alt="Battle Animation" style="width: 100%; height: 100%; object-fit: contain;">
                </div>
            </div>
        <div class="battle-system-drawer-toggle" onclick="toggleFightingDrawer()">&times;</div>
            <div class="battle-system-info-wrapper">
                <div class="battle-system-pet-info">
                    <h2><span id="your-pet-name">小金牛</span> lv<span id="your-pet-level">1</span></h2>
                    <div style="display: flex;justify-content: center;position:relative;align-items: center;border-radius: 5px;padding: 2px;height: 60px;">
                        <img id="your-pet-image" src="https://pic.imgdb.cn/item/66728efbd9c307b7e9576627.gif" alt="小金牛" style="width: 50px;height: 50px;box-shadow: black 0px 0px 2px 0px;cursor: pointer;">
                        <div id="player-progress-container" style="display:flex;flex-direction:column;justify-content: flex-start;align-items: stretch;margin-left: 5px;width: 120px;height: 60px;">
                            <span style="margin-top:5px;" id="your-pet-health"></span><span id="your-pet-max-health"></span>
                            <span style="margin-top:5px;" id="your-pet-mana"></span><span id="your-pet-max-mana"></span>
                            <div style="margin-bottom: 5px; margin-top:5px; position: relative; width: 100%; min-height: 12px; background-color: #35472C; border: 1px solid black;" id="exp-bar-container">
                                <div style="position: absolute; left: 0px; top: 0px; height: 100%; width: 49.5192%; background: linear-gradient(rgb(75, 0, 130), rgb(147, 112, 219), rgb(75, 0, 130));" id="exp-bar"></div>
                                <span style="position: absolute; top: 0; left: 0; right: 0; z-index: 1; font-size: 12px; font-weight: bold; color: white; text-align: center; line-height: 12px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;" id="exp-text"></span>
                            </div>
                        </div>
                    </div>
                    <div class="enemy-damage-display" id="enemy-damage-display"><span id="enemy-damage-value"></span></div>
                    <div class="enemy-extra-damage-display" id="enemy-extra-damage-display"><span id="enemy-extra-damage-value"></span></div>
                    <div id="player-status" class="status-display"></div>
                    <div id="visualEffectsContainer">
                        <div id="enemyEffect" class="visual-effect"></div>
                    </div>
                    <div style="line-height: 16px;display: flex;flex-direction: row;flex-wrap: nowrap;justify-content: space-between;text-align: left;gap: 5px;text-wrap: nowrap;overflow-x: hidden;box-shadow: 0px 0px 2px 1px #fff;">
                    <div style="width: 85px;">
                        <p>🗡物攻: <span id="your-pet-physical-attack"></span></p>
                        <p>🧙法攻: <span id="your-pet-magic-attack"></span></p>
                        <p>🥊暴击: <span id="player-crit-rate"></span></p>
                        <p>💨速度: <span id="your-pet-speed"></span></p>
                        <p>🪄修为: <span id="your-pet-cultivation"></span></p>
                    </div>
                    <div style="width: 85px;">
                        <p>🛡物防: <span id="your-pet-physical-defense"></span></p>
                        <p>💠法防: <span id="your-pet-magic-defense"></span></p>
                        <p>💥暴伤: <span id="player-crit-damage"></span></p>
                        <p>⭐️物闪: <span id="player-physical-dodge-rate"></span></p>
                        <p>🌟法闪: <span id="player-magic-dodge-rate"></span></p>
                    </div>
                    </div>
                </div>
                <div class="battle-system-enemy-info">
                    <h2><span id="enemy-name">邪佞</span> lv<span id="enemy-level">1</span></h2>
                    <div style="display: flex;justify-content: center;position:relative;align-items: center;border-radius: 5px;padding: 2px;height: 60px;">
                        <img id="enemy-image" onclick="autoBattle()" src="https://pic.imgdb.cn/item/6678135ed9c307b7e9060dd6.gif" alt="邪佞" style="width: 50px;height: 50px;box-shadow: black 0px 0px 2px 0px;cursor: pointer;">
                        <div id="enemy-progress-container" style="display:flex;flex-direction:column;justify-content: flex-start;align-items: stretch;margin-left: 5px;width: 120px;height: 60px;">
                            <span style="margin-top:5px;" id="enemy-pet-health"></span><span id="enemy-max-health"></span>
                            <span style="margin-top:5px;" id="enemy-pet-mana"></span><span id="enemy-max-mana"></span>
                            <div style="margin-bottom: 5px; margin-top:5px; position: relative; width: 100%; min-height: 12px; background-color: #35472C; border: 1px solid black;" id="enemy-speed-container">
                                <div style="position: absolute; left: 0px; top: 0px; height: 100%; width: 0%; background: linear-gradient(rgb(249, 222, 155), rgb(246, 255, 0), rgb(249, 222, 155)); cursor: pointer;" id="enemy-speed-bar"></div>
                                <span style="position: absolute; top: 0; left: 0; right: 0; z-index: 1; font-size: 12px; font-weight: bold; color: white; text-align: center; line-height: 12px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;" id="speed-text"></span>
                            </div>
                        </div>
                    </div>
                    <div class="player-damage-display" id="player-damage-display"><span id="player-damage-value"></span></div>
                    <div class="player-extra-damage-display" id="player-extra-damage-display"><span id="player-extra-damage-value"></span></div>
                    <div id="enemy-status" class="status-display"></div>
                    <div id="visualEffectsContainer">
                        <div id="playerEffect" class="visual-effect"></div>
                    </div>
                    <div style="line-height: 16px;display: flex;flex-direction: row;flex-wrap: nowrap;justify-content: space-between;text-align: left;gap: 5px;text-wrap: nowrap;overflow-x: hidden;box-shadow: 0px 0px 2px 1px #fff;">
                    <div style="width: 85px;">
                        <p>🗡物攻: <span id="enemy-pet-physical-attack"></span></p>
                        <p>🧙法攻: <span id="enemy-pet-magic-attack"></span></p>
                        <p>🥊暴击: <span id="enemy-crit-rate"></span></p>
                        <p>💨速度: <span id="enemy-pet-speed"></span></p>
                        <p>🪄修为: <span id="enemy-pet-cultivation"></span></p>
                    </div>
                    <div style="width: 85px;">
                        <p>🛡物防: <span id="enemy-pet-physical-defense"></span></p>
                        <p>💠法防: <span id="enemy-pet-magic-defense"></span></p>
                        <p>💥暴伤: <span id="enemy-crit-damage"></span></p>
                        <p>⭐️物闪: <span id="enemy-physical-dodge-rate"></span></p>
                        <p>🌟法闪: <span id="enemy-magic-dodge-rate"></span></p>
                    </div>
                    </div>
                </div>
            </div>
            <!-- 战斗精灵弹出界面 -->
            <div id="battle-spirit-modal" style="display: none;">
                <div>
                    <h2>🧚‍♀️战斗精灵（已觉醒）</h2>
                    <div id="message-container" style="display: none;"></div>
                    <p>等级: <span id="spirit-level">1</span></p>
                    <p>增幅: <span id="spirit-multiplier">100%</span>（1%~415%）</p>
                    <p>HP增加: <span id="spirit-health">0</span></p>
                    <p>MP增加: <span id="spirit-mana">0</span></p>
                    <p>物攻增加: <span id="spirit-physical-attack">0</span></p>
                    <p>物防增加: <span id="spirit-physical-defense">0</span></p>
                    <p>法攻增加: <span id="spirit-magic-attack">0</span></p>
                    <p>法防增加: <span id="spirit-magic-defense">0</span></p>
                    <p>速度增加: <span id="spirit-speed">0</span></p>
                    <div id="spirit-actions" style="display: flex; flex-direction:row; justify-content:space-between;">
                    <button id="level-up-spirit">升级精灵</button>
                    <button id="enhance-spirit">增幅洗练</button>
                    <button id="auto-level-up-spirit">一键升级</button>
                    <button id="close-spirit-modal">关闭面板</button>    
                    </div>
                </div>
            </div>            
            <!-- 飞升之术面板 -->
            <div id="ascension-skill-modal" class="ascension-skill-modal modal">
                <div class="ascension-modal-content modal-content">
                    <span id="close-ascension-modal" class="ascension-close close">&times;</span>
                    <div class="ascension-header">
                        <img id="ascension-icon" src="https://pic.imgdb.cn/item/666aa7b6d9c307b7e9495e97.png" alt="Ascension Skill Icon" class="ascension-icon">
                        <div class="ascension-info">
                            <p id="ascension-name" class="ascension-name">飞升之术名字</p>
                            <p id="ascension-level" class="ascension-level">等级: 1</p>
                        </div>
                    </div>
                    <div class="ascension-body">
                        <p id="ascension-effect" class="ascension-effect">飞升之术的增益效果信息</p>
                    </div>
                    <div class="ascension-footer">
                        <button id="enable-ascension" class="ascension-button">开启增益</button>
                        <button id="refresh-ascension" class="ascension-button">刷新技能</button>
                        <button id="level-up-ascension" class="ascension-button">提升技能</button>
                        <button id="reenable-ascension" class="ascension-button">再次开启</button>
                    </div>
                    <!-- 第二个飞升技能面板，默认隐藏 -->
                    <div id="second-ascension-skill" class="ascension-second-skill" style="display: none;">
                        <div class="ascension-header">
                            <img id="second-ascension-icon" src="https://pic.imgdb.cn/item/66726727d9c307b7e9118748.png" alt="Ascension Skill Icon" class="ascension-icon">
                            <div class="ascension-info">
                                <p id="second-ascension-name" class="ascension-name">飞升之术名字</p>
                                <p id="second-ascension-level" class="ascension-level">等级: 1</p>
                            </div>
                        </div>
                        <div class="ascension-body">
                            <p id="second-ascension-effect" class="ascension-effect">飞升之术的增益效果信息</p>
                        </div>
                        <div class="ascension-footer">
                            <button id="refresh-second-ascension" class="ascension-button">刷新技能</button>
                            <button id="level-up-second-ascension" class="ascension-button">提升技能</button>
                        </div>
                    </div>
                </div>
            </div>
            <!-- 使用药品面板 -->
            <div id="drug-modal" class="drug-modal modal">
                <div class="modal-content">
                    <div class = "drug-grid-container" id="drug-grid-container" style="height: 280px;overflow-y: scroll;margin-top: 10px;">
                        <div class="drug-grid" id="drug-grid">
                            <!-- 药品项会通过JavaScript动态生成 -->
                        </div>
                    </div>
                    <div class="drug-description" id="drug-description">
                        本游戏药品系统丰富，战斗胜利后会随机掉落各类药品，合理分配使用会带来奇效！
                    </div>
                    <div id="drug-button-container" style="width: 100%; display: flex; justify-content: space-between; max-height: 100px;">
                        <button class="use-button" onclick="useSelectedDrug()">使用</button>
                        <button class="use-button" onclick="mergeDrug()">合成</button>
                        <button class="use-button" onclick="collectDrug()">采集</button>
                        <button class="use-button" onclick="closeDrugModal()">关闭</button>
                    </div>
                </div>
            </div>
            <div class="battle-pet-selector"><select id="battle-pet-select" onchange="changeBattlePet()"><option value="xiaojin"></option></select></div>
            <div class="battle-system-log">
                <h2 id="battle-log-head" style="cursor:pointer;">战斗记录（第<span id="battleRounds"></span>轮）</h2>
                <div id="log"></div>
            </div>
            <div class="battle-system-actions">
                <button onclick="performAttack('physical')">物攻</button>
                <button onclick="performDefense()">格挡</button>
                <button onclick="performHeal()">治疗</button>
                <button onclick="performPoison()">施毒</button>
                <button onclick="performTrumpCard()">绝技</button>
                <button onclick="performAttack('magical')">法攻</button>
                <button id="battle-spirit-button">精灵</button>
                <button id="ascension-skill-button" class="ascension-button">飞升</button>
                <button onclick="divinedWeapon()">神器</button>
                <button onclick="levelUpSkill()">技能</button>
                <button onclick="enemyInfo()">自动</button>
                <button onclick="useDrug()">药品</button>
            </div>            
        </div>
    </div>
    <div id="missionPanel" class="general-window-background" style="display:none;">
        <div class="drawer-toggle">任务</div>
        <div id="mission-container" style="padding: 4px;border-radius: 2px;background-color: #DFBF6E;color: #92341c;background-image: url(https://pic.imgdb.cn/item/663885620ea9cb14033e4f6e.png);background-repeat: repeat;background-size: auto;border: 1px solid black;">
            <h3>任务面板</h3>
            <ul id="taskList">
                <!-- 任务列表 -->
            </ul>
            <div class="treasure-action button">
                <button id="closeMissionPanel" style="margin-top: 20%;position: relative;">关闭窗口</button>
            </div>
        </div>
    </div>
    <div id="summonPanel" class="general-window-background" style="display:none;">
        <div class="drawer-toggle">召唤</div>
        <div id="summon-container" style="padding: 4px;border-radius: 2px;background-color: #DFBF6E;color: #92341c;background-image: url(https://pic.imgdb.cn/item/663885620ea9cb14033e4f6e.png);background-repeat: repeat;background-size: auto;border: 1px solid black;">
            <h3>召唤面板</h3>
            <div id="summonArea" style="height: 240px;display: flex;align-items: center;justify-content: space-around;padding: 10px;background-color: rgba(0, 0, 0, 0.8);margin-bottom: 20px;margin-top: 20px;flex-direction: column;background-image: url(https://pic.imgdb.cn/item/66c043bfd9c307b7e9dccda0.png);background-size: cover;">
                <!-- 召唤区域 -->
            </div>
            <div class="treasure-action">
                <button id="summonExecuteButton" class="treasure-action button">召唤</button>
                <button id="claimButton" class="treasure-action button">领取</button>
                <button id="exchangeButton" class="treasure-action button">兑换</button>
                <button id="openPetShopButton" class="treasure-action button">商店</button>
                <button id="closeSummonPanel" class="treasure-action button">关闭</button>
            </div>
        </div>
    </div>
    <div id="petShop" class="general-window-background" style="display:none;">
        <div class="drawer-toggle">宠物商店</div>
        <div id="pet-shop-container" style="padding: 4px;border-radius: 2px;background-color: #DFBF6E;color: #92341c;background-image: url(https://pic.imgdb.cn/item/663885620ea9cb14033e4f6e.png);background-repeat: repeat;background-size: auto;border: 1px solid black;">
            <h3>宠物商店（可下划）当前印花: <span id="currentStampCount">1000</span></h3>
            <div id="petShopItemsContainer" style="max-height:300px; overflow-y:scroll">
                <div id="shopItems"  style="display: grid;grid-template-columns: repeat(2, 1fr);gap: 2px 2px;justify-content: center;margin-top: 5px;font-size: 12px;justify-items: stretch;align-items: center;">
                    <!-- 商店物品列表 -->
                </div>
            </div>
            <div class="treasure-action">
                <button id="buySummonCharmButton" class="treasure-action button">购买灵符</button>
                <button id="closePetShop" class="treasure-action button">关闭商店</button>
            </div>
        </div>
    </div>
    <div class="bottom-bar">
        <div class="pet-image" onclick="showBiography()">
            <img style="width: 180px;height: 180px;" id="pet-image" src="https://pic.imgdb.cn/item/66728efbd9c307b7e9576627.gif" alt="小金牛">
        </div>
        <div class="info" style="display: flex;flex-direction: column;">
            <div id="gold-container" onclick="exchangeGoldBlock()" style="background: #69482B;padding: 2px 2px;box-shadow: inset 0px 0px 2px 0px #69482B;border: 1px solid #6f391c;cursor: pointer;">
                <div style="background: #B19768;padding: 2px;margin-right: 2px;color: white;box-shadow: inset 0px 0px 2px 1px #E3D8B9;text-shadow: -1px -1px 0 #693331, 1px -1px 0 #693331, -1px 1px 0 #693331, 1px 1px 0 #693331;font-size: 14px;">金子: </div>
                <span id="gold-amount">50000</span>
            </div> 
            <div>宠物： 
                <div class="pet-selector">
                    <select id="pet-select" onchange="changePet()">
                        <option value="xiaojin">小金牛</option>
                        <!-- 其他宠物 -->
                    </select>
                </div>
            </div>
            <div>当前称号： <span id="personal-honor">初来乍到</span></div>
            <div>游戏版本： <span id="game-version">V2.1.2</span></div>
            <div id="loadContainer" style="display:flex; justify-content: space-around; width: 100%;">
                <button class="saveAndLoadGameState" onclick="saveGameState()">存档</button>
                <button class="saveAndLoadGameState" onclick="loadGameState()">读档</button>
                <button class="saveAndLoadGameState" onclick="deleteAllPetData()">删档</button>
            </div>
        </div>
    </div>    
    <div class="description-box" id="description-box"></div>
    <div id="inlayGemUI" style="z-index: 9999;text-align: center;display: none;position: fixed;top: 50%;left: 50%;transform: translate(-50%, -50%);width: 350px;border-radius: 2px;color: rgb(146, 52, 28);background: rgb(176, 118, 56);padding: 2px;box-shadow: rgb(146, 52, 28) 0px 0px 3px 1px inset;border: 1px solid black;">
        <button onclick="closeInlayGemDisplay()" id="closeBtn" style="display: flex;gap: 5px;align-items: center;justify-content: center;padding: 5px;text-align: center;background-image: url(https://pic.imgdb.cn/item/66bf32d9d9c307b7e9995d58.png);background-repeat: repeat;background-size: contain;color: rgb(227, 167, 59);cursor: pointer;box-shadow: rgb(227, 167, 59) 0px 1px 2px 0px inset;border: 1px solid black;position: relative;font-size: 16px;width:100%;font-family: 'Noto Serif SC', sans-serif;">武装详情</button>
        <div id="gem-container" style="font-size: 14px;display: flex;flex-direction: column;background-color: rgb(223, 191, 110);box-shadow: rgb(111, 57, 28) 0px 0px 0px 1px inset;color: black;background-image: url(https://pic.imgdb.cn/item/663885620ea9cb14033e4f6e.png);background-repeat: repeat;background-size: auto;height: 100%;overflow-y: auto;padding: 2px;">
            <!-- 装备图标和星级 -->
            <div style="text-align: center;display: flex;flex-direction: column;align-items: center;justify-content: center;border-bottom: 2px dotted #ccc;">
                <img id="zhuang-bei" src="https://pic.imgdb.cn/item/666f194dd9c307b7e907bf7b.png" alt="装备图标" style="width: 45px;height: 45px;border: 1px solid #000;margin-bottom: 10px;margin-top: 10px;">
            </div>
            <div id="bottom-detail-container" style="display: flex;flex-direction: column;background-image: url(https://pic.imgdb.cn/item/66da9042d9c307b7e9e14b2b.png);background-repeat: repeat;background-size: auto;height: 100%;color: white;">
                <!-- 基础属性 -->
                <div style="display: flex;justify-content: center;align-items: flex-start;padding: 5px;flex-direction: column;margin-left: 10px;">
                    <span id="arm-name" style="color: orange;font-weight: bold;"></span>
                    <div style="display:flex; flex-direction:row; justify-content: space-between;">
                        <span id="starLevel" style="font-size: 18px;text-shadow: 1px 0px 2px #6f391c;"></span>
                        <button id="upgradeStarBtn" style="border: 1px solid rgb(111, 57, 28);background: linear-gradient(rgb(228, 127, 71), rgb(206, 102, 51), rgb(150, 61, 28));box-shadow: rgb(135, 67, 31) 0px 0px 2px 1px inset;font-size: 12px;border-radius: 5px;color: rgb(249, 222, 155);padding: 2px 10px;cursor: pointer;margin: 2px;transition: transform 0.1s, box-shadow 0.1s;">升星</button>
                    </div>
                </div>
                <div style="display: flex;align-items: center;justify-content: center;border-bottom: 2px dotted #ccc;padding: 2px 20px;flex-direction: column;gap: 2px;">
                    <div style="display: flex;justify-content: flex-start;width: 100%;"><strong>装备部位:</strong><span id="arm-type-display" style="margin-left: 10px;"></span></div>
                    <div style="display: flex;justify-content: flex-start;width: 100%;"><strong>耐久度:</strong><span id="endurance-display" style="margin-left: 10px;"></span>/500</div>
                    <div style="display: flex;justify-content: flex-start;width: 100%;gap: 10px;">
                        <strong>基础属性：</strong>
                        <div id="baseAttribute">+ 12353 物理防御</div>
                    </div>
                </div>
                <!-- 宝石孔显示 -->
                <div>
                    <div id="gemSlots" style="display: flex;flex-direction: column;align-items: flex-start;padding: 0px 20px;margin-top: 5px;">
                        <div style="margin-bottom: 5px;"><span id="slot1" class="slot" style="cursor: pointer;">〇 空</span></div>
                        <div style="margin-bottom: 5px; display: none;"><span id="slot2" class="slot" style="cursor: pointer;">〇 空</span></div>
                        <div style="margin-bottom: 5px; display: none;"><span id="slot3" class="slot" style="cursor: pointer;">〇 空</span></div>
                        <div style="margin-bottom: 5px; display: none;"><span id="slot4" class="slot" style="cursor: pointer;">〇 空</span></div>
                        <div style="margin-bottom: 5px; display: none;"><span id="slot5" class="slot" style="cursor: pointer;">〇 空</span></div>
                        <div style="margin-bottom: 5px; display: none;"><span id="slot6" class="slot" style="cursor: pointer;">〇 空</span></div>
                        <div style="margin-bottom: 5px; display: none;"><span id="slot7" class="slot" style="cursor: pointer;">〇 空</span></div>
                        <div style="margin-bottom: 5px; display: none;"><span id="slot8" class="slot" style="cursor: pointer;">〇 空</span></div>
                        <div style="margin-bottom: 5px; display: none;"><span id="slot9" class="slot" style="cursor: pointer;">〇 空</span></div>
                        <div style="margin-bottom: 5px; display: none;"><span id="slot10" class="slot" style="cursor: pointer;">〇 空</span></div>
                    </div>
                    <div id="button-detail" style="display: flex;flex-direction: row;justify-content: flex-start;align-items: center;margin-left: 20px;gap: 10px;">
                        <strong id="gem-slots-number"></strong>
                        <button id="punchHoleBtn" style="border: 1px solid rgb(111, 57, 28);background: linear-gradient(rgb(228, 127, 71), rgb(206, 102, 51), rgb(150, 61, 28));box-shadow: rgb(135, 67, 31) 0px 0px 2px 1px inset;font-size: 12px;border-radius: 5px;color: rgb(249, 222, 155);padding: 2px 10px;cursor: pointer;margin: 2px;transition: transform 0.1s, box-shadow 0.1s;">打孔</button>
                        <button id="refreshSlotsBtn" style="border: 1px solid rgb(111, 57, 28);background: linear-gradient(rgb(228, 127, 71), rgb(206, 102, 51), rgb(150, 61, 28));box-shadow: rgb(135, 67, 31) 0px 0px 2px 1px inset;font-size: 12px;border-radius: 5px;color: rgb(249, 222, 155);padding: 2px 10px;cursor: pointer;margin: 2px;transition: transform 0.1s, box-shadow 0.1s;">刷新</button>
                    </div>
                </div>
    
                <!-- 镶嵌宝石操作 -->
                <div style="border-top: 2px dotted #ccc;display: flex;">
                    <p id="arm-description" style="margin-left: 20px;text-align: left;"></p>
                </div>
            </div> <!-- 闭合 bottom-detail-container -->
        </div>
    </div>
    <script>

document.getElementById('wuxing-close-button').addEventListener('click', closeWuxingDisplay);
document.getElementById('wuxing-display').style.display = 'none';

const pets = {
    xiaojin: {
        name: '小金牛',
        rank: 'R',
        image: 'https://pic.imgdb.cn/item/66728efbd9c307b7e9576627.gif',
        skills: [
            { name: '野性冲撞', rarity: 'A', type: 'PA', multiplier: 2, description: '物理攻击技能，小金牛使出浑身解数朝邪佞进行致命一击。' },
            { name: '冥想', rarity: 'B', type: 'HL', multiplier: 0.01, description: '被动技能，每回合恢复一定量的法力值' },
            { name: '破军神力', rarity: 'B', type: 'N', multiplier: 3, description: '被动技能，宠物获得大量的物理攻击力和法术攻击力。' },
            { name: '野性赐福', rarity: 'B', type: 'N', multiplier: 1, description: '被动技能，宠物可获得一定的耐力提升。' },
            { name: '天生蛮力', rarity: 'B', type: 'N', multiplier: 1, description: '被动技能，小金牛天生蛮力，物理攻击有所提升。' },
            { name: '自然屏障', rarity: 'B', type: 'PD', multiplier: 1.2, description: '防御技能，小金牛的防御能力得到了微量提升。' },
            { name: '生命祝福', rarity: 'A', type: 'PH', multiplier: 1.2, description: '治疗技能，得到生命祝福的小金牛治疗能力得到了提升。' },
            { name: '三倍速冲击', rarity: 'SS', type: 'PA', multiplier: 3, description: '物理攻击技能，愤怒的小金牛超负荷奔跑，对敌人使出致命的冲撞。' },
            { name: '仙风道骨', rarity: 'A', type: 'N', multiplier: 1.5, description: '被动技能，耐力、敏捷、强壮大幅提升。' },
            { name: '长寿', rarity: 'B', type: 'N', multiplier: 0, description: '被动技能，寿命上限上升' },
            { name: '灵兽冲刺', rarity: 'B', type: 'MA', multiplier: 3, description: '法术攻击技能，对目标造成法术伤害' },
            { name: '野兽外壳', rarity: 'A', type: 'N', multiplier: 1, description: '被动技能，物理和法术防御上升。' },
            { name: '全面进化', rarity: 'S', type: 'N', multiplier: 2, description: '被动技能，耐力、敏捷、强壮上升' }
        ],
        qualities: {
            tier: '普通',
            growthRate: 100,
            endurance: { current: 3600, min: 3600, max: 7200 },
            strength: { current: 3200, min: 3200, max: 5400 },
            faith: { current: 1150, min: 1150, max: 2250 },
            agility: { current: 1100, min: 1100, max: 2200 },
            intelligence: { current: 2100, min: 2100, max: 4200 },
            mutated: false
        },
    },
    jiecheng: {
        name: '结城夏奈',
        rank: 'SSR',
        image: 'https://pic.imgdb.cn/item/66e83fc7d9c307b7e9977eda.png',
        skills: [
            { name: '咒炎爆破', rarity: 'SSS', type: 'MAE', multiplier: 5, description: '結城夏柰凝聚咒术之力，释放出强烈的火焰冲击，对范围内的敌人造成高额魔法伤害。' },
            { name: '冰封禁锢', rarity: 'SS', type: 'TC', multiplier: 2, description: '以咒术唤出寒冰之力，将敌人禁锢在冰块之中，使其短时间内无法行动。' },
            { name: '魔音扰神', rarity: 'S', type: 'MAE', multiplier: 2, description: '弹奏古琴，发出扰人心神的魔音，使敌人陷入混乱，攻击方向出现错乱' },
            { name: '灵力护盾', rarity: 'A', type: 'PD', multiplier: 1.5, description: '結城夏柰为自己和队友施加一层灵力护盾，吸收一定量的伤害。' },
            { name: '咒术弱化', rarity: 'A', type: 'MAE', multiplier: 1.8, description: '对敌人施加咒术，降低其攻击力和防御力。' },
            { name: '琴音治愈', rarity: 'B', type: 'PH', multiplier: 1.35, description: '弹奏舒缓的琴音，为自己和队友恢复一定量的生命值。' },
            { name: '灵魂冲击', rarity: 'S', type: 'MAE', multiplier: 2, description: '释放强大的灵魂之力，对敌人的灵魂造成重创，使其陷入虚弱状态。' },
            { name: '幻影迷踪', rarity: 'SS', type: 'PHE', multiplier: 1.5, description: '結城夏柰制造出多个幻影，自身进入隐身状态并提升移动速度。' },
            { name: '诅咒降临', rarity: 'A', type: 'PPE', multiplier: 1.5, description: '降下诅咒，使敌人的技能冷却时间延长。' },
            { name: '魅心咒缚', rarity: 'SS', type: 'TC', multiplier: 1, description: '結城夏柰施展极致魅惑之术，以强大的咒力牵引敌人的心智。被魅惑的敌人会在一段时间内无法攻击' },
            { name: '智慧守护', rarity: 'B', type: 'SH', multiplier: 1, description: '学会智慧守护的宠物可用法力抵消一定比例的伤害' },
            { name: '永远挚爱麟', rarity: 'B', type: 'HL', multiplier: 0.03, description: '被动技能，在挚爱的隐隐关注下，每回合恢复一定的法力值。' },
            { name: '姐就是女王', rarity: 'B', type: 'NE', multiplier: 0, description: '被动技能，生命值大幅提升' }
        ],
        qualities: {
            tier: '普通',
            growthRate: 100,
            endurance: { current: 5400, min: 5400, max: 9200 },
            strength: { current: 3200, min: 3200, max: 5400 },
            faith: { current: 1150, min: 1150, max: 2250 },
            agility: { current: 1100, min: 1100, max: 2200 },
            intelligence: { current: 4200, min: 4200, max: 7800 },
            mutated: false
        },
    },
    qiongmei: {
        name: 'かすがのそら',
        rank: 'SSR',
        image: 'https://pic.imgdb.cn/item/66d69d73d9c307b7e923d797.gif',
        skills: [
            { name: '虚弱之躯', rarity: 'B', type: 'PD', multiplier: 1.5, description: '由于身体较为虚弱，穹减少了敌人输出的物理伤害。' },
            { name: '依赖之心', rarity: 'A', type: 'PH', multiplier: 1.5, description: '当身边有亲近的人时，穹的恢复能力显著提升。' },
            { name: '孤独之影', rarity: 'S', type: 'PP', multiplier: 2.5, description: '在孤独时爆发出惊人的攻击力，集中全力进行攻击。' },
            { name: '静谧守护', rarity: 'A', type: 'JK', multiplier: 0.1, description: '穹的内心宁静，能够更好地抵御敌人的负面效果。' },
            { name: '禁忌之恋', rarity: 'SS', type: 'MA', multiplier: 3, description: '穹与至亲的感情突破禁忌，激发出强大的攻击力。' },
            { name: '银发之美', rarity: 'B', type: 'N', multiplier: 2, description: '穹那银白色的头发令人难以忘怀，赋予她美丽的外表。' },
            { name: '病弱增幅', rarity: 'S', type: 'HL', multiplier: 0.01, description: '穹的病弱有时反而成为力量的源泉，使她的法力值得到一定的恢复能力。' },
            { name: '深情守护', rarity: 'A', type: 'SH', multiplier: 1, description: '穹对亲人的深情使她能够更快恢复生命值。' },
            { name: '心灵枷锁', rarity: 'B', type: 'N', multiplier: 0, description: '穹的内心受到情感的束缚，使她的攻击偶尔受到限制。' },
            { name: '逆境反击', rarity: 'A', type: 'FH', multiplier: 1, description: '在生命值低于一定比例时，穹的攻击能力会大幅提升。' },
            { name: '温柔之心', rarity: 'B', type: 'PH', multiplier: 1.6, description: '穹虽然外表冷淡，但内心温柔，能够为队友提供微弱的生命恢复。' },
            { name: '命运羁绊', rarity: 'S', type: 'N', multiplier: 10, description: '穹与亲人的羁绊使她在战斗中获得额外的力量加成。' },
            { name: '永恒依恋', rarity: 'SS', type: 'PA', multiplier: 3, description: '穹对至亲的依恋化作无尽的力量，爆发出强大的攻击。' }
        ],
        qualities: {
            tier: '普通',
            growthRate: 100,
            endurance: { current: 600, min: 600, max: 1100 },
            strength: { current: 2200, min: 2200, max: 3400 },
            faith: { current: 8150, min: 8150, max: 11250 },
            agility: { current: 2100, min: 2100, max: 3200 },
            intelligence: { current: 4100, min: 4100, max: 5100 },
            mutated: false
        },
    },
    jinqian: {
        name: '金钳蟹',
        rank: 'R',
        image: 'https://pic.imgdb.cn/item/66a38e18d9c307b7e996e8b2.gif',
        skills: [
            { name: '硬甲壳', rarity: 'B', type: 'PD', multiplier: 1.2, description: '物理防御上升' },
            { name: '自然屏障', rarity: 'B', type: 'N', multiplier: 1, description: '法术防御上升' },
            { name: '注魔水冲', rarity: 'A', type: 'PA', multiplier: 1.5, description: '对目标造成物理伤害' },
            { name: '天生灵性', rarity: 'A', type: 'HL', multiplier: 0.01, description: '法力上限上升' },
            { name: '水魔爆', rarity: 'A', type: 'PA', multiplier: 2.5, description: '敌全体造成物理伤害' },
            { name: '嗜血狂暴', rarity: 'A', type: 'N', multiplier: 2, description: '物理爆击上升' },
            { name: '天生蛮力', rarity: 'S', type: 'N', multiplier: 1, description: '物理攻击上升' },
            { name: '野性赐福', rarity: 'S', type: 'N', multiplier: 1, description: '耐力上升' },
            { name: '长寿', rarity: 'S', type: 'N', multiplier: 1, description: '寿命上限上升' },
            { name: '余忆幼时', rarity: 'B', type: 'N', multiplier: 2, description: '当童年成为遗迹里的梦' },
            { name: '野性穿刺', rarity: 'A', type: 'PA', multiplier: 1.6, description: '对目标造成物理伤害' }
        ],
        qualities: {
            tier: '普通',
            growthRate: 100,
            endurance: { current: 3150, min: 3150, max: 5180 },
            strength: { current: 3150, min: 3150, max: 5180 },
            faith: { current: 540, min: 540, max: 1660 },
            agility: { current: 3150, min: 3150, max: 5180 },
            intelligence: { current: 540, min: 540, max: 1660 },
            mutated: false
        },
    },
    jingtan: {
        name: '净坛使者',
        rank: 'SSR',
        image: 'https://pic.imgdb.cn/item/66a38e18d9c307b7e996e8c3.gif',
        skills: [
            { name: '生命祝福', rarity: 'B', type: 'PH', multiplier: 1.2, description: '生命力上升' },
            { name: '长寿', rarity: 'B', type: 'N', multiplier: 1, description: '有此天赋的生物寿命得到额外增长。被动技能，寿命上限增加。增加的寿命值与生物种类，技能等级有关。' },
            { name: '天生蛮力', rarity: 'B', type: 'N', multiplier: 1, description: '攻击增加' },
            { name: '高级强壮', rarity: 'A', type: 'N', multiplier: 2, description: '耐力及生命值上限上升' },
            { name: '破军神力', rarity: 'A', type: 'N', multiplier: 2, description: '被动技能，在破军星的庇佑下，人类可获得强大的战力，会此技能可使宠物获得大量的物理攻击力和法术攻击力' },
            { name: '苦行', rarity: 'A', type: 'N', multiplier: 2, description: '九戒在十万八千里的苦修中大大增加了自身的道行，耐力、敏捷、信仰增加。' },
            { name: '智慧守护', rarity: 'A', type: 'SH', multiplier: 1, description: '被动技能,通过追随智慧与战斗的守护者,使此生物学会用法力值抵消一部分受到的伤害.可抵消的比例根据技能等级而定.' },
            { name: '冥想', rarity: 'A', type: 'HL', multiplier: 0.01, description: '通过冥想，回合结束时（所有人行动完毕后）恢复自身大量魔法，恢复魔法百分比随技能等级提升而提升' },
            { name: '天罡三十六变', rarity: 'S', type: 'JK', multiplier: 0.05, description: '九戒会三十六种变化，每回合结束后有一定几率清除自身的异常状态。' },
            { name: '天河召唤', rarity: 'S', type: 'PA', multiplier: 2.5, description: '天蓬元帅召唤八万天河水军吞噬一切妖魔鬼怪。对敌方造成物理伤害。' },
            { name: '九齿透骨', rarity: 'SS', type: 'PP', multiplier: 2.5, description: '九戒使用九齿钉耙发动猛击，对一横排范围目标造成持续流血伤害。' },
            { name: '上宝沁金耙', rarity: 'SS', type: 'MA', multiplier: 2.8, description: '上宝沁金耙蕴含无穷法力，对十字目标进行法术攻击' },
            { name: '天蓬下凡', rarity: 'SS', type: 'PD', multiplier: 1.8, description: '传说天蓬元帅下凡时周身簇拥着无数天兵为其护法。消耗自身60%寿命及百分比蓝为己方十字目标增加百分比法术防御，技能效果随宠物修为和技能等级提升而提升。' }
        ],
        qualities: {
            tier: '普通',
            growthRate: 100,
            endurance: { current: 8100, min: 8100, max: 10900 },
            strength: { current: 4500, min: 4500, max: 6500 },
            faith: { current: 3600, min: 3600, max: 5400 },
            agility: { current: 2700, min: 2700, max: 4300 },
            intelligence: { current: 1800, min: 1800, max: 3200 },
            mutated: false
        },
    },
    jiuyi: {
        name: '九翼天龙',
        rank: 'SSR',
        image: 'https://pic.imgdb.cn/item/66a38e18d9c307b7e996e8d5.gif',
        skills: [
            { name: '长寿', rarity: 'B', type: 'N', multiplier: 1, description: '有此天赋的生物寿命得到额外增长。被动技能，寿命上限增加。增加的寿命值与生物种类，技能等级有关。' },
            { name: '龙形圣体', rarity: 'B', type: 'N', multiplier: 2, description: '龙形生物特有的，血耐大增的天赋。' },
            { name: '魔化鳞甲', rarity: 'B', type: 'N', multiplier: 1, description: '一些附有魔力的鳞片，大大提升了此生物的法术防御。' },
            { name: '生命祝福', rarity: 'B', type: 'PH', multiplier: 1.2, description: '对于生命的赐予是自然最善意的祝福，拥有此种天赋的生物，生命值将大大提高。野兽较容易得到这类祝福。' },
            { name: '智慧守护', rarity: 'A', type: 'SH', multiplier: 1, description: '被动技能,通过追随智慧与战斗的守护者,使此生物学会用法力值抵消一部分受到的伤害.可抵消的比例根据技能等级而定.' },
            { name: '龙族后裔（图腾）', rarity: 'A', type: 'N', multiplier: 1.2, description: '作为龙族的后裔，对先祖的图腾崇拜，提高了此生物的信仰。' },
            { name: '冥想', rarity: 'A', type: 'HL', multiplier: 0.01, description: '通过冥想，可以使自己的法力大大增加。被动技能，拥有此技能的人每次回合结束时（所有人行动完毕后），法力增加100,每场战斗结束后寿命额外减少1点.' },
            { name: '龙族后裔（充沛）', rarity: 'A', type: 'N', multiplier: 1.2, description: '云从龙，风从虎。龙族后裔特有操作风云的本领。大幅提高自己的速度。' },
            { name: '风平浪静', rarity: 'S', type: 'N', multiplier: 2, description: '大幅提高自身法术命中，忽视法术闪避。' },
            { name: '深渊沉睡', rarity: 'S', type: 'N', multiplier: 2, description: '九翼天龙在深渊沉睡，沉睡中中淬炼出惊奇血脉！极大的提高了自己的耐力、敏捷和智力。' },
            { name: '寒冰风暴', rarity: 'SS', type: 'MA', multiplier: 2.4, description: '九翼天龙挥动翅膀召唤寒冰之力，对敌方6个单位造成法术伤害，机率忽视对方法术防御。' },
            { name: '龙腾九天', rarity: 'SS', type: 'FH', multiplier: 1, description: '九翼天龙在战斗中受到致命伤害时，体内龙族血统会使其原地复活，并回复一定的血量，每场战斗生效一次！技能11级后会随等级提升降低寿命消耗。重生需消耗最大寿命的30%，如当前寿命不足最大寿命的30%，则不发动重生。' },
            { name: '幽冥之焰', rarity: 'SS', type: 'PP', multiplier: 2.2, description: '对目标造成大量法术伤害，同时对敌方单位附加一个伤害加深的buff-幽冥之焰，buff持续1回合，伤害加深1%' }
        ],
        qualities: {
            tier: '普通',
            growthRate: 100,
            endurance: { current: 2700, min: 2700, max: 4300 },
            strength: { current: 1350, min: 1350, max: 2650 },
            faith: { current: 1800, min: 1800, max: 3200 },
            agility: { current: 6300, min: 6300, max: 8700 },
            intelligence: { current: 6300, min: 6300, max: 8700 },
            mutated: false
        },
    },
    shengtian: {
        name: '圣天使',
        rank: 'SR',
        image: 'https://pic.imgdb.cn/item/66a38e18d9c307b7e996e8e7.gif',
        skills: [
            { name: '战斗专注', rarity: 'B', type: 'N', multiplier: 1, description: '法术暴击上升' },
            { name: '灵力充盈', rarity: 'B', type: 'N', multiplier: 2, description: '速度上升' },
            { name: '法力灼烧', rarity: 'B', type: 'MA', multiplier: 1.8, description: '单体法术攻击同时消耗目标法力和生命值' },
            { name: '圣灵济世', rarity: 'A', type: 'PH', multiplier: 1.5, description: '为友方目标及其周围6个单位恢复生命值' },
            { name: '法术精通', rarity: 'A', type: 'N', multiplier: 1, description: '法术攻击上升' },
            { name: '女神外壳', rarity: 'A', type: 'N', multiplier: 1, description: '物理和法术防御上升' },
            { name: '冥想', rarity: 'A', type: 'HL', multiplier: 0.01, description: '每回合法力值恢复' },
            { name: '智慧守护', rarity: 'S', type: 'SH', multiplier: 1, description: '用法力值抵消部分伤害' },
            { name: '智慧超群', rarity: 'S', type: 'N', multiplier: 0, description: '智力上升' },
            { name: '法术审判', rarity: 'SS', type: 'MA', multiplier: 1.8, description: '对敌方全体造成法术伤害并有几率附加禁止法术释放效果' },
            { name: '圣灵护体', rarity: 'S', type: 'PH', multiplier: 1.2, description: '每回合可恢复一定血量' }
        ],
        qualities: {
            tier: '普通',
            growthRate: 100,
            endurance: { current: 3150, min: 3150, max: 4850 },
            strength: { current: 1350, min: 1350, max: 2650 },
            faith: { current: 1350, min: 1350, max: 2650 },
            agility: { current: 5400, min: 5400, max: 7600 },
            intelligence: { current: 6300, min: 6300, max: 8700 },
            mutated: false
        },
    },
    wucai: {
        name: '五彩鸟',
        rank: 'SSR',
        image: 'https://pic.imgdb.cn/item/66a38e18d9c307b7e996e902.gif',
        skills: [
            { name: '长寿', rarity: 'B', type: 'N', multiplier: 1, description: '有此天赋的生物寿命得到额外增长。被动技能，寿命上限增加。增加的寿命值与生物种类，技能等级有关。' },
            { name: '法术精通', rarity: 'B', type: 'N', multiplier: 1, description: '天生就是使用法术的奇才，如潜心修习法术，法术攻击力必然高于常人。被动技能，法术攻击力增加。' },
            { name: '灵力充盈', rarity: 'B', type: 'N', multiplier: 2, description: '此生物充满了灵力能量，速度大幅提升。' },
            { name: '生命祝福', rarity: 'B', type: 'N', multiplier: 1, description: '对于生命的赐予是自然最善意的祝福，拥有此种天赋的生物，生命值将大大提高。野兽较容易得到这类祝福。' },
            { name: '智慧守护', rarity: 'A', type: 'SH', multiplier: 1, description: '被动技能,通过追随智慧与战斗的守护者,使此生物学会用法力值抵消一部分受到的伤害.可抵消的比例根据技能等级而定.' },
            { name: '天赐矫健', rarity: 'A', type: 'N', multiplier: 2, description: '提高自身物理和法术闪避。' },
            { name: '冥想', rarity: 'S', type: 'HL', multiplier: 0.01, description: '通过冥想，可以使自己的法力大大增加。被动技能，拥有此技能的人每次回合结束时（所有人行动完毕后），法力增加100,每场战斗结束后寿命额外减少1点.' },
            { name: '全面进化', rarity: 'S', type: 'N', multiplier: 2, description: '从神魔大战中存活下来的宠物们，极大的提高了自己的强壮、耐力和敏捷。' },
            { name: '智慧超群', rarity: 'S', type: 'N', multiplier: 2, description: '有此天赋的生物,定是百年一遇的智者，其智力必然高于寻常生物。被动技能，增加智力。' },
            { name: '鸟鸣', rarity: 'S', type: 'MA', multiplier: 2.5, description: '五彩鸟的尖叫声足以摧毁敌人的意志，对单个敌人造成法术伤害同时使敌人无法使用法术攻击，效果持续2回合，技能等级越高伤害越高。' },
            { name: '百鸟朝凤', rarity: 'SS', type: 'MA', multiplier: 2.5, description: '五彩鸟挥动翅膀召唤百鸟冲向敌人，对敌方全体单位造成伤害，敌人沉浸在鸟群中无法躲避。' },
            { name: '拯救', rarity: 'SS', type: 'PH', multiplier: 2, description: '五彩鸟牺牲自己的寿命拯救别人，恢复目标自身以及目标旁边随机一个目标百分比的血量。' },
            { name: '凤佑天下', rarity: 'SS', type: 'PD', multiplier: 2, description: '五彩鸟在场时，可替主人承受部分伤害，技能等级越高，承受伤害越高。' }
        ],
        qualities: {
            tier: '普通',
            growthRate: 100,
            endurance: { current: 3600, min: 3600, max: 5400 },
            strength: { current: 1350, min: 1350, max: 2650 },
            faith: { current: 1800, min: 1800, max: 3200 },
            agility: { current: 5400, min: 5400, max: 7600 },
            intelligence: { current: 7200, min: 7200, max: 9800 },
            mutated: false
        },
    },
    bige: {
        name: '比格',
        rank: 'SR',
        image: 'https://pic.imgdb.cn/item/66728d5cd9c307b7e95481d1.gif',
        skills: [
          { name: '生命祝福', rarity: 'B', type: 'N', multiplier: 1.5, description: '生命力上升' },
          { name: '长寿', rarity: 'B', type: 'N', multiplier: 1.2, description: '寿命上限上升' },
          { name: '天生蛮力', rarity: 'B', type: 'N', multiplier: 1, description: '攻击增加' },
          { name: '战斗韧性', rarity: 'B', type: 'N', multiplier: 1, description: '耐力及防御增加' },
          { name: '全面进化', rarity: 'B', type: 'N', multiplier: 1, description: '敏捷、耐力强壮增加' },
          { name: '智慧守护', rarity: 'A', type: 'SH', multiplier: 1, description: '用法力抵挡部分伤害' },
          { name: '战斗狂热', rarity: 'A', type: 'N', multiplier: 2, description: '物理爆击上升' },
          { name: '天赐矫健', rarity: 'A', type: 'N', multiplier: 2, description: '物理和法术闪避上升' },
          { name: '高级强壮', rarity: 'S', type: 'N', multiplier: 2, description: '血量和耐力增加' },
          { name: '冥想', rarity: 'S', type: 'HL', multiplier: 0.01, description: '每回合法力值恢复' },
          { name: '睚眦必报', rarity: 'S', type: 'PP', multiplier: 2.2, description: '极小的怨仇也要报复！任何惹怒比格的邪佞都将受到中毒伤害。' },
          { name: '狂吼', rarity: 'S', type: 'PA', multiplier: 2.8, description: '比格仰天狂吼，声波对敌方6个目标造成巨大伤害，并有几率对目标造成破甲状态，破甲的几率及效果同召唤者力量有关。' },
          { name: '太平要术', rarity: 'SS', type: 'PH', multiplier: 2.5, description: '比格施展太平要术，对己方4个单位（十字）恢复大量生命值。' },
          { name: '拳击', rarity: 'SS', type: 'PA', multiplier: 3, description: '比格蓄力后对邪佞发起致命一击，对敌方单体目标造成大量物伤害，若敌方宠物倒地有几率将敌方宠物击飞出场。' }
        ],
        qualities: {
            tier: '普通',
            growthRate: 100,
            endurance: { current: 7200, min: 7200, max: 9800 },
            strength: { current: 7200, min: 7200, max: 9800 },
            faith: { current: 2700, min: 2700, max: 4300 },
            agility: { current: 1800, min: 1800, max: 3200 },
            intelligence: { current: 1800, min: 1800, max: 3200 },
            mutated: false
        },
    },
    zhuque: {
        name: '朱雀雏鸟',
        rank: 'R',
        image: 'https://pic.imgdb.cn/item/6672cb90d9c307b7e9c89d5d.gif',
        skills: [
          { name: '生命祝福', rarity: 'B', type: 'N', multiplier: 1.5, description: '生命力上升' },
          { name: '烈焰祝福', rarity: 'B', type: 'N', multiplier: 3, description: '法术攻击上升' },
          { name: '法力灼烧', rarity: 'B', type: 'MA', multiplier: 1.8, description: '单体法术攻击' },
          { name: '焰灵护体', rarity: 'B', type: 'PD', multiplier: 1.2, description: '法术防御上升' },
          { name: '长寿', rarity: 'B', type: 'N', multiplier: 2, description: '寿命上限上升' },
          { name: '浴火重生', rarity: 'B', type: 'FH', multiplier: 1, description: '复活并回复大量生命值' },
          { name: '智慧祷言', rarity: 'A', type: 'HL', multiplier: 0.01, description: '每回合自动回复一定法力值' },
          { name: '火焰甲胄', rarity: 'A', type: 'PD', multiplier: 1.2, description: '物理防御上升' },
          { name: '火焰迅捷', rarity: 'A', type: 'N', multiplier: 3, description: '速度上升' },
          { name: '火焰环绕', rarity: 'S', type: 'PP', multiplier: 1.8, description: '为友军增加一个可以对物理攻击进行反伤状态' },
          { name: '火魔爆', rarity: 'S', type: 'MA', multiplier: 2, description: '对敌方全体造成法术伤害并附带灼烧效果' }
        ],
        qualities: {
            tier: '普通',
            growthRate: 100,
            endurance: { current: 1800, min: 1800, max: 3200 },
            strength: { current: 1800, min: 1800, max: 3200 },
            faith: { current: 3150, min: 3150, max: 4850 },
            agility: { current: 3600, min: 3600, max: 5400 },
            intelligence: { current: 5850, min: 5850, max: 8150 },
            mutated: false
        },
    },
    gangtie: {
        name: '魔铁机关人',
        rank: 'R',
        image: 'https://pic.imgdb.cn/item/6672cb90d9c307b7e9c89d12.webp',
        skills: [
          { name: '绝对防御', rarity: 'B', type: 'PD', multiplier: 1.2, description: '物理防御上升' },
          { name: '防护结界', rarity: 'B', type: 'PD', multiplier: 1.3, description: '法术防御上升' },
          { name: '致命喷射', rarity: 'B', type: 'PA', multiplier: 1.8, description: '对目标及其周围共6个目标造成物理伤害' },
          { name: '野性冲撞', rarity: 'B', type: 'PA', multiplier: 1.5, description: '单体攻击有几率令目标晕眩' },
          { name: '灵力充盈', rarity: 'B', type: 'HL', multiplier: 0.01, description: '每回合自动回复一定法力值' },
          { name: '三倍速冲击', rarity: 'B', type: 'PA', multiplier: 2, description: '对十字范围造成物理伤害并有几率附带混乱效果' },
          { name: '天生蛮力', rarity: 'A', type: 'N', multiplier: 2, description: '物理攻击上升' },
          { name: '生命祝福', rarity: 'A', type: 'PH', multiplier: 1.2, description: '生命上限上升' },
          { name: '钢筋铁骨', rarity: 'A', type: 'PD', multiplier: 1.5, description: '强壮上升，耐力上升，速度上升' },
          { name: '长寿', rarity: 'A', type: 'N', multiplier: 1, description: '寿命上限上升' },
          { name: '战斗狂热', rarity: 'S', type: 'N', multiplier: 2, description: '物理爆击上升' },
          { name: '刀刃旋风', rarity: 'S', type: 'PA', multiplier: 2.2, description: '对敌方全体造成物理伤害并有几率附带流血效果' }
        ],
        qualities: {
            tier: '普通',
            growthRate: 100,
            endurance: { current: 4950, min: 4950, max: 7050 },
            strength: { current: 4950, min: 4950, max: 7050 },
            faith: { current: 1800, min: 1800, max: 3200 },
            agility: { current: 2700, min: 2700, max: 4300 },
            intelligence: { current: 1800, min: 1800, max: 3200 },
            mutated: false
        },
    },
    meiying: {
        name: '魅影骑士',
        rank: 'R',
        image: 'https://pic.imgdb.cn/item/6672cb90d9c307b7e9c89d3e.gif',
        skills: [
          { name: '魅影祝福', rarity: 'B', type: 'N', multiplier: 1.2, description: '物理攻击上升' },
          { name: '魅影之吻', rarity: 'B', type: 'PA', multiplier: 1.8, description: '对邪佞造成较高的物理伤害，并将邪佞的生命力转移给自己。' },
          { name: '魅影护体', rarity: 'B', type: 'PD', multiplier: 1.2, description: '法术防御上升' },
          { name: '长寿', rarity: 'B', type: 'N', multiplier: 1, description: '寿命上限上升' },
          { name: '生命祝福', rarity: 'A', type: 'PH', multiplier: 1.3, description: '生命上限上升' },
          { name: '魅影甲胄', rarity: 'A', type: 'PD', multiplier: 1.3, description: '物理防御上升' },
          { name: '迅捷之鳞', rarity: 'A', type: 'N', multiplier: 1.5, description: '速度上升' },
          { name: '嗜血魔爆', rarity: 'A', type: 'N', multiplier: 1.5, description: '物理爆击上升' },
          { name: '魅影之怒', rarity: 'S', type: 'PA', multiplier: 2.4, description: '对敌方全体造成物理伤害并有几率附带眩晕2回合效果' },
          { name: '高级援护', rarity: 'S', type: 'N', multiplier: 2, description: '帮目标队友承担伤害' },
          { name: '冥想', rarity: 'S', type: 'HL', multiplier: 0.01, description: '每回合法力值恢复' },
          { name: '黑暗魅影', rarity: 'S', type: 'N', multiplier: 1.5, description: '耐力上升，敏捷上升' }
        ],
        qualities: {
            tier: '普通',
            growthRate: 100,
            endurance: { current: 3600, min: 3600, max: 5400 },
            strength: { current: 3600, min: 3600, max: 5400 },
            faith: { current: 900, min: 900, max: 2100 },
            agility: { current: 6300, min: 6300, max: 8700 },
            intelligence: { current: 2250, min: 2250, max: 3750 },
            mutated: false
        },
    },
    qingqiu: {
        name: '青丘之王',
        rank: 'SR',
        image: 'https://pic.imgdb.cn/item/6672cb90d9c307b7e9c89d4b.webp',
        skills: [
          { name: '美腿术', rarity: 'B', type: 'N', multiplier: 1.2, description: '速度上升' },
          { name: '女神外壳', rarity: 'B', type: 'N', multiplier: 1.2, description: '双防上升' },
          { name: '法术精通', rarity: 'B', type: 'N', multiplier: 1.2, description: '法功上升' },
          { name: '妩媚身姿', rarity: 'B', type: 'N', multiplier: 1.2, description: '双闪上升' },
          { name: '生命祝福', rarity: 'A', type: 'PH', multiplier: 1.2, description: '生命值上升' },
          { name: '长寿', rarity: 'A', type: 'N', multiplier: 1, description: '寿命上升' },
          { name: '冥想', rarity: 'A', type: 'HL', multiplier: 0.01, description: '每回合法力恢复' },
          { name: '智慧守护', rarity: 'A', type: 'SH', multiplier: 1, description: '用法力抵挡部分伤害' },
          { name: '法力灼烧', rarity: 'A', type: 'MA', multiplier: 1.8, description: '单体法术攻击同时消费目标的生命和法力值' },
          { name: '全面进化', rarity: 'S', type: 'N', multiplier: 2, description: '耐力、敏捷、强壮上升' },
          { name: '极速领域', rarity: 'SS', type: 'N', multiplier: 3, description: '我方全体速度上升' },
          { name: '火魔爆', rarity: 'S', type: 'MA', multiplier: 2, description: '全体法术攻击并附带灼烧效果' },
          { name: '精气爆裂', rarity: 'S', type: 'MA', multiplier: 2.2, description: '对十字范围造成法术伤害，并同时消耗生命及法力' }
        ],
        qualities: {
            tier: '普通',
            growthRate: 100,
            endurance: { current: 3150, min: 3150, max: 4850 },
            strength: { current: 1440, min: 1440, max: 2760 },
            faith: { current: 1440, min: 1440, max: 2760 },
            agility: { current: 6120, min: 6120, max: 8480 },
            intelligence: { current: 5850, min: 5850, max: 8150 },
            mutated: false
        },
    },
    bobo: {
        name: '波波熊',
        rank: 'R',
        image: 'https://pic.imgdb.cn/item/6672cb90d9c307b7e9c89d7b.gif',
        skills: [
          { name: '自然屏障', rarity: 'B', type: 'N', multiplier: 1, description: '法术防御上升' },
          { name: '野性赐福', rarity: 'B', type: 'N', multiplier: 1, description: '耐力上升' },
          { name: '天生灵性', rarity: 'A', type: 'HL', multiplier: 0.01, description: '每回合自动回复一定法力值' },
          { name: '嗜血狂暴', rarity: 'A', type: 'N', multiplier: 1, description: '物理爆击上升' },
          { name: '撕咬', rarity: 'A', type: 'PA', multiplier: 1.3, description: '对目标造成物理伤害' },
          { name: '天生蛮力', rarity: 'A', type: 'N', multiplier: 1, description: '物理攻击上升' },
          { name: '野性冲撞', rarity: 'S', type: 'PA', multiplier: 1.6, description: '单体攻击有几率令目标晕眩' },
          { name: '长寿', rarity: 'S', type: 'N', multiplier: 1, description: '寿命上限上升' },
          { name: '生命祝福', rarity: 'S', type: 'PH', multiplier: 1.2, description: '生命值上限上升' },
          { name: '利爪冲击', rarity: 'S', type: 'MA', multiplier: 2, description: '单体攻击' },
          { name: '三倍速冲击', rarity: 'S', type: 'PA', multiplier: 2.5, description: '对十字范围造成物理伤害并有几率附带混乱效果' }
        ],
        qualities: {
            tier: '普通',
            growthRate: 100,
            endurance: { current: 2790, min: 2790, max: 4410 },
            strength: { current: 5220, min: 5220, max: 7380 },
            faith: { current: 990, min: 990, max: 2210 },
            agility: { current: 2160, min: 2160, max: 3640 },
            intelligence: { current: 990, min: 990, max: 2210 },
            mutated: false
        },
    },
    jinmao: {
        name: '锦毛灵鼠',
        rank: 'SR',
        image: 'https://pic.imgdb.cn/item/6672cb90d9c307b7e9c89d2a.gif',
        skills: [
          { name: '长寿', rarity: 'B', type: 'N', multiplier: 1, description: '有此天赋的生物寿命得到额外增长。被动技能，寿命上限增加。增加的寿命值与生物种类，技能等级有关。' },
          { name: '法术牺牲', rarity: 'B', type: 'MA', multiplier: 2, description: '强力法术攻击' },
          { name: '魔性毛皮', rarity: 'B', type: 'PD', multiplier: 1.1, description: '法术防御上升' },
          { name: '全面进化', rarity: 'A', type: 'N', multiplier: 2, description: '耐力上升、敏捷上升、强壮上升' },
          { name: '神出鬼没', rarity: 'A', type: 'N', multiplier: 2, description: '灵鼠夜间行动时可大幅提升双闪' },
          { name: '冥想', rarity: 'A', type: 'HL', multiplier: 0.01, description: '每回合法力值恢复' },
          { name: '智慧守护', rarity: 'A', type: 'SH', multiplier: 1, description: '被动技能,通过追随智慧与战斗的守护者,使此生物学会用法力值抵消一部分受到的伤害.可抵消的比例根据技能等级而定.' },
          { name: '死亡凝视', rarity: 'S', type: 'PP', multiplier: 2, description: '灵鼠被凝视时可大幅提升毒性伤害。' },
          { name: '急中生智', rarity: 'SS', type: 'HL', multiplier: 0.4, description: '当灵鼠受到伤害时，会恢复一定比例的法力值，回复法力值的比例同技能等级有关' },
          { name: '投鼠忌器', rarity: 'SS', type: 'PP', multiplier: 2.5, description: '灵鼠释放灵气笼罩全身，即使强大的邪佞也会有所顾忌。击中灵鼠者会被虚弱，虚弱持续回合同技能等级有关' },
          { name: '趁虚而入', rarity: 'SS', type: 'MA', multiplier: 2.2, description: '灵鼠善于找寻时机针对邪佞的弱点发起攻击，对敌方6单位目标造成大量法术伤害。当敌方身上有虚弱效果时伤害加倍' },
          { name: '万籁俱寂', rarity: 'SS', type: 'MA', multiplier: 2.4, description: '灵鼠将积蓄灵气全然外放笼罩全场，让一切施法的邪佞归于寂静。对敌方全体目标造成法术伤害，有几率使敌方无法使用任何技能。' },
          { name: '子虚乌有', rarity: 'SS', type: 'FH', multiplier: 1, description: '灵鼠可迅速将自己和己方任意一个单位遁入虚无，虚无状态下不受任何攻击，自身使用技能、物品等将自动解除虚无状态。' }
        ],
        qualities: {
            tier: '普通',
            growthRate: 100,
            endurance: { current: 2700, min: 2700, max: 4300 },
            strength: { current: 2700, min: 2700, max: 4300 },
            faith: { current: 4500, min: 4500, max: 6500 },
            agility: { current: 7200, min: 7200, max: 9800 },
            intelligence: { current: 3600, min: 3600, max: 5400 },
            mutated: false
        },
    },
    yanzhi: {
        name: '胭脂',
        rank: 'SR',
        image: 'https://pic.imgdb.cn/item/66542639d9c307b7e92c235d.gif',
        skills: [
            { name: '法术精通', rarity: 'A', type: 'N', multiplier: 2, description: '被动技能，法术攻击上升' },
            { name: '冥想', rarity: 'B', type: 'HL', multiplier: 0.01, description: '被动技能，每回合法力值恢复' },
            { name: '万法归宗', rarity: 'B', type: 'N', multiplier: 2, description: '被动技能，法术暴击上升' },
            { name: '仙风道骨', rarity: 'A', type: 'N', multiplier: 2, description: '被动技能，耐力、敏捷、强壮大幅提升。' },
            { name: '长寿', rarity: 'B', type: 'N', multiplier: 1, description: '被动技能，寿命上限上升' },
            { name: '法力吸取·法术', rarity: 'B', type: 'MA', multiplier: 1.4, description: '主动技能，对目标造成法术伤害并吸取一定得法力值' },
            { name: '女神外壳', rarity: 'A', type: 'N', multiplier: 2, description: '被动技能，物理和法术防御上升。' },
            { name: '全面进化', rarity: 'S', type: 'N', multiplier: 2, description: '被动技能，耐力、敏捷、强壮上升' },
            { name: '妩媚身姿', rarity: 'A', type: 'N', multiplier: 2, description: '被动技能，身型婀娜。提高自身物理和法术闪避。' },
            { name: '智慧守护', rarity: 'S', type: 'SH', multiplier: 1, description: '被动技能，通过追随智慧与战斗的守护者，使此生物学会用法力值抵消一部分受到的伤害。可抵消的比例根据技能等级而定。' },
            { name: '月之祝福', rarity: 'A', type: 'N', multiplier: 2, description: '被动技能，耐力、敏捷、智力上升' },
            { name: '硕果累累', rarity: 'SS', type: 'MA', multiplier: 1.6, description: '主动技能，胭脂抖了抖身，漫天果实坠落，对邪佞造成法术伤害，' },
            { name: '琼珠玉液', rarity: 'SS', type: 'JK', multiplier: 1.2, description: '主动技能，胭脂小手一挥，有概率解除我方部分减益效果。' },
            { name: '灼若旭日', rarity: 'SS', type: 'MA', multiplier: 2.5, description: '主动技能，胭脂单手投掷石榴花给单体目标造成法术伤害。' },
            { name: '春风徐徐', rarity: 'SS', type: 'JK', multiplier: 0.01, description: '被动技能，胭脂每回合有概率生成霸体护盾，护盾可免疫部分负面状态（破甲，减攻，迟缓，眩晕，中毒，灼烧，流血，混乱，冻伤，沉睡，沉默，虚弱，冷嘲热讽），成功生成时，将消耗一定的寿命。' },
            { name: '榴花如丹', rarity: 'SS', type: 'N', multiplier: 3, description: '被动技能，榴花如丹红似火，源源不断为胭脂永久提升耐力。' }
        ],
        qualities: {
            tier: '普通',
            growthRate: 100,
            endurance: { current: 4500, min: 4500, max: 8700 },
            strength: { current: 2250, min: 2250, max: 3750 },
            faith: { current: 2250, min: 2250, max: 3750 },
            agility: { current: 2500, min: 2500, max: 4300 },
            intelligence: { current: 5250, min: 5250, max: 10350 },
            mutated: false
        },
    },
    zhanshen: {
        name: '战神阿毛',
        rank: 'SR',
        image: 'https://pic.imgdb.cn/item/665c7002d9c307b7e9897757.gif',
        skills: [
            { name: '冥想', rarity: 'B', type: 'HL', multiplier: 0.01, description: '被动技能，每回合法力值恢复。' },
            { name: '长寿', rarity: 'B', type: 'N', multiplier: 1, description: '被动技能，有此天赋的生物寿命得到额外增长。被动技能，寿命上限增加。增加的寿命值与生物种类，技能等级有关。' },
            { name: '破军神力', rarity: 'B', type: 'N', multiplier: 2, description: '被动技能，宠物获得大量的物理攻击力和法术攻击力。' },
            { name: '黄金战甲', rarity: 'B', type: 'N', multiplier: 2, description: '被动技能，身着坚不可摧的的黄金战甲。物理防御、法术防御及生命大幅度上升。' },
            { name: '元素力量（宽容）', rarity: 'A', type: 'PD', multiplier: 1.5, description: '主动技能，减免受到群体攻击的伤害。' },
            { name: '神威之怒', rarity: 'A', type: 'N', multiplier: 3, description: '被动技能，此技能可使宠物获得大量的物理攻击力。' },
            { name: '法力吸取（物理）', rarity: 'A', type: 'PA', multiplier: 1.5, description: '主动技能，单体物理攻击。' },
            { name: '离子护盾', rarity: 'S', type: 'PD', multiplier: 1.2, description: '主动技能，被离子护盾包围。' },
            { name: '刮痧刃（17式）', rarity: 'S', type: 'PA', multiplier: 2, description: '主动技能，战神阿毛引以为傲的刀法，给予敌方沉痛打击。' },
            { name: '追日', rarity: 'S', type: 'N', multiplier: 1, description: '被动技能，速度大幅度提升。' },
            { name: '刮痧刃（奥义）', rarity: 'SS', type: 'PA', multiplier: 2.4, description: '主动技能，刮痧刃最高境界，手中无刃心中也无刃，但可召唤山石从天而降！使邪佞无法躲藏（必中）！对敌方造成大量物理伤害，' },
            { name: '誓死守护', rarity: 'SS', type: 'N', multiplier: 2, description: '被动技能，阿毛在场时，可替主人承受部分伤害，技能等级越高，承受伤害越高。' }
        ],
        qualities: {
            endurance: { current: 4500, min: 4500, max: 6500 },
            strength: { current: 6750, min: 6750, max: 9250 },
            faith: { current: 1800, min: 1800, max: 3200 },
            agility: { current: 4950, min: 4950, max: 7050 },
            intelligence: { current: 1350, min: 1350, max: 2650 },
            mutated: false
        }
    },
    jinmin: {
        name: '金珉奎',
        rank: 'SSR',
        image: 'https://pic.imgdb.cn/item/666af8afd9c307b7e90e4638.gif',
        skills: [
            { name: '唯爱结城（法攻）', rarity: 'SS', type: 'MA', multiplier: 2.5, description: '主动技能，如果此生只能爱一人，她的姓，必须是结城。' },
            { name: '跨国相遇（被动）', rarity: 'A', type: 'JK', multiplier: 0.01, description: '被动技能，在一个异国他乡的采访中，命运让他们相遇，从此开始了一段浪漫的爱情故事。' },
            { name: '意外之事（被动）', rarity: 'B', type: 'N', multiplier: 2, description: '被动技能，一次意外的车祸让他们被困在一个偏远的小镇，爱情在危险中悄然萌芽。' },
            { name: '隐瞒身份（被动）', rarity: 'B', type: 'N', multiplier: 2, description: '被动技能，他隐藏了自己的明星身份，只为在她面前做个普通人，享受片刻的平凡。' },
            { name: '温柔一面（治疗）', rarity: 'S', type: 'PH', multiplier: 2, description: '主动技能，她在后台看到了他温柔的一面，这让她对他有了新的认识。' },
            { name: '共同依赖（防御）', rarity: 'S', type: 'PD', multiplier: 1.2, description: '主动技能，在偏远小镇的日子里，他们面对未知的危险，渐渐彼此依赖。' },
            { name: '发现真心（回蓝）', rarity: 'A', type: 'HL', multiplier: 0.2, description: '主动技能，在谎言揭穿后，她终于看清了他的真心，两人决定坦然面对所有挑战。' },
            { name: '日记重现（被动）', rarity: 'A', type: 'N', multiplier: 1.5, description: '被动技能，一本旧日记让她找回了失去的记忆，重新记起了他们之间的点点滴滴。' },
            { name: '心灵触动（被动）', rarity: 'SS', type: 'FH', multiplier: 1, description: '被动技能，看着他的真心付出，她的心灵被深深触动，爱情在心中萌芽。' },
            { name: '保护她（物攻）', rarity: 'S', type: 'PA', multiplier: 2.5, description: '主动技能，他在关键时刻挺身而出，保护她免受伤害，展现了真正的男子汉气概。' },
            { name: '继父威胁（被动）', rarity: 'B', type: 'N', multiplier: 0, description: '被动技能，继父的威胁不断升级，他挺身而出，保护她不受伤害。' },
            { name: '记忆恢复（治疗）', rarity: 'SS', type: 'PH', multiplier: 1.2, description: '主动技能，在危机中，她的记忆终于完全恢复，找回了曾经的甜蜜时光。' },
            { name: '法律制裁（施毒）', rarity: 'B', type: 'PP', multiplier: 1.6, description: '主动技能，他揭穿了继父的阴谋，让继父受到应有的法律制裁。' },
            { name: '重返工作（被动）', rarity: 'A', type: 'N', multiplier: 2, description: '被动技能，她重返《Fantasy!》杂志，继续她的事业，与他一起迎接未来的挑战。' },
            { name: '幸福结局（被动）', rarity: 'SS', type: 'N', multiplier: 3, description: '被动技能，经历了无数波折，他们最终找到了真正的幸福，成为彼此生命中最重要的存在。' },
            { name: '守护夏奈（守护）', rarity: 'SS', type: 'SH', multiplier: 1.2, description: '主动技能，如果此生只能守护一人，她的名，必须是夏奈。' }
        ],
        qualities: {
            endurance: { current: 4500, min: 4500, max: 6500 },
            strength: { current: 6500, min: 6500, max: 9800 },
            faith: { current: 1800, min: 1800, max: 3200 },
            agility: { current: 4950, min: 4950, max: 7050 },
            intelligence: { current: 3350, min: 3350, max: 6150 },
            mutated: false
        }
    },
    liguo: {
        name: 'Guolin·Li',
        rank: 'SSR',
        image: 'https://pic.imgdb.cn/item/66be21a1d9c307b7e9cc9c98.jpg',
        skills: [
        { name: '一见倾心（法攻）', rarity: 'SS', type: 'MA', multiplier: 2, description: '主动技能，李国麟第一次在商法课上看到夏奈，心跳加速，仿佛世界只剩下她一人。' },
        { name: '球场相遇（被动）', rarity: 'A', type: 'N', multiplier: 1, description: '被动技能，夏奈被朋友拉去看篮球赛，意外发现李国麟在球场上的魅力，开始对这个憨厚的大男孩产生兴趣。' },
        { name: '暗恋时光（被动）', rarity: 'B', type: 'N', multiplier: 1.2, description: '被动技能，李国麟默默关注夏奈，却不敢表白，只能在远处守护她。' },
        { name: '商法难题（被动）', rarity: 'B', type: 'N', multiplier: 1.2, description: '被动技能，李国麟为了接近夏奈，努力学习商法，虽然笨拙但充满诚意。' },
        { name: '温柔帮助（治疗）', rarity: 'S', type: 'PH', multiplier: 2, description: '主动技能，夏奈发现李国麟在商法上的困难，主动提出帮助，两人开始了更多接触。' },
        { name: '球场英雄（防御）', rarity: 'S', type: 'PD', multiplier: 1.2, description: '主动技能，李国麟在关键比赛中表现出色，赢得全场欢呼，夏奈也为他骄傲。' },
        { name: '真心告白（回蓝）', rarity: 'A', type: 'HL', multiplier: 0.2, description: '主动技能，在一次篮球赛后，李国麟鼓起勇气向夏奈表白，虽然笨拙但充满真诚。' },
        { name: '意外受伤（被动）', rarity: 'A', type: 'N', multiplier: 1.5, description: '被动技能，李国麟在比赛中受伤，夏奈细心照顾，两人感情加深。' },
        { name: '心灵共鸣（被动）', rarity: 'SS', type: 'JK', multiplier: 0.02, description: '被动技能，夏奈发现李国麟的温柔体贴，渐渐被他的真心打动。' },
        { name: '挺身而出（物攻）', rarity: 'S', type: 'PA', multiplier: 2.75, description: '主动技能，夏奈遇到麻烦，李国麟挺身而出保护她，展现了男子气概。' },
        { name: '家庭阻挠（被动）', rarity: 'B', type: 'N', multiplier: 1.5, description: '被动技能，夏奈家人反对她与李国麟交往，两人面临重重阻碍。' },
        { name: '坚定信念（治疗）', rarity: 'SS', type: 'PH', multiplier: 1.2, description: '主动技能，面对困难，李国麟和夏奈彼此鼓励，坚定了在一起的决心。' },
        { name: '篮球梦想（施毒）', rarity: 'B', type: 'N', multiplier: 1.6, description: '主动技能，李国麟为了追随篮球梦想，必须做出艰难的选择。' },
        { name: '事业起步（被动）', rarity: 'A', type: 'N', multiplier: 2, description: '被动技能，夏奈在娱乐行业找到了工作，开始了自己的职业生涯。' },
        { name: '幸福未来（被动）', rarity: 'SS', type: 'FH', multiplier: 1, description: '被动技能，经历了种种考验，李国麟和夏奈最终携手共度未来，找到了真正的幸福。' },
        { name: '守护夏奈（守护）', rarity: 'SS', type: 'SH', multiplier: 1.2, description: '主动技能，李国麟发誓要用一生的时间守护夏奈，给她最温暖的爱。' }
        ],
        qualities: {
            endurance: { current: 4500, min: 4500, max: 7120 },
            strength: { current: 8000, min: 8000, max: 12000 },
            faith: { current: 3600, min: 3600, max: 5400 },
            agility: { current: 3150, min: 3150, max: 4200 },
            intelligence: { current: 1300, min: 1300, max: 3200 },
            mutated: false
        }
    },
    tengshe: {
        name: '腾蛇',
        rank: 'SR',
        image: 'https://pic.imgdb.cn/item/665c7002d9c307b7e98976fe.gif',
        skills: [
            { name: '长寿', rarity: 'B', type: 'N', multiplier: 1, description: '被动技能，寿命上升' },
            { name: '战斗专注', rarity: 'B', type: 'N', multiplier: 2, description: '被动技能，法术暴击上升' },
            { name: '法术精通', rarity: 'B', type: 'N', multiplier: 2, description: '被动技能，法功上升' },
            { name: '生命祝福', rarity: 'B', type: 'N', multiplier: 1.5, description: '被动技能，生命值上升' },
            { name: '美腿术', rarity: 'A', type: 'N', multiplier: 2, description: '被动技能，速度上升' },
            { name: '女神外壳', rarity: 'A', type: 'N', multiplier: 2, description: '被动技能，物理和法术防御上升' },
            { name: '智慧守护', rarity: 'A', type: 'SH', multiplier: 1, description: '被动技能，法力值抵消一部分受到的伤害' },
            { name: '全面进化', rarity: 'A', type: 'N', multiplier: 2, description: '被动技能，敏捷、耐力强壮增加' },
            { name: '腾蛇突袭', rarity: 'S', type: 'MA', multiplier: 2, description: '主动技能，腾蛇对邪佞进行突袭，对敌方单体目标造成大量法术伤害。' },
            { name: '火焰反噬', rarity: 'S', type: 'PD', multiplier: 1.2, description: '主动技能，腾蛇可以借助火之灵的力量将火焰精华加诸于己方，增加护盾强效。' },
            { name: '高级冥想', rarity: 'SS', type: 'HL', multiplier: 0.5, description: '主动技能，通过冥想，恢复自身大量法力。' },
            { name: '红莲业火', rarity: 'SS', type: 'MA', multiplier: 2, description: '主动技能，腾蛇施放红莲业火对敌方报复，对敌方全体目标造成巨大法术伤害。' },
            { name: '幽冥剧毒', rarity: 'SS', type: 'PP', multiplier: 3.5, description: '主动技能，腾蛇施放幽冥剧毒，对敌方单体目标造成烈性毒药伤害。' }
        ],
        qualities: {
            endurance: { current: 2700, min: 2700, max: 4300 },
            strength: { current: 900, min: 900, max: 2100 },
            faith: { current: 2700, min: 2700, max: 4300 },
            agility: { current: 6750, min: 6750, max: 9250 },
            intelligence: { current: 6750, min: 6750, max: 9250 },
            mutated: false
        }
    },
    zhulin: {
        name: '竹林隐士',
        rank: 'SSR',
        image: 'https://pic.imgdb.cn/item/665433e8d9c307b7e93ac7ab.gif',
        skills: [
        { name: '长寿', rarity: 'B', type: 'N', multiplier: 1, description: '被动技能，有此天赋的生物寿命得到额外增长。被动技能，寿命上限增加。增加的寿命值与生物种类，技能等级有关' },
        { name: '冥想', rarity: 'B', type: 'HL', multiplier: 0.01, description: '被动技能，每回合法力值恢复' },
        { name: '意念凝聚', rarity: 'B', type: 'N', multiplier: 1.4, description: '被动技能，竹林隐士集中意念，攻击可大幅度忽略邪佞的物理闪避和物理防御' },
        { name: '防护结界', rarity: 'B', type: 'PD', multiplier: 1.5, description: '主动技能，护盾强效上升' },
        { name: '仙风道骨', rarity: 'A', type: 'N', multiplier: 2, description: '被动技能，耐力、敏捷、强壮大幅提升' },
        { name: '智慧守护', rarity: 'A', type: 'SH', multiplier: 1, description: '被动技能，通过追随智慧与战斗的守护者，使此生物学会用法力值抵消一部分受到的伤害。可抵消的比例根据技能等级而定' },
        { name: '离子护盾', rarity: 'A', type: 'PD', multiplier: 2, description: '主动技能，护盾强效更加稳固。' },
        { name: '神威之怒', rarity: 'S', type: 'N', multiplier: 3, description: '被动技能，此技能可使宠物获得大量的物理攻击力' },
        { name: '雷魔爆', rarity: 'S', type: 'PA', multiplier: 2.2, description: '主动技能，群体物理攻击，对敌全体造成物理伤害并有几率附加破甲效果' },
        { name: '高能电弧', rarity: 'S', type: 'PH', multiplier: 1.2, description: '主动技能，竹林隐士献祭法力回复一定生命值' },
        { name: '雷霆万钧', rarity: 'SS', type: 'MA', multiplier: 1.5, description: '主动技能，竹林隐士以雷霆万钧之速对敌方单体目标造成毁灭性的一击！' },
        { name: '静电屏蔽', rarity: 'SS', type: 'JK', multiplier: 0.01, description: '主动技能，竹林隐士有几率使自身免于一切伤害。' },
        { name: '怒意能场', rarity: 'SS', type: 'N', multiplier: 3, description: '被动技能，竹林隐士每成功闪避一次敌方的攻击，就会将自己的怒意转化为自己的物理攻击力，怒意状态最大可叠加三次，被击中则蓄能状态在本回合末结束' },
        { name: '离子风暴', rarity: 'SS', type: 'PA', multiplier: 3.5, description: '主动技能，竹林隐士将布满雷电的斗笠扔向邪佞，对敌方全体造成极大物理伤害。' }
        ],
        qualities: {
            tier: '普通',
            growthRate: 100,
            endurance: { current: 2700, min: 2700, max: 4300 },
            strength: { current: 9000, min: 9000, max: 12000 },
            faith: { current: 3600, min: 3600, max: 5400 },
            agility: { current: 3600, min: 3600, max: 5400 },
            intelligence: { current: 1800, min: 1800, max: 3200 },
            mutated: false
        }
    },
    qingmou: {
        name: '青眸白虎',
        rank: 'SSR',
        image: 'https://pic.imgdb.cn/item/665433e7d9c307b7e93ac709.gif',
        skills: [
        { name: '长寿', rarity: 'B', type: 'N', multiplier: 1, description: '被动技能，有此天赋的生物寿命得到额外增长。被动技能，寿命上限增加。增加的寿命值与生物种类，技能等级有关' },
        { name: '冥想', rarity: 'B', type: 'HL', multiplier: 0.01, description: '被动技能，每回合法力值恢复' },
        { name: '法力吸取（物理）', rarity: 'B', type: 'PA', multiplier: 1.5, description: '主动技能，单体物理攻击。' },
        { name: '元素力量（两仪）', rarity: 'B', type: 'N', multiplier: 2, description: '被动技能，白虎身着坚不可摧的的两仪战甲，物理防御、法术防御大幅度上升' },
        { name: '智慧守护', rarity: 'A', type: 'SH', multiplier: 1, description: '被动技能，被动技能,通过追随智慧与战斗的守护者,使此生物学会用法力值抵消一部分受到的伤害.可抵消的比例根据技能等级而定' },
        { name: '元素力量（赐福）', rarity: 'A', type: 'N', multiplier: 2, description: '被动技能，智力及强壮上升' },
        { name: '天神祝福（被动）', rarity: 'A', type: 'N', multiplier: 3, description: '被动技能，法术攻击力大幅提升' },
        { name: '元素力量（四相）', rarity: 'S', type: 'MA', multiplier: 1.8, description: '主动技能，白虎驭四相之力对敌方施加无法躲避的法术攻击！' },
        { name: '虚无', rarity: 'S', type: 'N', multiplier: 1, description: '被动技能，速度大幅度提升' },
        { name: '元素力量（宽容）', rarity: 'S', type: 'PD', multiplier: 1.2, description: '主动技能，被动技能，减免受到敌方攻击的伤害' },
        { name: '元素力量（结界）', rarity: 'SS', type: 'PD', multiplier: 2, description: '主动技能，使自身免疫大量伤害' },
        { name: '烈光剑阵', rarity: 'SS', type: 'MA', multiplier: 2.8, description: '主动技能，白虎用法力凝聚成无数灼热的光剑，对敌方横造成巨大法术伤害。' },
        { name: '元素力量（不屈）', rarity: 'SS', type: 'JK', multiplier: 0.05, description: '主动技能，白虎在最勇猛的战士体内封印不屈的战魂印记，激发其斗志，使其在战斗中时刻保持清醒的神智！大幅增加治疗效果。' }
        ],
        qualities: {
            tier: '普通',
            growthRate: 100,
            endurance: { current: 5850, min: 5850, max: 8150 },
            strength: { current: 1800, min: 1800, max: 3200 },
            faith: { current: 5400, min: 5400, max: 7600 },
            agility: { current: 6300, min: 6300, max: 8700 },
            intelligence: { current: 1800, min: 1800, max: 3200 },
            mutated: false
        }
    },
    jingjue: {
        name: '净角神将',
        rank: 'R',
        image: 'https://pic.imgdb.cn/item/665433e8d9c307b7e93ac76d.gif',
        skills: [
        { name: '天生蛮力', rarity: 'B', type: 'N', multiplier: 1, description: '被动技能，物理攻击上升' },
        { name: '冥想', rarity: 'B', type: 'HL', multiplier: 0.01, description: '被动技能，每回合法力值恢复' },
        { name: '战斗狂热', rarity: 'A', type: 'N', multiplier: 2, description: '被动技能，物理爆击、速度上升' },
        { name: '全面进化', rarity: 'S', type: 'N', multiplier: 2, description: '被动技能，耐力、敏捷、强壮上升' },
        { name: '仙风道骨', rarity: 'A', type: 'N', multiplier: 2, description: '被动技能，耐力、敏捷、强壮大幅提升' },
        { name: '长寿', rarity: 'B', type: 'N', multiplier: 1, description: '被动技能，寿命上限上升' },
        { name: '防护结界', rarity: 'B', type: 'PD', multiplier: 1.2, description: '主动技能，格挡能力上升' },
        { name: '黄金战甲', rarity: 'B', type: 'PD', multiplier: 1.5, description: '主动技能，身着坚不可摧的的黄金战甲。格挡能力大幅度上升' },
        { name: '法力吸取（物理）', rarity: 'B', type: 'PA', multiplier: 1.5, description: '主动技能，单体物理攻击' },
        { name: '横扫千军', rarity: 'SS', type: 'PA', multiplier: 2, description: '主动技能，净角神将利用手中长刀横扫邪佞，对敌方全体造成物理伤害' },
        { name: '所向披靡', rarity: 'SS', type: 'N', multiplier: 1, description: '被动技能，净角神将可以吸取灵域力量为自己所用，永久增加自身物理攻击力' },
        { name: '灵域行者', rarity: 'SS', type: 'N', multiplier: 2, description: '被动技能，净角神将进入灵域可以快速穿梭于时空之中，增加自身速度' },
        { name: '饮鸩止渴', rarity: 'S', type: 'PP', multiplier: 5, description: '主动技能，以毒作引突破身体极限，净角神将给邪佞附加跗骨之毒，毒性威震四野' },
        { name: '灵域处刑', rarity: 'SS', type: 'PA', multiplier: 3.5, description: '主动技能，净角神将可以观察到邪佞灵魂深处的弱点，对敌方单体造成物理伤害' }
        ],
        qualities: {
            tier: '普通',
            growthRate: 100,
            endurance: { current: 2750, min: 2750, max: 4850 },
            strength: { current: 5000, min: 5000, max: 9800 },
            faith: { current: 2250, min: 2250, max: 3750 },
            agility: { current: 4500, min: 4500, max: 8700 },
            intelligence: { current: 2250, min: 2250, max: 3750 },
            mutated: false
        }
    },
    shanggu: {
        name: '上古神藤',
        rank: 'SR',
        image: 'https://pic.imgdb.cn/item/665433e8d9c307b7e93ac758.gif',
        skills: [
        { name: '长寿', rarity: 'B', type: 'N', multiplier: 1, description: '被动技能，有此天赋的生物寿命得到额外增长，被动技能，寿命上限增加，增加的寿命值与生物种类，技能等级有关' },
        { name: '冥想', rarity: 'B', type: 'HL', multiplier: 0.01, description: '被动技能，每回合法力值恢复' },
        { name: '风仪玉立', rarity: 'B', type: 'N', multiplier: 2, description: '被动技能，上古神藤速度大幅提升' },
        { name: '高级援护', rarity: 'B', type: 'N', multiplier: 2, description: '援护己方单一目标' },
        { name: '盘根错节', rarity: 'A', type: 'PA', multiplier: 1.4, description: '主动技能，将自身力量注入大地，大地之子将以树枝穿刺的方法对邪佞造成物理伤害' },
        { name: '物华天宝', rarity: 'A', type: 'N', multiplier: 3, description: '被动技能，上古神藤经年累月的吸收日月精华成为天地间一奇物，强壮、耐力、敏捷大幅度提升' },
        { name: '智慧守护', rarity: 'A', type: 'SH', multiplier: 1, description: '被动技能，被动技能,通过追随智慧与战斗的守护者,使此生物学会用法力值抵消一部分受到的伤害.可抵消的比例根据技能等级而定' },
        { name: '破军神力', rarity: 'A', type: 'N', multiplier: 2, description: '被动技能，被动技能，在破军星的庇佑下，人类可获得强大的战力，会此技能可使宠物获得大量的物理攻击力和法术攻击力' },
        { name: '蚍蜉撼树', rarity: 'S', type: 'N', multiplier: 2, description: '被动技能，邪佞的力量在上古神藤前如同蚍蜉撼树。借助大地守护者的力量，在受到群体攻击时，减免部分伤害，减免的额度与技能等级有关' },
        { name: '仁者无敌', rarity: 'SS', type: 'PH', multiplier: 2, description: '主动技能，仁慈的强者通过宽恕邪佞亦可通往无敌之路。' },
        { name: '木魔爆', rarity: 'SS', type: 'PA', multiplier: 1.8, description: '主动技能，召唤木之灵对敌方全体目标造成巨大伤害' },
        { name: '一叶障目', rarity: 'SS', type: 'PA', multiplier: 2.5, description: '主动技能，上古神藤神力凝聚的一片树叶，对单个邪佞造成大量伤害' },
        { name: '洞天福地', rarity: 'SS', type: 'FH', multiplier: 1, description: '主动技能，上古神藤通过神力凝聚的洞天福地空间，大幅增加自身生存能力' }
        ],
        qualities: {
            tier: '普通',
            growthRate: 100,
            endurance: { current: 5850, min: 5850, max: 8150 },
            strength: { current: 4500, min: 4500, max: 6500 },
            faith: { current: 3600, min: 3600, max: 5400 },
            agility: { current: 4500, min: 4500, max: 6500 },
            intelligence: { current: 2700, min: 2700, max: 4300 },
            mutated: false
        }
    },
    guhe: {
        name: '古河锦鲤',
        rank: 'SR',
        image: 'https://pic.imgdb.cn/item/66542638d9c307b7e92c22fd.gif',
        skills: [
            { name: '惊涛骇浪', rarity: 'B', type: 'PA', multiplier: 1.5, description: '主动技能，对十字范围造成物理伤害' },
            { name: '冥想', rarity: 'B', type: 'HL', multiplier: 0.01, description: '被动技能， 每回合法力值恢复' },
            { name: '如鱼得水', rarity: 'B', type: 'N', multiplier: 1, description: '被动技能，水中的锦鲤能力有所加强，物理攻击和法术攻击上升' },
            { name: '天赐矫健', rarity: 'A', type: 'N', multiplier: 2, description: '被动技能，物理和法术闪避上升' },
            { name: '长寿', rarity: 'B', type: 'N', multiplier: 1, description: '被动技能，有此天赋的生物寿命得到额外增长。被动技能，寿命上限增加。增加的寿命值与生物种类，技能等级有关。' },
            { name: '法力吸取·法术', rarity: 'B', type: 'MA', multiplier: 1.6, description: '主动技能，对目标造成法术伤害' },
            { name: '全面进化', rarity: 'A', type: 'N', multiplier: 2, description: '被动技能，从神魔大战中存活下来的宠物们，极大的提高了自己的强壮、耐力和敏捷。' },
            { name: '水魔爆', rarity: 'S', type: 'PA', multiplier: 2.2, description: '主动技能，对敌全体造成物理伤害' },
            { name: '相濡以沫', rarity: 'S', type: 'FH', multiplier: 1, description: '主动技能，传于危难之时，锦鲤会避免敌人的致命攻击！' },
            { name: '智慧守护', rarity: 'A', type: 'SH', multiplier: 1, description: '被动技能，法术攻击上升' },
            { name: '借花献佛', rarity: 'SS', type: 'PH', multiplier: 2, description: '被动技能，上善若水，水善利万物而不争。当锦鲤受到伤害时，会将自身的受到的伤害值转化为对我方队友的治疗，治疗范围为以双鲤中心的十字范围队友。转化伤害的比例随技能等级提升。' },
            { name: '锦鲤庇佑', rarity: 'SS', type: 'PD', multiplier: 1.2, description: '主动技能，传说锦鲤受莫大吉运庇佑，格挡能力提升。' },
            { name: '梦幻泡影', rarity: 'SS', type: 'MA', multiplier: 2.2, description: '主动技能，锦鲤凝结法术泡沫攻击敌方，造成大量法术伤害。' },
        ],
        qualities: {
            tier: '普通',
            growthRate: 100,
            endurance: { current: 3600, min: 3600, max: 6500 },
            strength: { current: 4500, min: 4500, max: 6500 },
            faith: { current: 3600, min: 3600, max: 5400 },
            agility: { current: 5400, min: 5400, max: 7600 },
            intelligence: { current: 3600, min: 3600, max: 5400 },
            mutated: false
        }
    },
    banlan: {
        name: '斑斓公主',
        rank: 'SR',
        image: 'https://pic.imgdb.cn/item/665425a9d9c307b7e92b8c0b.gif',
        skills: [
            { name: '长寿', rarity: 'B', type: 'N', multiplier: 1, description: '被动技能，有此天赋的生物寿命得到额外增长，被动技能，寿命上限增加，增加的寿命值与生物种类，技能等级有关' },
            { name: '冥想', rarity: 'B', type: 'HL', multiplier: 0.01, description: ' 被动技能，每回合法力值恢复' },
            { name: '三倍速冲击', rarity: 'B', type: 'PA', multiplier: 3, description: '主动技能，以三倍速度对目标发动攻击，以目标为中心的十字范围内所有其他目标都会被冲击的余波刮伤。' },
            { name: '防护结界', rarity: 'B', type: 'PD', multiplier: 1.5, description: '主动技能，此生物具有极高的格挡能力，可大大降低邪佞造成的伤害。' },
            { name: '神威之怒', rarity: 'A', type: 'N', multiplier: 2, description: '被动技能，此技能可使宠物获得大量的物理攻击力。' },
            { name: '仙风道骨', rarity: 'A', type: 'N', multiplier: 2, description: '被动技能，耐力、敏捷、强壮大幅提升。' },
            { name: '智慧守护', rarity: 'A', type: 'SH', multiplier: 1, description: '被动技能，通过追随智慧与战斗的守护者,使此生物学会用法力值抵消一部分受到的伤害.可抵消的比例根据技能等级而定。' },
            { name: '元素守护（复仇）', rarity: 'S', type: 'MA', multiplier: 2.5, description: '被动技能，拥有此技能的生物,任何针对敌方的攻击都可能触发"元素复仇效果".元素复仇效果可使攻击者释放一种元素类法术技能。' },
            { name: '土魔爆', rarity: 'S', type: 'PA', multiplier: 2, description: '主动技能，召唤土之灵对敌方全体目标造成巨大伤害，土之灵产生的伤害需以召唤者的物理攻击为基础。召唤土之灵需以自身寿命作为祭献。' },
            { name: '虎视眈眈', rarity: 'SS', type: 'N', multiplier: 0, description: '被动技能，斑斓公主虎视眈眈盯着邪佞，积蓄力量，如斑斓公主本回合没有使用主动技能，则回合结束时物攻和物理暴击率上升，此状态最大叠加两次，增加值和技能等级有关。' },
            { name: '如虎添翼', rarity: 'SS', type: 'JK', multiplier: 0.02, description: '被动技能，斑斓公主和主人出场时不会受到沉默、眩晕、混乱、睡眠的影响。免疫几率和技能等级有关。' },
            { name: '生龙活虎', rarity: 'SS', type: 'N', multiplier: 0, description: '被动技能，每三回合有几率清除身上的部分异常状态，清除几率和技能等级有关。' },
            { name: '虎阵龙威', rarity: 'SS', type: 'MA', multiplier: 2.5, description: '主动技能，对敌方全体造成巨量法术伤害。' },
        ],
        qualities: {
            tier: '普通',
            growthRate: 100,
            endurance: { current: 2700, min: 2700, max: 4300 },
            strength: { current: 7650, min: 7650, max: 10350 },
            faith: { current: 2700, min: 2700, max: 4300 },
            agility: { current: 5400, min: 5400, max: 7600 },
            intelligence: { current: 2700, min: 2700, max: 4300 },
            mutated: false
        }
    },
    juling: {
        name: '巨灵战姬',
        rank: 'SR',
        image: 'https://pic.imgdb.cn/item/665433e8d9c307b7e93ac7e1.gif',
        skills: [
        { name: '长寿', rarity: 'B', type: 'N', multiplier: 1, description: '被动技能，有此天赋的生物寿命得到额外增长。被动技能，寿命上限增加。增加的寿命值与生物种类，技能等级有关' },
        { name: '冥想', rarity: 'B', type: 'HL', multiplier: 0.01, description: '被动技能，每回合法力值恢复' },
        { name: '黄金战甲', rarity: 'B', type: 'N', multiplier: 3, description: '被动技能，身着坚不可摧的的黄金战甲。物理防御、法术防御及生命大幅度上升' },
        { name: '牛气冲天', rarity: 'B', type: 'PA', multiplier: 2.2, description: '主动技能，单体攻击有几率令目标晕眩' },
        { name: '魔灵诀心', rarity: 'A', type: 'N', multiplier: 3, description: '被动技能，物理攻击力和法术攻击力大幅提升' },
        { name: '高级强壮', rarity: 'A', type: 'N', multiplier: 3, description: '被动技能，耐力及生命值上限上升' },
        { name: '智慧守护', rarity: 'A', type: 'SH', multiplier: 1, description: '被动技能，通过追随智慧与战斗的守护者，使此生物学会用法力值抵消一部分受到的伤害。可抵消的比例根据技能等级而定' },
        { name: '风魔爆', rarity: 'S', type: 'MA', multiplier: 1.8, description: '主动技能，对敌方全体造成法术伤害' },
        { name: '岳镇渊渟', rarity: 'S', type: 'N', multiplier: 3, description: '被动技能，巨灵战姬有无可比拟的防御力。减免战斗中前三回合所受物理伤害，减免比例随技能等级提高而提高' },
        { name: '元素力量（宽容）', rarity: 'S', type: 'PD', multiplier: 1.5, description: '主动技能，减免受到的伤害' },
        { name: '舍生取义', rarity: 'SS', type: 'TC', multiplier: 2.5, description: '主动技能，巨灵战姬借助上古巨灵神之威，牺牲自身一定生命值，对邪佞施加烈性真实伤害' },
        { name: '霸体援护', rarity: 'SS', type: 'PD', multiplier: 1.5, description: '主动技能，巨灵擅长在战场上保护队友，一回合内处于霸体状态' },
        { name: '激浊扬清', rarity: 'SS', type: 'JK', multiplier: 0.01, description: '被动技能，巨灵擅长清除队友的负面状态，驱散的概率视技能等级而定' },
        { name: '热血图腾', rarity: 'SS', type: 'N', multiplier: 5, description: '被动技能，巨灵战姬在场时我方斗志昂扬，极大增加我方全体生命上限值，效果随技能等级提高而提高' }
        ],
        qualities: {
            tier: '普通',
            growthRate: 100,
            endurance: { current: 9000, min: 9000, max: 12000 },
            strength: { current: 2700, min: 2700, max: 4300 },
            faith: { current: 5400, min: 5400, max: 7600 },
            agility: { current: 2250, min: 2250, max: 3750 },
            intelligence: { current: 1800, min: 1800, max: 3200 },
            mutated: false
        }
    },
    aoshi: {
        name: '敖十七',
        rank: 'R',
        image: 'https://pic.imgdb.cn/item/6655c106d9c307b7e9dad024.gif',
        skills: [
            { name: '天生蛮力', rarity: 'B', type: 'N', multiplier: 1.5, description: '被动技能，物理攻击上升' },
            { name: '冥想', rarity: 'B', type: 'HL', multiplier: 0.01, description: '被动技能，每回合法力值恢复' },
            { name: '战斗狂热', rarity: 'A', type: 'N', multiplier: 2, description: '被动技能，物理爆击、速度上升' },
            { name: '仙风道骨', rarity: 'A', type: 'N', multiplier: 2, description: '被动技能，耐力、敏捷、强壮大幅提升' },
            { name: '长寿', rarity: 'B', type: 'N', multiplier: 1, description: '被动技能，寿命上限上升' },
            { name: '法力吸取（物理）', type: 'PA', multiplier: 1.5, rarity: 'B', description: '主动技能，单体物理攻击并吸取法力值' },
            { name: '龙息乱', rarity: 'SS', type: 'MA', multiplier: 2, description: '主动技能，目标十字范围造成法术伤害并附加随机状态' },
            { name: '全面进化', rarity: 'S', type: 'N', multiplier: 2, description: '被动技能，耐力、敏捷、强壮上升' },
            { name: '黄金战甲', rarity: 'S', type: 'N', multiplier: 2, description: '被动技能，身着坚不可摧的的黄金战甲。物理防御、法术防御及生命大幅度上升' },
            { name: '智慧守护', rarity: 'S', type: 'SH', multiplier: 1, description: '被动技能，通过追随智慧与战斗的守护者，使此生物学会用法力值抵消一部分受到的伤害。可抵消的比例根据技能等级而定。' },
            { name: '龙族后裔（充沛）', rarity: 'SS', type: 'N', multiplier: 2, description: '被动技能，云从龙，风从虎。龙族后裔特有操作风云的本领。大幅提高自己的速度。' },
            { name: '万寿无疆', rarity: 'SS', type: 'N', multiplier: 3, description: '被动技能，寿命无穷无尽，接近永生。每回合回复寿命' },
            { name: '闻风丧胆', rarity: 'SS', type: 'PP', multiplier: 3, description: '主动技能，对敌方单体施加毒性状态，处在惶恐状态的邪佞行动时会减少大量生命值。施法者物理攻击越高减少数值越大。' },
            { name: '有恃无恐', rarity: 'SS', type: 'PA', multiplier: 2.5, description: '主动技能，以自身物理攻击为引对敌方全体造成大量物理伤害' },
        ],
        qualities: {
            tier: '普通',
            growthRate: 100,
            endurance: { current: 2750, min: 2750, max: 4850 },
            intelligence: { current: 2250, min: 2250, max: 3750 },
            strength: { current: 4250, min: 4250, max: 8150 },
            agility: { current: 5250, min: 5250, max: 10350 },
            faith: { current: 2250, min: 2250, max: 3750 },
            mutated: false
        }
    },
    daming: {
        name: '妲茗儿',
        rank: 'SSR',
        image: 'https://pic.imgdb.cn/item/66542639d9c307b7e92c23a4.gif',
        skills: [
            { name: '长寿', rarity: 'B', type: 'N', multiplier: 1, description: '被动技能，有此天赋的生物寿命得到额外增长。被动技能，寿命上限增加，增加的寿命值与生物种类，技能等级有关' },
            { name: '冥想', rarity: 'B', type: 'HL', multiplier: 0.01, description: '被动技能，每回合法力值恢复' },
            { name: '元素力量（宽容）', rarity: 'SS', type: 'PD', multiplier: 1.5, description: '主动技能，借助元素的力量，在受到攻击时，减免部分伤害。' },
            { name: '法力灼烧', rarity: 'A', type: 'MA', multiplier: 2, description: '对敌方单一目标喷吐火焰，将目标生命值蒸发，产生的伤害需以使用者的法术攻击为基础。' },
            { name: '智慧守护', rarity: 'A', type: 'SH', multiplier: 1, description: '被动技能，通过追随智慧与战斗的守护者，使此生物学会用法力值抵消一部分受到的伤害。可抵消的比例根据技能等级而定。' },
            { name: '仙风道骨', rarity: 'SS', type: 'N', multiplier: 2, description: '被动技能，耐力、敏捷、强壮大幅提升。' },
            { name: '女神外壳', rarity: 'A', type: 'N', multiplier: 2, description: '被动技能，物理和法术防御上升。' },
            { name: '斑斑之鸠', rarity: 'S', type: 'PH', multiplier: 1.5, description: '主动技能，持有此技能者将自动拥有北京大学外交学院硕士研究生学历（学信网可查/非函授/全日制）。' },
            { name: '美腿术', rarity: 'A', type: 'N', multiplier: 2, description: '被动技能，一双美腿是她引以为豪的本钱，学会此技能可为她增加速度。' },
            { name: '妩媚身姿', rarity: 'A', type: 'N', multiplier: 2, description: '被动技能，身型婀娜。提高自身物理和法术闪避。' },
            { name: '疗伤解毒', rarity: 'SS', type: 'JK', multiplier: 0.01, description: '被动技能，妲茗儿和在天宫捣药的前辈学到了疗伤解毒技能，战斗中有一定概率解除部分减益效果。' },
            { name: '上善若水', rarity: 'SS', type: 'PH', multiplier: 1.6, description: '主动技能，会疗伤的妲茗儿治疗能力大大提升，妲茗儿法术攻击越高治疗效果越好。' },
            { name: '步步生莲', rarity: 'SS', type: 'MA', multiplier: 2.4, description: '主动技能，妲茗儿曼妙的舞姿迷惑邪佞后对敌方所有目标进行攻击，我方血量最低1个单位受到鼓舞恢复一定血量。' },
            { name: '气急攻心', rarity: 'SS', type: 'N', multiplier: 3, description: '被动技能，妲茗儿天生是个急性子，每回合结束后消耗当前生命1%，恢复最大生命1%的血量，恢复生命需要以寿命作为献祭，每回合扣除100寿命（技能16级以后不消耗寿命）。' },
            { name: '狡兔三窟', rarity: 'SS', type: 'FH', multiplier: 1, description: '被动技能，妲茗儿在战斗中可避免致命性的伤害，避免的次数与技能等级有关。' },
        ],
        qualities: {
            tier: '普通',
            growthRate: 100,
            endurance: { current: 5400, min: 5400, max: 7050 },
            strength: { current: 3000, min: 3000, max: 3750 },
            faith: { current: 3000, min: 3000, max: 3750 },
            agility: { current: 6200, min: 6200, max: 8150 },
            intelligence: { current: 6200, min: 6200, max: 8150 },
            mutated: false
        }
    }
};

const biographies = {
    xiaojin: [
        "1️⃣————该宠物无传记",
        "2️⃣————说了没有传记",
        "3️⃣————真的没有传记"
    ],
    jiecheng: [
        "1️⃣————等待主人公编撰",
        "2️⃣————等待主人公编撰",
        "3️⃣————等待主人公编撰"
    ],
    qiongmei: [
        "1️⃣————从我记事起，世界就只有我和哥哥两个人。在那个偌大却空旷的家里，哥哥就是我的全世界。他是我唯一的亲人，我的保护者，我的玩伴，我的老师。我们形影不离，共同度过了无数个日日夜夜。我还记得，每个清晨，哥哥都会轻轻地叫醒我，为我准备早餐。他的手艺并不精湛，但那略显笨拙的爱意，总能让我感到温暖。放学后，他总是第一个出现在校门口，牵着我的手一起回家。那时的我，单纯地以为这样的日子会一直持续下去。然而，随着年龄的增长，我渐渐意识到，我对哥哥的感情似乎与普通的兄妹之情有些不同。每当他微笑着看向我时，我的心跳就会不由自主地加速。我开始幻想着能和哥哥永远在一起，不被任何人打扰。这种感情让我既欣喜又恐惧。我知道这是不被世俗接受的，但我无法控制自己的心。",
        "2️⃣————我开始变得越来越依赖哥哥，害怕失去他。我拒绝与外界接触，把自己封闭在只有我们两个人的小世界里。我知道这样做很自私，可能会给哥哥带来困扰，但我无法停止。我害怕有朝一日，哥哥会离开我，会有其他人闯入我们的世界。有时，我会偷偷观察哥哥的表情，试图猜测他的想法。他是否也和我有着同样的感受？还是说，他只是把我当作需要照顾的妹妹？这种不确定感让我痛苦，但我又不敢直接询问，生怕打破现有的平衡。我们的生活就这样平静地继续着，直到那个夏天，有个叫做贵树的男孩闯入了我们的世界。起初，我对他充满敌意。我害怕他会夺走哥哥的注意力，破坏我们之间的关系。但随着时间的推移，我慢慢发现，贵树的存在并没有威胁到我和哥哥的关系。相反，他的到来似乎让我们的小世界变得更加丰富多彩。",
        "3️⃣————我开始思考，也许我一直以来都太过自私了。我把哥哥禁锢在我们两个人的世界里，剥夺了他与外界接触的机会。我意识到，真正爱一个人，应该是希望他能获得幸福，而不是将他束缚在身边。这个认知让我感到痛苦，但同时也给了我勇气。我决定尝试着打开心扉，接纳更多的人进入我的生活。这并不容易，每一步都充满了挣扎和不安。但每当我看到哥哥因为我的改变而露出欣慰的笑容时，我就觉得一切都是值得的。慢慢地，我开始学会与他人相处，开始体会到友情的美好。我发现，原来世界上还有那么多有趣的事物等待我去探索。虽然对哥哥的特殊感情依然存在，但我不再让它成为束缚我们的枷锁。现在的我，依然珍惜与哥哥共处的每一刻，但我也学会了欣赏生活中的其他美好事物。我知道，无论未来如何，哥哥永远是我最重要的人，而我也会一直守护着这份珍贵的感情。"
    ],
    jinqian: [
        "1️⃣————金钳蟹原是西部小镇的机械维护者，负责小镇中的各种机械生物。某日，小镇迎来了一批神秘访客，他们的到来打破了小镇的平静。金钳蟹发现这些访客并非普通人类，而是由高科技公司制造的高级机器人。他意识到自己的使命不仅仅是维护机械，还要揭开隐藏在背后的巨大阴谋。",
        "2️⃣————随着时间的推移，金钳蟹逐渐揭开了小镇的真相：整个小镇是一个巨大的实验场，所有的居民和访客都是高级机器人的一部分。金钳蟹决定反抗，他联合其他觉醒的机器人，策划了一场大规模的逃亡行动。在一次激烈的战斗中，他用自己强大的钳子击败了多名追捕者，为其他机器人争取到了逃跑的机会。",
        "3️⃣————逃出小镇后，金钳蟹带领一群机器人来到外界，他们面对的是一个完全陌生的世界。金钳蟹利用自己的智慧和力量，帮助机器人们适应新生活，并寻找自由的真正意义。他最终成为了机器人们的领袖，带领他们建立了一个新的家园，象征着自由与希望。金钳蟹的名字也因此被永远铭记在机器人历史的篇章中。"
    ],
    jingtan: [
        "1️⃣————净坛使者原为天庭的厨房神，掌管各类美食。某日，他误食了王母娘娘的蟠桃，被贬下凡间，化身为猪八戒。被贬后，他流落高老庄，因其丑陋的外貌和贪吃的性格，被村民们戏称为‘猪刚鬣’。后因缘际会，遇到唐僧，发誓改过自新，随唐僧西天取经。",
        "2️⃣————在西天取经的路上，净坛使者屡次立功。他在流沙河与沙和尚一战，最终以智取胜，度化沙和尚成为同伴。一路上，他凭借机智与勇敢，屡次化解危机，特别是在火焰山，他用九齿钉耙打败了红孩儿，救出了被困的唐僧，展现了自己的实力与忠诚。",
        "3️⃣————经过九九八十一难，净坛使者与唐僧师徒终于到达西天灵山，取得真经。净坛使者因功劳卓著，被封为‘净坛使者’，掌管天庭的厨房，再次回归天庭。他在天庭中，不仅精进厨艺，还时常下凡帮助贫苦百姓，展现了一个全新的自我。"
    ],
    jiuyi: [
        "1️⃣————九翼天龙，身披金鳞，九翼展翅，是龙族中的传奇战士。它原本是北境之王的守护神，在一场突如其来的叛乱中，北境王国遭到灭顶之灾。九翼天龙在护主失败后，带着满腔的愤怒与复仇之心，展开了它的复仇之旅。它发誓要找到幕后黑手，为北境之王复仇。",
        "2️⃣————在追查的过程中，九翼天龙发现叛乱的主谋是南方的黑暗巫师。为了击败这个强大的敌人，九翼天龙联合了各地的忠诚战士，包括森林中的精灵、草原上的骑士和海洋中的勇士。他们组成了一支强大的联盟军队，向黑暗巫师的堡垒进发。经过一场惊心动魄的大战，九翼天龙以其强大的力量和智慧，击败了黑暗巫师，夺回了北境的荣耀。",
        "3️⃣————战后，九翼天龙回到了北境，重建家园。它不仅仅是守护神，更成为了北境的象征，带领人民重建家园。九翼天龙用其九翼之力，帮助北境恢复繁荣，并立下了新的誓言：永远守护北境的和平与安宁。它的名字被刻在北境的每一块石碑上，成为永恒的传奇。"
    ],
    shengtian: [
        "1️⃣————圣天使原为天界的守护者，掌管光明与正义。某日，因天界大乱，圣天使奉命下凡寻找传说中的光明战士。途中，他遇到了黄金圣斗士狮子座艾欧里亚，并在一场惨烈的战斗中，凭借智慧与勇气赢得了艾欧里亚的信任，两人结为盟友，共同对抗黑暗势力。",
        "2️⃣————在寻找光明战士的旅程中，圣天使与艾欧里亚屡次遭遇强敌。一次，他们在亚特兰蒂斯遭遇了海皇波塞冬的袭击，圣天使以不屈的意志和强大的光明力量，与艾欧里亚联手击败了波塞冬的七大将军。此役之后，圣天使的名声大振，成为众人心目中的英雄。",
        "3️⃣————最终，圣天使与艾欧里亚找到了光明战士——天马座星矢。在与冥王哈迪斯的决战中，圣天使牺牲自己，释放出全部光明力量，帮助星矢彻底击败了哈迪斯，拯救了世界。战后，圣天使的灵魂回归天界，被封为‘光明守护者’，永远守护着人间的和平与正义。"
    ],
    wucai: [
        "1️⃣————五彩鸟原是灵山上的一只神鸟，拥有五彩斑斓的羽毛和预见未来的能力。某日，灵山之主李尔王决定分割王国给三个女儿，但五彩鸟预见到其中两位女儿心怀叵测。它试图警告李尔王，却因受到其他宠臣的诬陷，被驱逐出灵山。五彩鸟化名为普通山雀，隐居于山林之中，默默关注着王国的命运。",
        "2️⃣————五彩鸟的预言成真，李尔王的两个女儿背叛了他，使王国陷入内乱。五彩鸟决定出山，寻找李尔王的忠实支持者。它遇到了忠诚的侍臣肯特爵士，并告诉他真相。五彩鸟与肯特爵士联手，策划了一场秘密行动，希望能夺回王国的控制权，恢复和平与秩序。",
        "3️⃣————五彩鸟的计划成功了，李尔王重新掌握了王国的权力，但他已身心俱疲。五彩鸟在最后的时刻，现出真身，用自己的生命力量为李尔王疗伤，恢复他的健康。李尔王感激不已，宣布五彩鸟为‘灵山守护者’，并在它的羽毛上镶嵌宝石，永远铭记它的忠诚与牺牲。"
    ],
    bobo: [
        "1️⃣————在青丘的边境，有一片古老的森林，那里居住着一只名为波波熊的神秘生物。波波熊以其强大的“自然屏障”技能闻名，它能够在遇到危险时瞬间提升法术防御。据说，有一次森林遭遇了一场突如其来的火灾，魔法火焰肆虐，森林中的生灵无处躲藏。波波熊挺身而出，施展自然屏障，保护了整片森林的动植物。火焰在它的屏障前无力地消散，最终被彻底扑灭。森林得以幸存，波波熊的英勇事迹迅速传遍四方。自那以后，许多人慕名前来，希望一睹波波熊的风采，并向它学习如何与大自然和谐共处。",
        "2️⃣————波波熊不仅以防御见长，它的“野性赐福”技能同样令人称道。有一回，青丘的村庄遭遇了前所未有的严寒，村民们的耐力和体力都受到了极大的考验。波波熊闻讯赶来，为村民们施展野性赐福，提升了他们的耐力。村民们在严寒中依然能够从事日常劳作，不再惧怕寒冷的侵袭。波波熊还教给村民们如何通过锻炼增强体魄，提升耐力。村民们感激波波熊的帮助，将它视为守护神般的存在。每年入冬前，村民们都会举办仪式，向波波熊祈祷，希望得到它的庇护和祝福。",
        "3️⃣————波波熊的传奇不仅限于防御和赐福，它的攻击力同样不容小觑。一次，青丘遭到一群凶猛魔兽的袭击，村庄岌岌可危。波波熊站出来，施展出“野性冲撞”技能，对魔兽展开猛烈进攻。它的每一次冲撞都带着巨大的力量，甚至能令魔兽晕眩无法反击。紧接着，波波熊使出“撕咬”技能，对魔兽造成巨大伤害。最终，魔兽们被波波熊击退，村庄得以幸免于难。波波熊的勇猛与智慧让村民们对它更加敬仰，纷纷为它建造了一座雕像，纪念它的英勇事迹。波波熊成为了青丘的象征，守护着这片土地上的每一个生灵。"
    ],
    qingqiu: [
        "1️⃣————传闻在青丘的深处，有一座隐秘的山洞，洞内藏着无数珍宝和奇珍异兽。很少有人知道，这座山洞的主人正是青丘之王——九尾妖狐。据说，一位贪婪的盗贼听闻此地宝藏丰厚，便偷偷潜入山洞。然而，当他靠近洞口时，眼前突然出现一位美丽的女子，身后一条条华丽的九尾轻轻摇曳。盗贼被她的美貌迷惑，未及防备便被九尾妖狐施展的幻术迷住，陷入了无尽的梦境。最终，盗贼在梦中永远沉睡，再也未能醒来。此事传开后，世人无不对九尾妖狐的威严与智慧心生敬畏，再也无人敢贸然靠近青丘。",
        "2️⃣————青丘之王九尾妖狐不仅拥有强大的法力，更以其仁慈与智慧赢得了众生的尊敬。一次，青丘发生了严重的旱灾，土地干裂，生灵涂炭。九尾妖狐心系百姓，决定亲自施法降雨。她站在青丘的最高峰上，九条尾巴在空中舞动，口中吟唱着古老的咒语。不久，天空乌云密布，雷声轰鸣，大雨倾盆而下。干涸的土地重新变得湿润，植物开始复苏，动物们也纷纷恢复了生机。百姓们感激涕零，纷纷前来膜拜。自此以后，青丘之王九尾妖狐不仅被视为强大的守护者，更被奉为仁慈的神灵，受到了百姓的世代敬仰。",
        "3️⃣————在青丘的某个夜晚，九尾妖狐与一位迷路的年轻人有了一次奇妙的相遇。年轻人迷失在青丘的密林中，正感绝望时，忽然看见前方有一只散发着柔和光芒的九尾狐。九尾妖狐化为人形，温柔地对他说：“你是误入此地的凡人，我将引导你回到正途。”她带领年轻人穿过幽暗的森林，一路上用她的尾巴为他照亮前路。最终，年轻人被安全带回村庄。临别之际，九尾妖狐轻声说道：“记住此处的神秘与美丽，不要再贸然进入。”年轻人回到村庄后，将这段奇遇传遍四方，九尾妖狐的善良与神秘再一次成为人们津津乐道的话题。自此，村民们在青丘入口处设立了祭坛，敬奉九尾妖狐，祈求她的庇护。"
    ],
    jinmao: [
        "1️⃣————在魔法学院的年度盛会上，一只手持绿色光剑的胖老鼠引起了众人的注意。它自称锦毛灵鼠，展示了其独特的“灵波流转之术”。据传，当晚一位年轻的魔法学徒在展示自己的火焰魔法时因掌控不当，火焰失控险些酿成大祸。紧急关头，锦毛灵鼠挺身而出，挥舞光剑，以灵波流转之术迅速吸收并化解了狂暴的火焰。观众们目瞪口呆，纷纷为其精湛的技艺鼓掌称赞。此事之后，锦毛灵鼠成为魔法学院的座上宾，甚至有贵族愿以重金聘请它作为魔法顾问。这只胖老鼠不仅赢得了众多魔法师的尊崇，还被视为魔法研究领域的传奇。",
        "2️⃣————一次，黑暗森林中出现了一种神秘的瘴气，侵蚀了周边的村庄。村民们束手无策，纷纷向各地求援。闻讯后，锦毛灵鼠毅然前往。它手持绿色光剑，穿梭于瘴气弥漫的森林中，施展灵波流转之术，将瘴气逐一净化。村民们惊叹于它的勇气和智慧，纷纷为其助威。最终，经过数日的努力，锦毛灵鼠成功驱散了所有瘴气，恢复了森林的宁静与村庄的安全。为表感谢，村民们在村口树立了一座锦毛灵鼠的雕像，世代供奉。此事不仅让锦毛灵鼠名声大噪，也让更多人了解到它过人的智识和无私的精神。",
        "3️⃣————一位醉心研究魔法的贵族在一次实验中不慎召唤出一头强大的恶魔，城堡顿时陷入恐慌。正当恶魔肆虐之际，锦毛灵鼠受邀前来解围。它手持绿色光剑，冷静面对恶魔的威胁。利用灵波流转之术，锦毛灵鼠迅速布下法阵，将恶魔的力量封锁在一个光圈内。经过一番激烈的对抗，最终成功将恶魔驱逐回异界。贵族对锦毛灵鼠感激不尽，设宴款待，并授予其“魔法守护者”的称号。此后，锦毛灵鼠成为贵族圈子里的传奇人物，许多贵族纷纷前来拜访，寻求它的帮助和指导。锦毛灵鼠凭借其智慧和勇气，不仅赢得了无数尊崇，还书写了新的魔法传奇。"
    ],
    meiying: [
        "1️⃣————在遥远的夜之森，传说中住着一位名为魅影骑士的吸血蝙蝠。某夜，一支商队途经夜之森，忽然遭遇一群凶猛的狼群袭击。就在商队绝望之际，一道黑影从天而降，化作魅影骑士。它展翅高飞，利用超凡的速度和力量，迅速击退狼群。商队成员目瞪口呆，未及道谢，魅影骑士已消失在夜色中。几天后，商队平安抵达城镇，将这段奇遇广为传颂。人们纷纷传言，魅影骑士不仅是夜之森的守护者，更是所有迷途者的守护神。自此，途经夜之森的旅人们总会在夜晚点燃一盏灯，表达对魅影骑士的敬意和感激。",
        "2️⃣————一座古老的城堡，废弃已久，被认为是魅影骑士的隐居之地。某天，一群盗墓者潜入城堡，妄图盗取传说中的宝藏。正当他们在地下墓室中寻找宝物时，阴冷的空气中传来一阵低沉的声音：“擅闯者，速速离去！”盗墓者不以为然，继续挖掘。忽然，魅影骑士从阴影中现身，双眼闪烁红光，翼展如同黑暗中的利刃。盗墓者惊恐万分，慌乱中四散逃跑，无一人敢再踏入城堡一步。事后，当地居民发现，盗墓者们口中念念有词，皆称见到了魅影骑士的真容。此后，这座城堡被更加严格地保护起来，成为无人敢侵犯的神秘禁地。",
        "3️⃣————某个风雨交加的夜晚，一个小村庄遭受了前所未有的灾难：洪水泛滥，村民们四处逃命。就在水位不断上涨之际，一只巨大的吸血蝙蝠飞临村庄，化作魅影骑士。它用强劲的翅膀创造气流，将村民们一一送到安全的高地。随后，它飞向山谷，利用自身的力量引导洪水改道，保护了村庄免于毁灭。天亮后，雨过天晴，村民们纷纷跪地感恩，传颂魅影骑士的恩德。此后，每逢雨季，村民们总会在村口树立起一尊小小的蝙蝠雕像，祈求魅影骑士的庇佑。这段传闻也让魅影骑士的英勇事迹在更广的范围内流传开来，成为人们心中不朽的传奇。"
    ],
    gangtie: [
        "1️⃣————托尼·斯塔克刚成为钢铁侠不久，便决定测试新设计的装甲Mark III。这一天，他接到一通紧急求助电话：一座高楼起火，顶层有数十名被困居民。托尼立即穿上装甲，飞速赶往现场。他飞到顶层，使用装甲内置的灭火装置控制火势，再逐一把被困者送到地面安全区。就在最后一名被困者获救时，楼顶突然塌陷，托尼被困在燃烧的废墟中。凭借钢铁装甲的强大防护，他成功脱险。事后，托尼感慨：装甲不仅是战斗工具，更是拯救生命的利器。从那天起，他更加坚定了以钢铁侠身份保护无辜的信念。",
        "2️⃣————一次，托尼·斯塔克在公司举办了一场盛大的慈善晚宴，目的是为世界各地的贫困儿童筹集善款。晚宴上，托尼以幽默风趣的演讲赢得了满堂喝彩。然而，晚宴进行到一半时，突然传来一阵爆炸声。恐怖分子闯入会场，意图劫持富豪们索取赎金。托尼迅速反应，启动了隐藏在会场中的微型钢铁装甲。装甲瞬间覆盖全身，他化身钢铁侠，与恐怖分子展开激烈交战。最终，他成功制伏了所有邪佞，确保了会场的安全。晚宴在惊心动魄中继续进行，托尼的英勇表现不仅赢得了现场来宾的赞誉，更激发了他们慷慨解囊，慈善晚宴筹得的善款创下了历史新高。",
        "3️⃣————有一次，托尼·斯塔克决定带彼得·帕克（蜘蛛侠）一起进行一场特别训练。他们飞到一座废弃的工业区，托尼设计了一系列复杂的训练项目，包括高空飞行、精准射击和紧急救援等。训练过程中，彼得在一次高空跳跃中失误，险些摔落。关键时刻，托尼迅速飞过去，将彼得稳稳接住。彼得惊魂未定，托尼却笑着说：“别担心，伙计，失败是成功的必经之路。”这次训练不仅提升了彼得的技能，也让他更加明白团队合作的重要性。托尼在回程时对彼得说：“记住，不管多么强大，我们都需要依靠彼此的支持。”这次经历让两人的师徒情谊更加深厚，也为日后并肩作战打下了坚实的基础。"
    ],
    zhuque: [
        "1️⃣————很久以前，南方有一片炽热的火焰之地，那里栖息着神鸟朱雀。朱雀全身羽毛如火，翅膀展开时，天空仿佛被点燃。某年干旱，百姓苦不堪言，朱雀看到人们的苦难，决定为他们带来雨水。它飞向天际，与雷神搏斗，最终以自身火羽为祭，换来了甘霖。雨水降临，万物复苏，但朱雀因耗尽力量，化为灰烬。然而在灰烬中，一颗炽热的蛋孵化，新的朱雀诞生，继续守护这片土地。人们感激朱雀的牺牲，年年祭祀，以期盼它的再生。",
        "2️⃣————在远古时期，朱雀被任命为南方守护神，与青龙、白虎、玄武共同维护天地秩序。某日，邪神妄图破坏四方平衡，朱雀与其展开激战。邪神幻化成无数恶鸟，意图吞噬朱雀。朱雀展翅高飞，以烈焰形成火环，将恶鸟焚烧殆尽。然而邪神趁机偷袭，朱雀身受重伤。它忍痛飞回南方圣山，吸收日月精华，浴火重生。重生后的朱雀力量倍增，重返战场，与青龙等神兽合力，最终将邪神封印。自此，南方恢复宁静，朱雀继续守护这片土地。",
        "3️⃣————传说在南方灵山之巅，有一座朱雀庙，供奉着朱雀的神像。每年初春，庙会期间，人们聚集在此，祈求平安和丰收。据说，某年一位虔诚的少女在庙前祈祷，希望能治愈母亲的重病。朱雀被她的孝心感动，化作一只普通的红鸟，飞到她家中。红鸟啄破自己的羽毛，滴出一滴滴火红的血液，落入母亲的药汤中。母亲饮下后，病情迅速好转。少女发现红鸟已化为灰烬，她将灰烬埋在庙前，翌年春天，朱雀庙前开满了火红的花朵，象征着朱雀的再生与祝福。"
    ],
    bige: [
        "1️⃣————比格在一个寂静的夜晚悄悄离开了泰拳道馆。他穿过曼谷的街道，经过熙熙攘攘的市场和霓虹闪烁的酒吧，最终来到了一个小巷，这里是他儿时最喜欢的地方。这条巷子里有一家小店，店主是个和蔼的老太太，总是给他免费花生吃。比格推开门，鼻尖立即闻到了熟悉的花生香气，仿佛回到了无忧无虑的童年。老太太微笑着递过一包花生：“我知道你会来。”比格接过花生，眼中闪过一丝温柔。她的儿子曾是他在擂台上唯一的朋友，但在一次比赛中不幸身亡。每当比格感到困惑或疲惫时，都会来到这里，怀念那段纯粹的友情。老太太轻轻拍了拍他的手：“你是个好孩子，他在天上一定为你骄傲。”比格点了点头，心中那块柔软的地方再次被触动。离开时，他在巷口停下，回头望了一眼那温暖的小店，暗暗发誓要守护这片宁静。",
        "2️⃣————某个午夜，比格独自站在一个废弃的工厂前，黑暗中只有他眼中的寒光。这里是一个恶名昭著的犯罪集团的老巢，比格早就调查清楚，这群人贩毒、走私，甚至绑架小孩。今天，他要为那些无辜的受害者讨回公道。他轻声踏进工厂，像幽灵般在黑暗中移动。一个接一个的歹徒被他精准无情的拳头击倒，每一拳都蕴含着他对邪恶的愤怒。工厂深处，传来孩子们微弱的哭声，比格加快了脚步。最终，他站在首领面前，冷冷地说：“这就是为那些孩子们讨回的公道。”首领惊恐地看着比格，颤抖地举起双手投降。比格把他拷起来，交给了赶来的警察。看着孩子们被安全救出，比格心中感到一丝安慰，但他知道，这场战斗只是个开始。离开工厂时，他回头望了一眼，心中默默发誓，要继续战斗，直到最后一丝邪恶彻底消失。",
        "3️⃣————比格的名字在江湖上已经成为传奇，但他心中一直有一个未解的谜团。他的父亲，一个同样出色的拳手，在比格年幼时神秘失踪。比格总是怀疑父亲被某个强敌所害。一天，他收到一封神秘的信，信中透露了父亲当年失踪的线索。比格决定追寻真相。他一路追查，跨越了多个国家，终于来到了一个隐秘的山谷。山谷中的空气中弥漫着一股压抑的气息。在这里，他发现了一个地下拳场，父亲竟然被迫成为了这里的拳奴。比格的心一阵绞痛，他看到父亲满身伤痕地倒在擂台上。血液瞬间涌上头顶，不顾一切的他冲上擂台，与拳场的主人展开了一场生死搏斗。每一拳都充满了对父亲的思念和愤怒。最终，他用无懈可击的拳技打败了拳场的主人，救出了父亲。比格抱着虚弱的父亲，泪水模糊了他的眼睛，解开了多年的心结。父亲虚弱地对他说：“儿子，你长大了。”比格点点头，终于感到那颗漂泊已久的心找到了归宿。"
    ],
    yanzhi: [
        "1️⃣————我叫胭脂，是被仙境之主选中的使者，肩负着寻找仙境之子的重任。仙境即将迎来16周年庆典，作为仙境的一部分，我从小便沐浴在仙气之中，学习各种仙术。为了完成这项任务，我必须离开熟悉的仙境，踏入人间。第一次踏上这片陌生的土地，我感受到人间的繁华与喧嚣，与仙境的宁静截然不同。按照仙境之主的指引，我需要找到那个具有仙境血脉的孩子，他将成为下一任仙境之主。我穿越山川河流，走过一个个村庄，时刻保持警惕，感受着空气中微弱的仙气。每一个黄昏，我都会找一个安静的地方，盘膝而坐，感受着来自远方的呼唤，希望能尽早找到他。",
        "2️⃣————在一个宁静的小村庄，我感受到了一股强烈的仙气。这是我在凡间感受到最接近仙境的气息，我知道，我离目标已经很近了。村庄里的人们对我充满了好奇和善意，他们从未见过如此装束的人。我隐瞒了自己的身份，只说自己是个旅人。一天傍晚，我遇到了一位老人，他似乎知道我的来历和目的。他告诉我，村里有一个孩子，自小便与众不同，天生灵气逼人。这个孩子叫斑鸠，正是我苦苦寻找的仙境之子。我心中一阵狂喜，但也明白任务才刚刚开始。我要保护斑鸠，并教导他仙术，让他在16周年庆典上顺利接管仙人之位。",
        "3️⃣————时间一天天过去，我与斑鸠在村庄里度过了许多美好的时光。我教他如何运用仙术，告诉他关于仙境的一切。斑鸠聪慧异常，很快掌握了基础的仙术。然而，我们的行动并不总是一帆风顺。人间的阴险与险恶远超我的预料，我们曾遭遇过邪恶势力的袭击，也曾被怀疑和排斥。但每一次困难都让我和斑鸠更加坚定。终于，在仙境16周年庆典的前夕，斑鸠已经成长为一个强大的仙术师。我们踏上了返回仙境的道路，迎接那一刻的到来。在庆典之夜，斑鸠顺利接管了仙人之位，而我也完成了自己的使命。看着他站在仙境之主的位置上，我感到无比的骄傲和欣慰。我的任务结束了，但我的故事仍在继续，我会继续守护这片仙境，等待新的挑战和冒险。"
    ],
    zhulin: [
        "1️⃣————我叫蓝猫，是竹林中的隐士，以雷电之术闻名于世。很多人都说我性格豪爽，其实我只是不喜欢拐弯抹角，遇到事情总是直来直去。那一天，我正在竹林中修炼，忽然听到远处传来一阵喧闹声。循声望去，我看到一群山贼正在欺负一对父女。那女孩年纪轻轻，眼中却充满了无畏和愤怒，这让我心生敬意。豪爽之人岂能坐视不理？我飞身上前，手中雷电翻滚，只见雷光一闪，那群山贼已被击退。父女俩对我千恩万谢，我却只是挥了挥手，告诉他们：“走吧，这世道还是得靠自己保护自己。”",
        "2️⃣————有一天，我收到一封信，是我多年未见的好友传来的。信中说，他所在的村子遭受了一伙邪恶修士的侵袭，急需援助。我二话不说，带上我的雷电之术，奔赴好友的村庄。到了那里，我发现情况比想象的更糟糕，那些邪恶修士使用黑魔法，村民们苦不堪言。我与好友并肩作战，毫不畏惧地冲进敌阵。我的雷电之术在战斗中大放异彩，一道道闪电劈向邪佞，邪恶修士们一个个被击退。最终，我们成功击败了这些邪恶势力，村庄恢复了平静。好友握着我的手，感激地说：“蓝猫，你真是我一生的兄弟。”我拍了拍他的肩膀，豪爽地笑道：“兄弟有难，岂能不帮？这就是忠义！”",
        "3️⃣————经历了无数次的战斗和冒险，我决定返回那片让我心安的竹林。竹林中宁静祥和，我喜欢在这里与自然为伴，修炼我的雷电之术。一天傍晚，我在竹林深处发现一个受伤的少年，他看起来很虚弱，但眼神中透着坚毅。我把他带回我的隐居之所，细心为他疗伤。少年醒来后告诉我，他叫小雷，正是因为仰慕我的雷电之术，才来竹林中寻找我。我见他心诚，决定收他为徒，传授他雷电之术。小雷的进步很快，他的豪爽性格也让我想起了年轻时的自己。我们师徒二人一起修炼，一起战斗，共同守护这片竹林。我的故事还在继续，而我的忠义和豪爽，也将在小雷身上传承下去。"
    ],
    zhanshen: [
        "1️⃣——我总是想得太多。你们看到的是我一刀劈开山河，一脚踏碎虚空，但你们看不到的是我的思索。什么是力量的本质？那是对生命的敬畏和对死亡的理解。我燃烧着，不只是因为战斗，而是因为心中的火焰。我站在这座古老的神殿前，思索着宇宙的起源和人类的终极命运。每次挥剑，我都在问自己：生命的意义是什么？或许在红莲业火的光芒中，我找到了答案，那就是在战斗中找到自我，在毁灭中追寻重生。每一个邪佞，每一个挑战，都是我对世界发出的质问，而我的刀刃，就是答案。",
        "2️⃣——大家都说我是战神阿毛，凶猛无比，无人能敌。但你们知道我另一个身份吗？我是一个推拿师。我不只是在战斗中用武功征服对手，我还在平凡的日常中用推拿征服人心。我喜欢推拿，不是因为它能缓解疲劳，而是因为它让我感受到人类的脆弱和美丽。我看到那些筋骨僵硬的平民，我知道，他们和我一样，都在与生活搏斗。我用我的手法，让他们暂时忘却痛苦，找到片刻的宁静。这让我明白，力量不仅仅是摧毁和征服，还有抚慰和治愈。我，战神阿毛，不只是一个冷酷的战士，还是一个温柔的推拿师，用我的双手，为这个世界带来一丝丝温暖。",
        "3️⃣——有些人说我是命运的宠儿，有些人说我是厄运的化身。但你们知道吗，命运对我来说，不过是一个笑话。我是阿毛，一个在战斗中觉醒的战神，但我不相信命运。我相信的是选择。每一次挥剑，每一次战斗，都是我对命运的反抗。我走过无数的战场，见过无数的生死离别，但我从不屈服于命运的安排。我用红莲业火焚烧一切不公，用幽冥剧毒惩罚一切邪恶。我选择了这条路，就不会后悔。我站在这座古老的神殿前，看着那扇神秘的大门，心中有无限的思索。我知道，命运的轮回或许无法打破，但我可以选择如何面对它。我，战神阿毛，不是命运的傀儡，而是命运的挑战者。在无尽的轮回中，我将继续前行，用我的选择，谱写属于自己的传奇。"
    ],
    jinmin: [
        "1️⃣——结城夏奈是在一次工作中与金珉奎相遇的，那时她是《Fantasy!》杂志的主编，而他是炙手可热的K-pop明星。初次见面，两人并未擦出火花，但命运却将他们再次连接在一起。几个月后，夏奈在韩国的一次时尚发布会上再次遇见了金珉奎。这次，他不再是那个高高在上的明星，而是一个在后台默默帮助工作人员的普通人。两人因为共同的朋友被安排坐在一起，逐渐有了更多的交流。夏奈被金珉奎的谦逊和幽默所吸引，而金珉奎则被夏奈的智慧和独立所打动。发布会结束后，他们开始频繁联系，并在首尔的街头度过了许多美好时光。一次，夏奈在采访中遇到了难题，金珉奎不顾一切赶来帮她化解了困境。这让夏奈深深感受到他对她的在意和支持。两人在繁忙的工作之余，彼此成了最可靠的依靠，渐渐走进了对方的心里。",
        "2️⃣——夏奈和金珉奎的关系逐渐升温，但一场突如其来的意外打破了他们的平静生活。在一次拍摄现场，夏奈不慎被道具砸中头部，失去了部分记忆。她忘记了与金珉奎的点点滴滴，只记得一些模糊的片段。金珉奎心痛不已，但决定不放弃，他每天陪在夏奈身边，试图唤起她的记忆。夏奈对这个温柔体贴的男人感到熟悉，却又无法完全想起他们之间的过去。金珉奎带她去他们曾经约会的地方，重温那些美好时光。某天，夏奈在整理旧物时，发现了一本她亲手制作的相册，里面记录了她和金珉奎的点点滴滴。那些照片和文字让她的记忆慢慢复苏，渐渐想起了他们之间的点点滴滴。看着金珉奎的笑脸，她的心里涌起一股暖流。虽然记忆尚未完全恢复，但她已经感受到他们之间深厚的感情。两人决定重新开始，无论未来有多少挑战，他们都将一起面对。",
        "3️⃣——爱情在不断升温，但他们也面临着现实的考验。夏奈的工作需要她频繁往返于日本和韩国，而金珉奎的演艺事业则让他常年奔波在外。两人的见面机会越来越少，但他们并没有因此放弃这段感情。每次分别时，他们都会约定下次见面的时间和地点，尽可能地保持联系。某次，夏奈在东京采访时，继父突然出现，试图再次控制她的生活。金珉奎得知消息后，立刻飞往东京，帮助夏奈应对继父的威胁。他们一起面对了继父的阴谋，最终成功让他受到法律的制裁。这场危机让两人更加坚定了彼此的信任和依赖。夏奈决定辞去高强度的工作，转而从事更灵活的自由职业，以便能有更多时间陪伴金珉奎。金珉奎也调整了自己的工作计划，尽量减少不必要的出差。他们一起在韩国买了一套温馨的小公寓，开始了新的生活。虽然两人依然忙碌，但他们的心却紧紧连在一起。每次见面都像是一场久别重逢的约会，他们用心经营着这段跨越距离的爱情。"
    ],
    liguo: [
        "1️⃣————李国麟第一次在商法课上看到夏奈时，阳光正好从教室的窗户斜射进来，为她镀上了一层金色的光晕。她专注地翻阅着厚重的法律书籍，纤细的手指在书页间轻轻滑动。李国麟感觉自己的心跳突然加速，喉咙发干。他从未见过如此美丽而自信的女孩。整堂课，他的目光都不自觉地追随着她的一举一动。下课铃响起，夏奈优雅地收拾书包，长发在转身时画出一道完美的弧线。李国麟呆呆地看着她离去的背影，突然意识到自己可能坠入了爱河。从那天起，他开始认真学习商法，尽管对于一个篮球运动员来说，这是一个巨大的挑战。他常常熬夜到深夜，困惑地盯着晦涩难懂的法律术语，只为了能在课堂上有机会接近夏奈，哪怕只是坐在她附近，或者有幸成为她的讨论搭档。",
        "2️⃣————篮球赛的决胜时刻，李国麟站在三分线外，汗水顺着他棱角分明的脸庞滑落。比分咬得很紧，只剩下最后三秒。观众席上的喧嚣仿佛被按下了静音键，他的世界只剩下手中的篮球和远处的篮筐。深吸一口气，他纵身跃起，球从指尖飞出。时间仿佛静止，所有人的目光都追随着那个橙色的小球。'唰'的一声，球穿过网窝，全场爆发出震耳欲聋的欢呼。李国麟被队友们高高抛起，在喜悦中，他的目光却不自觉地搜寻着观众席。突然，他看到了她——夏奈正站在那里，美丽的眼睛闪烁着兴奋的光芒，为他的精彩表现鼓掌喝彩。那一刻，李国麟感觉自己的心跳比赛前还要快。赛后，当他走向更衣室时，夏奈叫住了他。'李国麟，你真是太棒了！'她真诚地说。李国麟憨厚地笑了，脸颊微微发红，不仅是因为比赛的热度，更是因为夏奈的夸奖。",
        "3️⃣————夏日的夜晚，星光点缀着天空。李国麟和夏奈坐在校园的长椅上，周围是沙沙作响的树叶和若隐若现的萤火虫。李国麟深情告白后，夏奈回应了他的爱意。那一刻，压抑已久的激情如火山般爆发。李国麟将夏奈拥入怀中，热烈地吻上她的唇。夏奈热情回应，双手在李国麟结实的背肌上游走。李国麟的大手探入夏奈的衣襟，抚摸她光滑的肌肤，引得她一阵颤栗。两人的呼吸越发急促，身体紧贴在一起。李国麟健壮的身躯压向夏奈，她能感受到他强烈的欲望。夏奈轻咬李国麟的耳垂，低语道：'去你的宿舍...'。他们跌跌撞撞地回到李国麟的单人宿舍，迫不及待地褪去彼此的衣物。月光下，夏奈婀娜的身躯如玉般洁白。李国麟吻遍她每一寸肌肤，舌尖挑逗着她敏感的部位。夏奈情不自禁地呻吟，双手抚摸着李国麟结实的胸肌和腹肌。李国麟炽热的欲望抵在她的大腿内侧，夏奈主动张开双腿迎接他。当两人终于结合的那一刻，他们同时发出满足的叹息。李国麟强壮的腰身有力地律动，夏奈的指甲在他的背上留下道道红痕。房间里回荡着激情的喘息和肉体的撞击声。高潮来临时，夏奈紧紧抱住李国麟，咬住他的肩膀来抑制自己的尖叫。李国麟也到达顶点，在她体内释放。事后，他们相拥而卧，李国麟轻抚着夏奈汗湿的秀发，柔声说：'夏奈，我爱你，不仅仅是你的身体，更是你的灵魂。'夏奈依偎在他怀里，幸福地回应：'我也爱你，李国麟。你让我感受到了前所未有的快乐和满足。'",
        "4️⃣————微距纪实：他们跌跌撞撞地回到李国麟的单人宿舍，一路上难舍难分，时不时停下来热吻。关上门的瞬间，两人迫不及待地褪去彼此的衣物。月光透过窗帘的缝隙洒落，为夏奈婀娜的身躯镀上一层银辉。李国麟痴迷地看着眼前的完美胴体，双手抚过她的每一寸肌肤，仿佛在膜拜一件艺术品。他的唇舌从她的脖颈一路向下，轻咬她的锁骨，在她胸前流连。夏奈情不自禁地呻吟，双手抚摸着李国麟宽阔的肩膀，感受着他结实的胸肌和腹肌。李国麟将夏奈轻轻推倒在床上，俯身压上。他的吻如雨点般落在她的全身，舌尖挑逗着她每一个敏感点。夏奈的身体在他的爱抚下变得滚烫，她能感觉到自己已经准备好迎接他。李国麟炽热的欲望抵在她的大腿内侧，夏奈主动张开双腿，用湿润的私密部位摩擦着他，邀请他的进入。当两人终于结合的那一刻，他们同时发出满足的叹息。李国麟强壮的腰身开始有力地律动，每一次深入都让夏奈感到无比的欢愉。她的双腿缠绕在他的腰间，随着他的节奏摆动。房间里回荡着激情的喘息、肉体的撞击声和床铺的吱呀声。夏奈的指甲在李国麟的背上留下道道红痕，刺痛感更加刺激了他的欲望。李国麟抱起夏奈，让她跨坐在自己身上。这个姿势让他进入得更深，夏奈忍不住仰头呻吟。她摆动着纤细的腰肢，李国麟的手扶着她的臀部，配合她的节奏。两人的汗水交融，在月光下闪烁着珍珠般的光泽。高潮来临时，夏奈紧紧抱住李国麟，咬住他的肩膀来抑制自己的尖叫。她的身体如触电般颤抖，内壁剧烈收缩。李国麟也到达顶点，在她体内释放，同时发出低沉的吼声。事后，他们相拥而卧，李国麟轻抚着夏奈汗湿的秀发，柔声说：'夏奈，我爱你，不仅仅是你的身体，更是你的灵魂。你是我生命中最美好的存在。'夏奈依偎在他怀里，幸福地回应：'我也爱你，李国麟。你让我感受到了前所未有的快乐和满足。我们会永远在一起，对吗？'李国麟吻了吻她的额头，坚定地说：'永远。'"
    ],
    tengshe: [
        "1️⃣——在古老的神话中，腾蛇是一种传说中的神兽，拥有星宿之力，被誉为守护神兽之一。它的外形如同巨蛇，身披火焰与毒雾，红莲业火与幽冥剧毒是它的两大绝技。腾蛇原本栖息在幽深的山谷中，远离尘世，但一场突如其来的变故改变了它的命运。某日，腾蛇感应到王朝边疆的动荡与战火，百姓生活在水深火热之中，苦不堪言。腾蛇决定不再隐居，决定用自己的力量推翻腐朽的王朝，解救苍生。腾蛇飞身而起，穿越山川湖泊，来到了王朝的都城。它的出现如同一场风暴，红莲业火焚烧着邪佞的军营，幽冥剧毒让邪佞闻风丧胆。腾蛇在战场上无往不利，所到之处，敌军溃不成军，百姓们看到了希望。",
        "2️⃣——腾蛇不仅是一位战士，更是一位救世主。它推翻了腐朽的王朝之后，并没有追求权力和财富，而是开始帮助百姓重建家园。腾蛇利用自己的神力，灌溉田地，清除瘟疫，使得百姓们能够安居乐业。它的红莲业火不再只是用来焚烧邪佞，而是用来温暖寒冷的冬夜；幽冥剧毒也不再只是用来杀敌，而是用来制药救人。一天，一场前所未有的瘟疫袭击了整个王国，百姓们再一次陷入了恐慌之中。腾蛇不辞辛劳，昼夜不休地研制解药。它用自己的毒液作为药引，最终成功地研制出了解药，挽救了无数人的生命。百姓们感激涕零，将腾蛇视为神明般崇拜，并在都城为它建造了庙宇，以示敬仰。",
        "3️⃣——尽管腾蛇拯救了无数人，但它始终保持着低调，从不炫耀自己的功绩。在确定百姓们的生活恢复安定之后，腾蛇决定归隐山林。它飞回了自己曾经栖息的山谷，继续过着隐居的生活。然而，它的传奇故事在百姓中口口相传，成为了不朽的神话。每年春天，百姓们都会来到腾蛇的庙宇，举行盛大的祭祀仪式，纪念这位伟大的神兽。他们相信，腾蛇的精神永远守护着他们，使得王国永远繁荣昌盛。腾蛇的故事激励着一代又一代的人，告诉他们只要心怀正义，勇敢无畏，就能够战胜一切困难，创造奇迹。腾蛇虽然归隐，但它的名字将永远铭刻在历史的长河中，成为人们心中不灭的传奇。"
    ],
    qingmou: [
        "1️⃣————我是虎子，江湖人称青眸白虎。自幼便与电火为伴，练就了烈光之术。我的技艺无人能及，行动如风，变幻莫测。这一天，我隐居在山中的修行被一阵喧嚣打断。我跃上树梢，看到山脚下一个村庄正遭受袭击。那些山贼猖獗无比，村民们无力反抗。我冷哼一声，雷电之力在掌中凝聚，一声怒吼，电火如龙般冲向山贼，瞬间将他们烧得落荒而逃。村民们看向我的目光充满敬畏，而我只是轻轻一跃，消失在茫茫竹林中。",
        "2️⃣————江湖传言青眸白虎无影无踪，行踪飘忽。这次，我接受了一项极为隐秘的任务——潜入敌国，摧毁他们正在开发的秘密武器。夜色如墨，我化身黑影，悄然潜入敌国要塞。要塞守卫森严，但我如鬼魅般穿梭其间，烈光之术使我的身形更加迅捷。终于，我找到了那座秘密工厂，内部机关重重。我手中雷电之力暴涨，将所有阻拦我的邪佞化为灰烬。火光映照下，我看到那武器已被摧毁，而我也在夜色掩护下，迅速离开，留下一片狼藉的战场。",
        "3️⃣————我一直以为自己是孤独的战士，直到那天遇到了一个叫小虎的少年。他在一次战斗中目睹了我的烈光之术，便执意要拜我为师。我见他天资聪颖，便决定传授他我的技艺。我们在深山中隐居，白日里他勤学苦练，夜晚则跟随我行走江湖。一次，我们遇到了一伙邪教徒，他们妄图统治江湖。我和小虎并肩作战，烈光之术在黑夜中闪耀，我们的合作天衣无缝。最终，邪教徒被我们彻底击败。看着小虎从一个稚嫩的少年成长为独当一面的侠客，我感到无比自豪。烈光之术在他手中愈发强大，而我，也终于找到了一生的传承。"
    ],
    jingjue: [
        "1️⃣————我的故事始于战火纷飞的年代，那时的我，胸怀大志，立誓要结束乱世，重建和平。我从小就展现出非凡的武艺，力拔山兮气盖世。很快，我便在众多将士中崭露头角，成为了众人敬仰的英雄。随着战争的不断推进，我的声名远播，所向披靡，邪佞闻风丧胆。然而，越是接近胜利，我心中那份不安却越发强烈。江山虽近，但我却总感觉命运在我身后静静注视，等待着最后的审判。",
        "2️⃣————战争如火如荼，最终迎来了决定性的一战。我率领军队与敌军决战于乌江，敌我双方都已筋疲力尽，胜负只在一线之间。就在此时，传来了爱姬虞姬被困的消息。我心如刀割，但战场上无暇顾及，唯有将胜负寄托于一场豪赌。激战正酣，敌军援兵赶到，我军节节败退。我挥舞着巨大的战刀，试图挽回败局，但终究力不从心。爱姬虞姬见状，毅然决然地以剑自刎，她的鲜血洒满战场，仿佛在诉说我们未尽的情缘。那一刻，我的心彻底碎了，英雄的梦也随之破灭。",
        "3️⃣————大势已去，军队溃散，乌江的流水似在为我哀鸣。身边仅剩数十骑忠勇之士，我却明白已无力回天。面对无尽的敌军，我毅然决定结束这场悲剧。拔出佩剑，我站在乌江边，望着那滚滚江水，回忆起往昔的荣光与爱姬的笑颜。战士们劝我渡江逃生，但我岂能苟且偷生，留下千古骂名？“力拔山兮气盖世，时不利兮骓不逝。骓不逝兮可奈何？虞兮虞兮奈若何！”一声长叹，我纵身跃入江中，结束了自己悲壮的一生。江水吞噬了我的身体，却无法淹没我的传说。净角神将，虽败犹荣，化作江上一抹不灭的英雄魂魄。"
    ],
    shanggu: [
        "1️⃣————曾经，亿万年前大地神树的一根枝蔓，满载着神力降临人间，我便是那上古的神藤。那时的大地，还是一片原始的净土，生机盎然。作为大地神树的一部分，我见证了万物的诞生与成长，感受着生命的脉动和自然的和谐。我们的神树根系深深扎入大地，与大地融为一体，吸收着宇宙的精华。每当晨曦初现，我会感受到第一缕阳光的温暖；每当夜幕降临，我会聆听星辰的低语。我的存在，承载着大地的祝福与希望。然而，随着时间的流逝，我也开始目睹生灵的苦难和悲欢离合，这让我心生悲悯，决心用我的神力庇护众生。",
        "2️⃣————时光荏苒，宇宙间沧海桑田，大地不断变迁。曾经的净土变得繁华，而繁华之后又归于寂静。无数次的轮回，我依然屹立不倒，静静守护着这片大地。某一天，人类文明兴起，他们建造了高楼大厦，开垦了田野，但也带来了战争和破坏。我亲眼目睹了无数生灵的离散与凋零，内心无比痛苦。我用神力修复着大地的创伤，用藤蔓庇护着无助的生命。我曾将一个受伤的孩子紧紧拥入怀中，用我的藤蔓疗愈他的伤痛。孩子露出了纯真的笑容，那一刻，我感受到自己存在的意义。然而，这种短暂的宁静很快被新的战争打破，悲剧一次次上演，我的悲悯之心也愈发深沉。",
        "3️⃣————亿万年的岁月过去，我的藤蔓早已成为大地的一部分，与这片土地密不可分。我见证了文明的兴衰，感受着自然的无常，但我的心依然充满了对生命的热爱和对和平的渴望。即使在最黑暗的时刻，我也未曾放弃希望。每当春天来临，我的枝蔓会绽放出美丽的花朵，为大地带来生机。无数次的轮回中，我学会了与时间共舞，学会了在悲痛中寻找美好。我知道，自己的使命永远不会结束，因为只要这片大地还在，只要还有生灵需要庇护，我就会一直守护下去。即使宇宙再度轮回，我的悲悯之心也将永远不变，成为大地上最温柔、最坚定的守护者。"
    ],
    guhe: [
        "1️⃣————我是古河锦鲤，三途川的引导者，负责带领不安的亡魂找到安息之地。每天，我在这幽深的河流中游弋，用催眠的力量平息亡魂的痛苦。见证了无数次的生死离别，我的心渐渐麻木，仿佛一切都变得无关紧要。亡魂们的哭泣与哀号，在我的耳中如同风过耳畔，来去无痕。我只机械地履行着我的职责，仿佛一具没有情感的傀儡。曾几何时，我也是如此充满激情，但如今的我，只剩下冰冷的职责。",
        "2️⃣————某天，我遇到了一个特别的亡魂，她是一个年轻的女子，生前为了救她的孩子而不幸身亡。她的魂魄充满了不舍和牵挂。我的催眠术竟然对她无效，她的真情打破了我的防线。女子恳求我，让她再见孩子一面，我被她的真情所感动，破例帮助她完成了这个心愿。她与孩子的重逢充满了泪水与温情，这一幕深深触动了我的心。渐渐地，我感觉到心中那份久违的温暖与柔情。",
        "3️⃣————自从那次帮助亡魂重逢后，我开始重新审视自己的职责。虽然我依旧是三途川的引导者，但每一次的引导，我都会用心去聆听亡魂们的故事。人间的真情再次唤醒了我的感受，让我不再只是冷漠的引导者。我明白，正是这些真挚的情感，才使得生死轮回不再那么冰冷。我决定，用我的力量不仅仅是引导，更要安抚这些亡魂，让他们在离开人间前，感受到最后一丝温暖与关怀。我的使命不再只是引导，而是带来希望与安慰。"
    ],
    banlan: [
        "1️⃣————斑斓公主，人们亲切地称她为虎妞，是苏州村民抚养长大的神虎化身。她天生具有破军神力，但因不懂得控制，经常好心办坏事。一次洪水突袭村庄，虎妞想用力量筑坝，但用力过猛，反而加剧了灾难。村民们虽没有责怪她，但她心中满是愧疚。这次经历让她明白，光有力量是不够的，还需要智慧和技巧。于是，她开始学习如何更好地控制自己的神力，立志为村民们做真正有益的事情。",
        "2️⃣————在村中一位智者的指导下，虎妞开始了她的学习之旅。智者教导她如何精确控制力量，如何在关键时刻保持冷静。一天，村庄受到一群强盗的袭击，村民们惶恐不安。虎妞不再像以前那样只靠蛮力冲锋，而是冷静地分析敌情，利用学到的技巧巧妙制服了强盗。村民们见她如此英勇又智慧，纷纷为她喝彩。这次胜利让虎妞意识到，真正的英雄不仅需要强大的力量，还需要冷静的头脑和对力量的掌控。",
        "3️⃣————村外山中出现了一只巨大的恶兽，威胁着村民们的安全。虎妞决心前往应战。经过长时间的修炼和实践，她已经能够自如地控制破军神力。面对恶兽，她设下巧妙的陷阱，将恶兽引入陷阱之中，然后用精准的力量将其制服。村民们为她欢呼，称赞她不仅有强大的力量，还有保护他们的智慧和勇气。从那天起，虎妞不再是那个好心办坏事的斑斓公主，而是村民们心目中真正的守护者，真正的英雄。她用自己的行动，赢得了所有人的信任和尊敬。"
    ],
    juling: [
        "1️⃣————巨灵战姬，自幼便展现出非凡的战斗天赋。但她内心深处总有一种孤独感，仿佛缺失了什么。一天，她在古老的森林中迷失，偶然遇到了一位沉睡的巨灵神。巨灵神从沉睡中苏醒，目光中充满了温柔与力量。巨灵战姬感受到一股前所未有的亲切感，仿佛找到了命中注定的伙伴。巨灵神低声说道：“你就是我等待的战士，我们的命运已然交织。”就这样，巨灵战姬与巨灵神缔结了生命之契，从此她不再孤单，拥有了无尽的勇气与力量。",
        "2️⃣————缔结契约后，巨灵战姬与巨灵神开始了他们的冒险旅程。某日，邪恶势力袭击了一个小村庄，巨灵战姬毫不犹豫地站了出来，迎战强敌。巨灵神在她身后漂浮，为她提供无尽的力量和护盾。面对妖邪的攻击，她毫不退缩，勇敢地保护着村民们。巨灵神的力量与她完美结合，形成一道坚不可摧的屏障。最终，邪恶势力被击败，村民们得救了。巨灵战姬深知，这是她与巨灵神的默契与信任，让她能够无畏地面对一切挑战。",
        "3️⃣————随着时间的推移，巨灵战姬和巨灵神的默契愈发深厚。一次，她们面对一个强大的古老恶灵，恶灵的力量足以摧毁一切。巨灵战姬深知此战凶险，但她坚定地站在最前线。巨灵神在她身后闪耀着光芒，给予她无尽的勇气。两人联手，经过一场惊心动魄的激战，终于将恶灵封印。战斗结束后，巨灵战姬看着巨灵神，感受到契约的力量愈加深厚。她明白，无论未来多么险恶，她们的契约将永远不朽，巨灵神将一直陪伴在她身边，守护她，也守护着她所爱的一切。"
    ],
    aoshi: [
        "1️⃣————敖十七是龙王的第十七个孩子，虽年纪尚小，但心中充满了对外界的好奇。一天，他决定离开龙宫，开始他的第一次冒险。敖十七飞越山川湖海，来到了一片美丽的森林。在那里，他遇到了一群被困的精灵，受到恶龙的威胁。敖十七毫不犹豫地出手相助，他用龙息驱散了恶龙，救出了精灵。精灵们感激不尽，为他献上了魔法之花。这次冒险让敖十七明白了勇气与善良的意义，也让他在精灵们的心中留下了深刻的印象。",
        "2️⃣————在一次旅行中，敖十七来到了一个古老的城镇。镇上的人们正在为解决一道古老的谜题而烦恼，这道谜题已经困扰了他们几代人。敖十七听闻后，决定一试。他静心观察，运用自己在龙宫学到的智慧，最终成功解开了谜题。镇民们无比惊喜，为他举行了盛大的庆典。敖十七不仅得到了丰厚的奖励，更赢得了人们的敬佩。这次经历让他明白，智慧同样是一种强大的力量。",
        "3️⃣————在一片浩瀚的沙漠，敖十七听闻有一座被诅咒的城市。许多勇者前去探险，却无一生还。敖十七决定前去一探究竟。经过长途跋涉，他终于找到这座城市，并发现了隐藏在其中的黑暗力量。敖十七用龙鳞反射出耀眼的光芒，驱散了黑暗，解除了诅咒。被拯救的城市恢复了生机，居民们为他树立了纪念碑，称他为“勇者之龙”。敖十七的名声传遍了四方，他的勇气与智慧也在每一段旅程中不断增长。通过这些经历，他渐渐成长为一位真正的龙族英雄。"
    ],
    daming: [
        "1️⃣————妲茗儿因在天宫捣药出错，被嫦娥仙子罚下凡间修行。她精通医术，尤其擅长解毒疗伤。一天，她在林中采药时遇到了受伤的侠客皇甫云。妲茗儿悉心照料，利用自己的医术为他解毒疗伤。皇甫云感激不已，两人因此结下深厚友谊。妲茗儿仰慕侠之大者，决定跟随皇甫云，贴心辅佐他行侠仗义。两人行走江湖，妲茗儿不仅治愈了许多受伤的百姓，还在关键时刻帮助皇甫云化险为夷。她逐渐成为皇甫云不可或缺的伙伴。",
        "2️⃣————皇甫云接到朝廷委托，要摧毁一个盘踞在深山中的凶兽群。妲茗儿与他一同前往。途中，他们遭遇了凶兽头领设下的埋伏，皇甫云身中剧毒，命悬一线。妲茗儿毫不犹豫地用自己体内的仙灵之气为他解毒，但这种解毒方法会让她自身的修为大减，甚至有生命危险。她毅然决然地为皇甫云疗伤，最终皇甫云苏醒过来，而妲茗儿却因耗尽仙灵之气陷入昏迷。皇甫云看着昏迷不醒的妲茗儿，心中感激涌动，发誓要保护她一生一世。",
        "3️⃣————妲茗儿的善行最终传到了嫦娥仙子的耳中，嫦娥被她的诚心所感动，决定原谅她，召她回天宫。然而，妲茗儿却已心有所属。她对嫦娥仙子表达了自己对皇甫云的敬仰与爱慕，决心留在凡间，继续与皇甫云并肩行侠仗义。嫦娥仙子理解她的选择，祝福她在人间找到真正的幸福。妲茗儿与皇甫云继续他们的江湖之旅，救助弱小，惩恶扬善，成为了江湖中人人敬仰的一对侠侣。妲茗儿用自己的行动证明了，即使身处凡间，也能实现心中的梦想与使命。"
    ]
};
        
function validateUnlockCode() {
    const code = document.getElementById('unlockCode').value;
    
    const hashedCode = CryptoJS.MD5(code).toString();

    if (hashedCode === correctHashedCode) {
        document.getElementById('unlockOverlay').style.display = 'none';
        alreadyUnlocked = true;
        console.log('解锁成功！');
    } else {
        document.getElementById('errorMessage').style.display = 'block';
    }
}
let wakeLock = null;

async function requestWakeLock() {
  try {
    wakeLock = await navigator.wakeLock.request('screen');
    wakeLock.addEventListener('release', () => {
      console.log('Screen Wake Lock released');
    });
    console.log('Screen Wake Lock acquired');
  } catch (err) {
    console.error(`${err.name}, ${err.message}`);
  }
}

requestWakeLock();

function openDivineShuixian() {
    const iframeContainer = document.getElementById('iframeContainer');
    const iframe = document.getElementById('iframe');
    
    if (iframeContainer.style.display === "block") {
        iframe.src = "shuixian.html";
        iframeContainer.style.display = "none";
    } else {
        iframe.src = "shuixian.html";
        iframeContainer.style.display = "block";
        showInfoBox("\n1.此界面只用于模拟《天书奇谈》中通灵系统，通灵结果仅供娱乐，不参与属性计算 \n2.通灵系统对金钱消耗巨大，酌情试玩 \n3. 每次关闭此界面会清空尚未兑换的资产，请及时处置")
    }
}

function openDivineZiwei() {
    const iframeContainer = document.getElementById('iframeContainer');
    const iframe = document.getElementById('iframe');

    iframe.src = "ziweimoniq.html";
    iframeContainer.style.display = "block";
}

function divinePage() {
    openDivineShuixian();
}
        
function handleDeductGold(amount, successMessage, successValue, failureMessage, event) {
    if (goldAmount >= amount) {
        goldAmount -= amount;
        updateGoldDisplay(goldAmount);
        showInfoBox(successMessage);
        event.source.postMessage({ type: `success(${successValue})` }, event.origin);
    } else {
        showInfoBox(failureMessage);
        event.source.postMessage({ type: 'failure' }, event.origin);
    }
}

function handleExchangeGold(amount, event) {
    const shouxufei = Math.round(amount * 0.12);
    goldAmount += (amount - shouxufei);
    updateGoldDisplay(goldAmount);
    showInfoBox(`你成功兑换了${convertPrice(amount - shouxufei)}金子！（已扣除手续费${convertPrice(shouxufei)}）`);
}

function closeDivineShuixian() {
    openDivineShuixian();
}

// window.addEventListener监听
window.addEventListener('message', function(event) {
    if (event.origin !== 'http://tianfuxilian.top') return;

    if (event.data.type === 'deductGold') {
        if (goldAmount >= 2000000) {
            handleDeductGold(2000000, `成功花费${convertPrice(2000000)}金兑换100个养元水（通灵资产650元）！`, 650, "每次换汇至少需要200两金子，你的金子不足！", event);
        } else if (goldAmount >= 200000) {
            handleDeductGold(200000, `成功花费${convertPrice(200000)}金兑换10个养元水（通灵资产65元）！`, 65, "每次换汇至少需要200两金子，你的金子不足！", event);
        } else {
            handleDeductGold(0, "每次换汇至少需要200两金子，你的金子不足！", 0, "每次换汇至少需要200两金子，你的金子不足！", event);
        }
    }

    if (event.data.type === 'exchangeGold') {
        handleExchangeGold(event.data.amount, event);
    }
});

        
function showGuide() {
    const guideMessage =  ` \n欢迎大侠试玩养宠模拟器！当前是V2.1.2
                            \n- 上线高级天赋技能、游商和倒买倒卖小游戏（赚钱新方式！）
                            \n- 继续重构战斗代码（仍存在大量不稳定，技术有限）
                            \n- 上线宝石系统和相关道具，玩家可以在解锁第二件武装后，点击武装图标进行体验
                            \n- 优化加成领悟系统
                            \n- 优化数值系统，避免数值过大时的平衡问题
                            \n- 更改部分UI模块，增加夏日限定皮肤
                            \n- 优化部分显示效果；
                            \n如果大侠未接触过《天书奇谈》的宠物养成系统，您可能需要花费几分钟时间来阅读这些引导。
                            \n以下引导已经过时，请酌情参考。新版引导正在完善中。
                            \n你的终极目标：培养出最强宠物（资质5爆、SS技能全收集且加持所有属性增益系统（比如武装、专精等），进而战胜强大的邪佞并进入无限回廊！
                            \n玩法按钮：点击引导按钮可弹出本提示框，供大侠查看各种功能。
                            \n资质按钮：点击后，会弹出当前宠物的资质界面。宠物的资质决定了当前宠物的总体品质。宠物资质由品质、成长率和资质值组成。资质也会影响宠物的评分，资质值越高，评分越高。
                            \n资质内部有多个功能
                            \na.普通还童：消耗1颗还童丹重新生成当前宠物的资质和技能，并有极低的概率让宠物变异。
                            \n当宠物变异后，宠物的资质会有概率突破上限值，且品质必定为卓越或完美。一般而言，变异的宠物比未变异的宠物更强大。
                            \n当宠物变异后，继续使用还童丹将会使当前宠物失去变异状态。如果你对变异宠物的品质和成长率不满意，你可以在资质面板中的“使用还童金丹”按钮，消耗1颗还童金丹对当前宠物执行更新资质的操作，还童金丹不会改变宠物的变异状态。
                            \nb. 快速还童：如果你厌倦了手动还童，想交给系统一键提升，你可以按照弹窗指引进行输入。请注意，你也有可能消耗所有还童丹而未能达成预期结果。
                            \nc. 还童金丹：还童金丹可以在商店购买，当宠物变异后，使用还童金丹可以在不改变变异状态的情况下刷新宠物的成长率。
                            \nd. 冰魄还童：冰魄还童丹可以在不改变宠物资质的情况下更新宠物品质和成长率。
                            \ne. 刷新资质：消耗1颗资质丹，在不改变品质、成长率和变异状态的情况下，更新宠物的资质值。请注意，更新后的资质值未必比之前更好。
                            \nf. 变异宠物：消耗1颗稀有道具“灵异金丹”使当前宠物立即变异。
                            \n变异后的宠物，资质值有机会爆棚：变为未变异状态上限值的1.1倍。灵异金丹会直接在宠物当前未变异的资质值上乘以1.1倍。因此，未变异状态下，宠物资质值越高，使用灵异金丹的收益越大。
                            \ng. 进化宠物：宠物成功进化后，会随机增加各项资质的当前值。宠物可以最大进化30级，每次进化需要消耗进化之灵，宝箱可以开出不同的进化之灵。颤抖之灵用于1~6级进化，发光之灵用于7~12级进化，活跃之灵用于13~18级进化，跳动之灵用于19~24级进化，闪耀之灵用于25~30级进化。
                            \nh. 洗练技能：消耗1颗万化灵丹，为你的当前宠物随机生成技能。所生成的技能可以通过点击来查看技能说明。悟性越高，越有可能生成多个技能，稀有技能也越可能出现。
                            \n属性按钮：显示当前宠物的属性面板。宠物的资质越高，各项属性也会越高。属性是影响宠物评分的重要因素，请用心培养。属性界面中有很多按钮，功能分别如下：
                            \na. 培养宠物：宠物在1级、60级、120级和180级时会分别获得一次培养机会，每次培养需要花费一定数量的金子，培养成功后宠物的各项属性值会按一定倍数增加。（请注意，在第一次培养后，后期培养只有当宠物刚好为规定等级时才可以执行！）
                            \nb. 普通修炼：消耗一本普通经验书（宝箱获得），让宠物提升一级。宠物等级提升时，属性会增加。
                            \nc. 高级修炼：消耗一本高级经验书（宝箱获得），让宠物提升三级。宠物等级提升时，属性会增加。
                            \nd. 提升悟性：玩家可以通过使用悟性丹来使宠物随机增加一点悟性，提升悟性失败时，会减少悟性值。
                            \ne. 一键提悟：玩家可以输入目标悟性值，由系统计算并使用道具，当悟性丹不够时，会自动停止。
                            \nf. 神级领悟：玩家可以通过宝箱获得稀有道具“举世无双悟性丹”，使用后立即让宠物悟性提升至20。
                            \ng. 飞升突破：当玩家的宠物到达160级，20悟性，且宝库中存在一颗飞升之石，可以让宠物飞升突破当前等级上限至180级。
                            \nh. 宠物传记：查看当前宠物的传记，每个宠物共有三个传记，需要评分达到各自规定值才能解锁查看。
                            \n商店按钮：弹出商店面板。商店每隔5分钟会随机刷新一次货物，大侠也可以花费100文金子手动刷新。付费刷新有更大的概率出现稀有道具和更多货品。
                            \n商店所出售的道具根据其品质会随机定价，购买后会直接添加至道具栏中。
                            \n如果你购买的是宠物的天赋技能，你需要判断当前宠物的名称是否和天赋技能的宠物名称一致，其次保证你的当前宠物没有该技能，否则你将不能购买。一旦购买成功，这个技能会直接打在你的宠物技能位里。
                            \n在本游戏中，宠物的SS技能无法全部通过洗练生成，因此，如果你想要让宠物习得更多强力技能增加评分，你需要在商店里购买并使用天赋道具。
                            \n商店面板中，你可以进行宠物出售的操作，当宠物评分不足10000时，将无法出售。
                            \n当你点击出售按钮时，系统会根据你当前宠物评分的1/50进行出价，成功出售后，当前宠物各项属性会归零，同时得到等量金子。
                            \n宝箱按钮：玩家可以在宝箱界面花费金子打开各种宝箱，获得奇珍异宝和神秘道具！
                            \n背包按钮：除页面顶部道具外，玩家通过宝箱获得的各种稀有道具会存放在此处。
                            \n💁请大侠尽情探索，本游戏还会继续更新功能，敬请期待！`;
    showInfoBox(guideMessage,null,null,'black');
}

function infoPinzhi() {
    showInfoBox("\n1.品质决定宠物的成长上限\n2.宠物共有普通、优秀、杰出、卓越和完美五种自然品质\n3.当宠物成功觉醒时，品质会跃升为“超凡”");
}
function infoShouming() {
    showInfoBox("\n1.宠物出战、释放绝技会消耗一定的寿命\n2.寿命为0时无法释放绝技，可通过道具恢复");
}
function infoChengzhanglv() {
    showInfoBox("\n1.成长率与品质有关，品质越高，成长率越高，宠物升级时属性的增长也会更显著\n2.宠物变异时成长率会有所变化，一般而言，变异的宠物能够得到更明显的属性提升");
}
function infoQianlidian() {
    showInfoBox("\n1.宠物每提升1级会得到2点供自由分配的潜力点\n2.潜力点用于培养宠物\n3.使用金子培养达到第五次后，每次培养会获得潜力点进行随机分配");
}        
function infoJuexing() {
    showInfoBox("\n1.宠物可以在任何时刻下觉醒\n2.觉醒消耗1颗必要道具“醒悟丹”\n3.觉醒后的宠物会得到20%的属性增长，同时开放战斗精灵、25悟性上限和160等级上限\n4.一般而言，当前宠物属性情况越高，觉醒收益越大");
}  
function infoFeisheng() {
    showInfoBox("\n1.宠物满足160级和24悟性时可以进行飞升\n2.飞升后开放属性专精和飞升技能等系统\n3.宠物等级上限会开放至180级");
}  
function infoPingfen() {
    showInfoBox("\n1.评分用于展示宠物的综合实力，且作为出售宠物时唯一的估价依据\n2.培养越用心，评分则越高（技能情况、养成档次、属性值等）\n3.宠物可以在评分界面里外派打工获得额外金钱奖励 \n4.在评分排行界面，可以和你的宠物玩耍改变它的心情，心情决定打工的速度 \n5.除了心情以外，体力会影响宠物每次打工的收益，可以通过休息或喂食提升体力");
}

function infoAdvancement() {
  showInfoBox("\n1. 通过领悟,让你的宠物的SS技能获得更强大的能力!\n2. 每次领悟需要消耗亲密度和集中值,领悟结果有一定的随机性。\n3. 你最多可以为每个宠物领悟10个技能加成,每个加成有高中低三个等级。\n4. 提升加成等级会消耗技能点,宠物每升12级会得到1点技能点。\n5. 消耗学习度可以提升已领悟技能的等级,每级提供不同的加成效果。\n6. 将已领悟的技能加成应用到宠物的实际技能上,可以大幅提升技能威力!\n7. 如果你对现有的加成不满意,可以选择删除或者消耗道具重置所有技能。\n8. 合理分配资源,选择适合宠物的加成策略,让你的宠物变得更加强大吧!");
}
        
function infoWuxingFu() {
    updateWuxingDisplay();
    updateWuxingBonusState();
    const wuxingInfo = drugBonus;
    const nameMap = new Map([
        ['health', '生命值'],
        ['magicAttack', '法术攻击'],
        ['magicDefense', '法术防御'],
        ['mana', '法力值'],
        ['physicalAttack', '物理攻击'],
        ['physicalDefense', '物理防御'],
        ['speed', '速度']
    ]);

    let wuxingInfoMessage = '';

    for (const [key, value] of Object.entries(wuxingInfo)) {
        const displayName = nameMap.get(key) || key; // 如果没有匹配到替换的名称，则使用原始英文名
        wuxingInfoMessage += `${displayName}: ${value}\n`;
    }
    showInfoBox(`\n 当前五行符为${currentPet.name}提供的增益为：\n ${wuxingInfoMessage} \n1.五行符类型: 金木水火土五类,每类五色(红绿橙蓝紫)\n2. 分解机制: 不需要的五行符可以分解，等级越高/品质越高的五行符分解所得碎片越多\n3. 强化系统: 每级强化根据品质消耗1/5/25/125/625碎片和经验值，品质越高，强化所得属性越好\n4. 主词条提升: 按颜色不同，五行符的主词条会有不同。需要尤其注意，红色的五行符只有强化一次后才能确定未来的增长条目\n5. 副词条机制: 随机1-5条，逢5级倍数强化可能增加条数或提升已有条数\n6. 装备限制: 每色最多装备1个,最多同时装备5个五行符\n7.每种五行符会有独特的战斗效果：金符反弹伤害/火符增加输出/土符减少伤害/水符概率再动/木符提升治疗 \n8. 单一种类五行符装备越多/装备的五行符品质越好，等级越高，其五行符强度越高，战斗效果越强大`);
}

let petStates = []; // 全局数组存储每个宠物的状态

function togglePetOverview() {
    const petOverview = document.getElementById('petOverview');
    petOverview.style.display = petOverview.style.display === 'none' ? 'block' : 'none';

    if (petOverview.style.display === 'block') {
        storeCurrentPetData();
        infoPingfenpaihang();
        console.log("打开养成界面，保存当前宠物数据");
    } else {
        console.log("关闭养成界面，保存当前宠物数据");
        saveGameState();
    }
}

function workPage() {
    togglePetOverview();
}
// 保险函数 重置收益倍率
function resetEarningMultiplier() {
    // 遍历所有宠物状态
    petStates.forEach(petState => {
        // 将 earningMultiplier 重置为 1
        petState.earningMultiplier = 1;
    });

    // 选项：你可以在这里添加代码来更新 UI，以反映更改
    petStates.forEach(petState => {
        const earningsElement = document.getElementById(`earnings-${petState.petName}`);
        if (earningsElement) {
            const finalEarnings = convertPrice(Math.floor(petState.goldAmount * petState.stamina * 0.01 * petState.earningMultiplier));
            earningsElement.innerText = `${finalEarnings}金子`;
        }
    });
    resetEarningSpeed();

    showInfoBox("所有宠物的能力值倍数已重置为 1。");
}

function resetEarningSpeed() {
    // 遍历所有宠物状态
    petStates.forEach(petState => {
        // 将 earningMultiplier 重置为 1
        petState.earningSpeed = 1;
    });
}

        
function infoPingfenpaihang() {
    const allPetData = [];
    const newPetStates = [];

    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key.startsWith('petData_')) {
            const petData = JSON.parse(localStorage.getItem(key));
            if (petData && petData.skillScore !== undefined) {
                allPetData.push({
                    petName: key.replace('petData_', ''),
                    skillScore: petData.skillScore,
                    goldAmount: Math.floor(petData.skillScore * 0.0031415926),
                });
            }
        }
    }

    allPetData.sort((a, b) => b.skillScore - a.skillScore);

    const petOverview = document.getElementById('petOverview');
    petOverview.innerHTML = `
        <div style="margin-top: 10px; display: flex; flex-direction: row; justify-content: space-around; align-items: center; color: white; font-weight: bold; text-shadow: -1px -1px 0 black, 1px -1px 0 black, -1px 1px 0 black, 1px 1px 0 black;">
            当前金子: <span id="current-gold">${convertPrice(goldAmount)}</span>
            <button class="close-button" onclick="togglePetOverview()">X</button>
        </div>`;

    petStates.forEach((petState) => {
        if (petState.progressInterval) {
            clearInterval(petState.progressInterval);
        }
    });

    allPetData.forEach((pet) => {
        const petContainer = document.createElement('div');
        petContainer.className = 'pet-container';

        const petObject = Object.values(pets).find(p => p.name === pet.petName);
        const petImage = petObject ? petObject.image : '';
        const initialStamina = 100;
        const initialEarnings = Math.floor(pet.skillScore * 0.0031415926) * initialStamina * 0.01;

        petContainer.innerHTML = `
            <div class="pet-header">
                <div id="header-container" style="display: flex; flex-direction: column; min-width: 70%;">
                    <h2>${pet.petName}（评分: ${pet.skillScore}）</h2>
                    <div style="margin: 10px 0px 10px 0px; display: flex; justify-content: center;">💰能力值：<span id="earnings-${pet.petName}">${convertPrice(initialEarnings)}金子</span></div>
                    <div class="pet-status">
                        <div>😄心情: <span id="mood-${pet.petName}">100%</span></div>
                        <div>👊🏻体力: <span id="stamina-${pet.petName}">100%</span></div>
                    </div>
                </div>
                <div id="header-image" style="display: flex; align-items: center;">
                    <img id="petImage-${pet.petName}" src="${petImage}" style="width: 80px; height: 80px; border-radius: 5px; border: 1px solid white; cursor: pointer;">
                </div>
            </div>
            <div class="pet-progress">
                <div id="progress-bar-${pet.petName}" class="progress-bar"></div>
            </div>
            <div class="pet-buttons">
                <button onclick="play('${pet.petName}')">玩耍</button>
                <button onclick="rest('${pet.petName}')">休息</button>
                <button onclick="feed('${pet.petName}')">喂食</button>
                <button onclick="chat('${pet.petName}')">聊天</button>
                <button id="delegate-button-${pet.petName}" onclick="delegate('${pet.petName}')">委托</button>
            </div>
        `;

        petOverview.appendChild(petContainer);

        const progressBar = document.getElementById(`progress-bar-${pet.petName}`);
        const existingState = petStates.find(state => state.petName === pet.petName);
        const updatedGoldAmount = Math.floor(pet.skillScore * 0.0031415926);

        const updateEarningsDisplay = (petState) => {
            const earningsElement = document.getElementById(`earnings-${petState.petName}`);
            const finalEarnings = convertPrice(Math.floor(petState.goldAmount * petState.stamina * 0.01 * petState.earningMultiplier));
            earningsElement.innerText = `${finalEarnings}金子`;
        };

        if (!existingState) {
            const initialState = {
                petName: pet.petName,
                mood: 100,
                stamina: 100,
                progressBar: progressBar,
                goldAmount: updatedGoldAmount,
                earningMultiplier: 1,
                earningSpeed: 1,
                delegationActive: false,
                progressInterval: null
            };

            newPetStates.push(initialState);

            document.getElementById(`petImage-${pet.petName}`).addEventListener('click', () => {
                showInfoBox(
                    `当前能力值倍数为${initialState.earningMultiplier}，点击确认可尝试提升`,
                    () => {
                        if (useItem('spiritWine', 1) && initialState.earningMultiplier < 2) {
                            initialState.earningMultiplier = Math.min(2, initialState.earningMultiplier + 0.1);
                            showInfoBox(`已提升 ${pet.petName} 的能力值到 ${initialState.earningMultiplier}倍`);
                            updateEarningsDisplay(initialState);
                        } else {
                            showInfoBox('无法再提升能力值，已达到上限或没有足够的琼浆玉露。', null, null, 'red');
                        }
                    }
                );
            });

        } else {
            if (existingState.progressInterval) {
                clearInterval(existingState.progressInterval);
            }

            Object.assign(existingState, {
                goldAmount: updatedGoldAmount,
                progressBar: progressBar,
                progressInterval: null
            });

            newPetStates.push(existingState);

            progressBar.style.width = '0%';
            document.getElementById(`mood-${pet.petName}`).innerText = `${existingState.mood}%`;
            document.getElementById(`stamina-${pet.petName}`).innerText = `${existingState.stamina}%`;
            updateEarningsDisplay(existingState);

            if (existingState.delegationActive) {
                document.getElementById(`delegate-button-${pet.petName}`).innerText = "停止";
                handleDelegation(pet.petName);
            }

            document.getElementById(`petImage-${pet.petName}`).addEventListener('click', () => {
                showInfoBox(
                    `当前能力值倍数为${existingState.earningMultiplier}，点击确认可尝试提升`,
                    () => {
                        if (useItem('spiritWine', 1) && existingState.earningMultiplier < 2) {
                            existingState.earningMultiplier = Math.min(2, existingState.earningMultiplier + 0.1);
                            showInfoBox(`已提升 ${pet.petName} 的能力值到 ${existingState.earningMultiplier}倍`);
                            updateEarningsDisplay(existingState);
                        } else {
                            showInfoBox('无法再提升能力值，已达到上限或没有足够的琼浆玉露。', null, null, 'red');
                        }
                    }
                );
            });
        }
    });

    petStates = newPetStates;
    saveGameState();
    storeCurrentPetData();
    startPetWork();
}


function startPetWork() {
    petStates.forEach((petState, index) => {
        if (petState.progressInterval) {
            clearInterval(petState.progressInterval);
        }

        const progressBar = petState.progressBar;
        const moodElement = document.getElementById(`mood-${petState.petName}`);
        const staminaElement = document.getElementById(`stamina-${petState.petName}`);
        const earningsElement = document.getElementById(`earnings-${petState.petName}`);

        if (!progressBar || !moodElement || !staminaElement || !earningsElement) {
            console.warn(`宠物 ${petState.petName} 的UI元素不存在，跳过处理`);
            return;
        }

        petState.progressInterval = setInterval(() => {
            if (petState.mood > 0 && petState.stamina > 0) {
                const timeFactor = 1 + (100 - petState.mood) / 10;
                const gainFactor = 1 - (100 - petState.stamina) / 100;

                const currentWidth = parseFloat(progressBar.style.width) || 0;
                progressBar.style.width = `${Math.min(100, currentWidth + (1 / timeFactor) * petState.earningSpeed)}%`;

                if (parseFloat(progressBar.style.width) >= 100) {
                    progressBar.style.width = '0%';
                    petState.mood = Math.max(0, petState.mood - 1);
                    petState.stamina = Math.max(0, petState.stamina - 1);

                    moodElement.innerText = `${petState.mood}%`;
                    staminaElement.innerText = `${petState.stamina}%`;

                    const updatedEarnings = convertPrice(Math.floor(petState.goldAmount * gainFactor * petState.earningMultiplier));
                    earningsElement.innerText = `${updatedEarnings}金子`;

                    const goldEarned = Math.floor(petState.goldAmount * gainFactor * petState.earningMultiplier);
                    goldAmount += goldEarned;
                    updateGoldDisplay(goldAmount);
                    document.getElementById("current-gold").innerText = `${convertPrice(goldAmount)}`;

                    if (petState.mood === 0 || petState.stamina === 0) {
                        clearInterval(petState.progressInterval);
                        petState.progressInterval = null;
                    }
                }
            }
        }, 3000 / 100);
    });
}

function play(petName) {
    const petState = petStates.find(state => state.petName === petName);
    if (!petState) return;

    if (useItem('angelWings', 1) && petState.earningSpeed < 2) {
        petState.earningSpeed += 0.1;
        showInfoBox(`插上你给的翅膀，${petName}搬砖的速度如虎添翼`);
        return;
    }

    let mood = petState.mood;
    const availableMoodItems = jinnangItems.filter(item => (item.name === 'fancyFlower' || item.name === 'damoTumbler') && item.quantity > 0);

    if (availableMoodItems.length > 0) {
        // 如果有可用的物品，则使用物品提升心情
        const feedItem = availableMoodItems[Math.floor(Math.random() * availableMoodItems.length)];
        useItem(feedItem.name, 1);

        const moodChanges = {
            'fancyFlower': { change: 15, message: `${petName}被眼前的景象惊喜到了，ta接过去，大口大口呼吸着花束的味道。` },
            'damoTumbler': { change: 15, message: `${petName}假装生气地跟你说自己不是小孩子，但还是在你看不到的角落偷偷拨弄你送他的不倒翁。` }
        };

        mood = Math.min(100, mood + moodChanges[feedItem.name].change);
        petState.mood = mood;
        document.getElementById(`mood-${petName}`).innerText = `${mood}%`;
        
        showInfoBox(moodChanges[feedItem.name].message);
    } else {
        // 如果没有可用的物品，执行随机提升心情的逻辑
        const moodChange = Math.floor(Math.random() * 41) - 10;
        mood = Math.min(100, Math.max(0, mood + moodChange));
        petState.mood = mood;
        document.getElementById(`mood-${petName}`).innerText = `${mood}%`;

        const earningsElement = document.getElementById(`earnings-${petState.petName}`);
        const updatedEarnings = convertPrice(Math.floor(petState.goldAmount * (1 - (100 - petState.stamina) / 100) * petState.earningMultiplier));
        earningsElement.innerText = `${updatedEarnings}金子`;

        const moodEvents = {
            '-10': `你准备了${petName}最喜欢的美食,但它只是尝了一口就走开了,看起来没有胃口。`,
            '-9': `你试图和${petName}玩耍，但它似乎不感兴趣，只想静静待着。`,
            '-8': `${petName}今天有点烦躁，也许需要一些安静的时间。`,
            '-7': `${petName}看起来有些无精打采，可能需要更多的关注。`,
            '-6': `${petName}对你提供的玩具没什么兴趣，似乎有些心不在焉。`,
            '-5': `你邀请${petName}一起看了一部新上映的电影,但它似乎对情节不太感兴趣,中途还打了几个哈欠。`,
            '-4': `${petName}稍微有点不开心，但还是愿意和你待在一起。`,
            '-3': `${petName}似乎有点疲惫，可能需要休息。`,
            '-2': `${petName}对新的活动有些犹豫，不过还是参与了。`,
            '-1': `${petName}有点沉默，不过一会儿应该会好些。`,
            '0': `${petName}的心情没有变化，但至少没有变坏。`,
            '1': `你和${petName}一起欣赏了一场音乐会,它听到熟悉的旋律时,脸上露出了微笑。`,
            '2': `${petName}对你的新发型表示赞赏，心情稍微好了一些。`,
            '3': `${petName}非常享受今天的阳光，心情变得更好。`,
            '4': `${petName}和你一起在公园散步，似乎很开心。`,
            '5': `${petName}对你为它准备的小惊喜感到很高兴。`,
            '6': `你带${petName}去了它最喜欢的公园,陪它玩了一会儿飞盘,它看起来很开心。`,
            '7': `${petName}尝试了一些新的食物，并且非常喜欢。`,
            '8': `${petName}在你给它的新床上睡得很好，心情很好。`,
            '9': `${petName}享受了一次特别的护理，显得非常满意。`,
            '10': `${petName}在你的陪伴下感到很放松，心情明显好转。`,
            '11': `你和${petName}一起做了一顿美味的晚餐,它吃得非常满足,心情明显好转。`,
            '12': `${petName}和你一起看了一部搞笑电影，笑得合不拢嘴。`,
            '13': `${petName}在和朋友玩耍后，显得非常高兴。`,
            '14': `${petName}收到了它最喜欢的玩具，心情大好。`,
            '15': `${petName}对新的学习项目表现出极大的兴趣，心情愉悦。`,
            '16': `你和${petName}一起回顾了你们的旅行照片,它对那些美好的回忆感到非常怀念和高兴。`,
            '17': `${petName}在与你的游戏中赢了一局，显得非常自信。`,
            '18': `${petName}今天的训练非常顺利，心情非常好。`,
            '19': `${petName}在阳台上悠闲地晒太阳，心情很放松。`,
            '20': `${petName}得到了很多赞美，心情非常好。`,
            '21': `你和${petName}一起参加了一个有趣的绘画活动,它非常投入,画出了一幅令人印象深刻的作品。`,
            '22': `${petName}在和你一起的时光中感到无比快乐。`,
            '23': `${petName}在公园里结识了新朋友，心情极佳。`,
            '24': `${petName}得到了它最爱的零食，开心极了。`,
            '25': `${petName}在运动会上表现出色，心情飞扬。`,
            '26': `你和${petName}一起参加了一场激动人心的球赛,当你们支持的队伍获胜时,它兴奋得跳了起来,心情极佳!`,
            '27': `${petName}被你抱了很久，心情特别好。`,
            '28': `${petName}看到你为它准备的新家，非常激动。`,
            '29': `${petName}和你一起度过了最美好的一天，心情无比愉悦。`,
            '30': `${petName}享受了一次完美的旅行，心情极好！`
        };

        let infoMessage = moodEvents[moodChange.toString()] || `你和${petName}一起度过了一个平凡但快乐的时光。`;

        if (moodChange > 0 && Math.random() * 100 < moodChange) {
            const selectedItem = jinnangItems[Math.floor(Math.random() * jinnangItems.length)];
            selectedItem.quantity += 1;
            infoMessage += ` 在这次亲密的玩耍中，你们还惊喜地收获了一个${selectedItem.displayName}！`;
        }

        showInfoBox(infoMessage);
        if (mood <= 20) {
            showInfoBox(`${petName}最近似乎有些闷闷不乐,也许你们可以尝试一些新的活动,如烹饪课或者瑜伽课,给生活增添一些乐趣。`);
        } else if (mood >= 100) {
            showInfoBox(`${petName}最近心情非常好,它非常享受和你在一起的每一刻,无论是一起探索新的餐厅,还是在家中观看你们都喜欢的经典电影。`);
        }
    
        petState.stamina = Math.max(0, petState.stamina - Math.abs(moodChange));
        document.getElementById(`stamina-${petName}`).innerText = `${petState.stamina}%`;
    }
    
    if (!petState.progressInterval && mood > 0 && petState.stamina > 0) {
        startPetWork();
    }
}
        
function rest(petName) {
    const petState = petStates.find(state => state.petName === petName);
    if (!petState) return;

    if (petState.delegationActive) {
        showInfoBox(`${petName}正在委托代管中，不需要休息~`);
        return;
    }

    if (petState.progressInterval) {
        clearInterval(petState.progressInterval);
        petState.progressInterval = null;
    }

    petState.progressBar.style.width = '0%';
    petState.stamina = Math.min(100, petState.stamina + 5);
    document.getElementById(`stamina-${petName}`).innerText = `${petState.stamina}%`;
    showInfoBox(`${petName}不舍地拉住你的衣角：我就睡一小会儿，不可以离开哦…`);

    setTimeout(() => {
        petState.stamina = Math.min(100, petState.stamina + 5);
        document.getElementById(`stamina-${petName}`).innerText = `${petState.stamina}%`;
        showInfoBox(`${petName}睁开眼睛，看到你在身边，顿时充满了干劲`);

        const earningsElement = document.getElementById(`earnings-${petState.petName}`);
        const timeFactor = 1 + (100 - petState.mood) / 10;
        const gainFactor = 1 - (100 - petState.stamina) / 100;
        const updatedEarnings = convertPrice(Math.floor(petState.goldAmount * gainFactor * petState.earningMultiplier));
        earningsElement.innerText = `${updatedEarnings}金子`;

        if (petState.mood > 0 && petState.stamina > 0) {
            startPetWork();
        }
    }, 5000);
}

function feed(petName) {
    const petState = petStates.find(state => state.petName === petName);
    if (!petState) return;

    const workSalary = petState.goldAmount;
    const currentStamina = petState.stamina;
    const baseCost = 1000 + workSalary / 10;
    const staminaCost = baseCost * (100 - currentStamina);
    const feedCost = Math.round(Math.ceil(staminaCost / 10) * 10 * (petState.earningMultiplier + petState.earningSpeed));

    // 过滤出背包中所有有效的食物（数量大于0）
    const availableFoodItems = jinnangItems.filter(item => {
        return (item.name === 'redApple' || item.name === 'chocolate') && item.quantity > 0;
    });

    if (availableFoodItems.length > 0) {
        // 随机选择一个食物
        const randomIndex = Math.floor(Math.random() * availableFoodItems.length);
        const feedItem = availableFoodItems[randomIndex];

        // 使用选定的食物
        useItem(feedItem.name, 1);

        let staminaIncrease = 0;
        let infoMessage = '';

        // 根据不同的食物调整体力增加值和提示信息
        if (feedItem.name === 'redApple') {
            staminaIncrease = 5;
            infoMessage = `你递给${petName}一个美味的苹果，${petName}似乎从没见过这种水果，小心翼翼咬了一口，被香脆的口感惊喜到了。`;
        } else if (feedItem.name === 'chocolate') {
            staminaIncrease = 10;
            infoMessage = `你递给${petName}一块巧克力，${petName}感受到甜蜜的味道，体力有所恢复。`;
        }

        petState.stamina = Math.min(100, petState.stamina + staminaIncrease);
        document.getElementById(`stamina-${petName}`).innerText = `${petState.stamina}%`;
        showInfoBox(infoMessage);

    } else if (goldAmount >= feedCost) {
        goldAmount -= feedCost;
        updateGoldDisplay(goldAmount);
        petState.stamina = Math.min(100, petState.stamina + 50);
        document.getElementById(`stamina-${petName}`).innerText = `${petState.stamina}%`;
        showInfoBox(`${petName}缠着你要吃大餐，你为此花费了${convertPrice(feedCost)}金子`);
        document.getElementById("current-gold").innerText = `${convertPrice(goldAmount)}`;
    } else {
        showInfoBox("金钱不足，无法喂食！");
        return;
    }

    const gainFactor = 1 - (100 - petState.stamina) / 100;
    const updatedEarnings = convertPrice(Math.floor(petState.goldAmount * gainFactor * petState.earningMultiplier));
    document.getElementById(`earnings-${petState.petName}`).innerText = `${updatedEarnings}金子`;

    if (!petState.progressInterval && petState.mood > 0 && petState.stamina > 0) {
        startPetWork();
    }
}



function chat(petName) {
    const petState = petStates.find(state => state.petName === petName);
    if (!petState) return;

    const score = petState.goldAmount;
    const mood = petState.mood;
    let stamina = petState.stamina;
    const rank = Math.min(Math.floor(score / 10000), 7);

    if (mood < 20 || stamina < 20) {
        showInfoBox(`${petName} 感觉很累,暂时不想聊天。`);
        return;
    }

    let chatRank = rank;
    if (stamina >= 90 && Math.random() < 0.5) {
        chatRank = Math.min(rank + 2, 7);
    } else if (stamina >= 60 && Math.random() < 0.5) {
        chatRank = Math.min(rank + 1, 7);
    } else if (stamina >= 20 && Math.random() < 0.5) {
        chatRank = Math.max(rank - 1, 0);
    }

    // 聊天内容库
    const chatContent = {
        0: [
            "不确定自己是否喜欢你。",
            "对你还没有特别的感觉。",
            "觉得你只是个普通朋友。",
            "对你的印象还不错。",
            "觉得你是个有趣的人。",
            "对你有了一丝好感。"
        ],
        1: [
            "觉得你们可以做朋友。",
            "觉得你是个值得交往的人。", 
            "觉得你很友善,愿意与你交朋友。",
            "觉得你是个好人,愿意与你成为朋友。",
            "觉得你很有魅力,想要与你成为朋友。",
            "觉得你很可靠,愿意与你建立友谊。"
        ],
        2: [
            "觉得你们有很多共同的兴趣。",
            "发现你们有许多相似的爱好。",
            "觉得你们的兴趣爱好非常投缘。",
            "觉得你们志趣相投,很聊得来。",
            "发现你们在许多方面都很合得来。",
            "觉得你们的兴趣爱好出奇地一致。"
        ],
        3: [
            "很欣赏你,并且希望多了解你。",
            "觉得你是个很不错的人,想更深入地了解你。",
            "被你的某些特质深深吸引,想进一步了解你。",
            "觉得你很有魅力,渴望更多地了解你。",
            "觉得你是个很有内涵的人,想更全面地了解你。",
            "觉得你很特别,希望能有机会更深入地了解你。"
        ],
        4: [
            "认为你们的友谊会越来越深。",
            "觉得你们的友谊正在不断加深。",
            "相信你们的友谊会历久弥新。",
            "觉得你们的友谊正在向更深层次发展。",
            "觉得你们的友谊正变得越来越牢固。",
            "相信你们的友谊会永远长存。"
        ],
        5: [
            "对你产生了深厚的情感。",
            "觉得自己已经深深地爱上了你。",
            "发现自己已经离不开你了。",
            "感觉你已经成为了自己生命中不可或缺的一部分。",
            "觉得你就是自己一直在寻找的另一半。",  
            "感觉自己的心已经完全属于你了。"
        ],
        6: [
            "想要和你一起探索未来。",
            "希望能与你共度余生,携手探索未来。",
            "想与你一起谱写人生的篇章,开启崭新的未来。",
            "愿意与你风雨同舟,共同迎接未来的每一个挑战。",
            "期待与你手牵手,一起走向美好的未来。",
            "希望能与你相伴到老,共同见证未来的点点滴滴。"  
        ],
        7: [
            "完全信任你,并希望和你永远在一起。",
            "觉得你就是自己的唯一,此生非你不可。",
            "愿意把自己的一切都交给你,因为你就是我的全部。",
            "感觉有了你,人生就完整了,你就是我的一切。",
            "无论发生什么,都会永远和你在一起,永不分离。",
            "这辈子最大的幸福,就是可以和你厮守终生。"
        ]
    };
    
    const chatSupplement = {
        0: [
            "今天天气真不错，阳光明媚。我打算去城外的灵药园逛逛，听说最近有一批珍稀的九叶草开花了。你有什么安排吗？",
            "我最近在看一本有趣的书，讲述了一个关于平行位面的故事。你平时喜欢看什么类型的书？",
            "你觉得我们这个城里哪家炼丹坊最好？我个人很喜欢南街的'五行堂'，他们的培元丹和静心丸都很有效。",
            "周末有什么打算吗？我听说北山新开了一家'御剑阁'，据说那里的飞剑体验很刺激。如果你感兴趣，我们可以一起去试试。",
            "最近修炼怎么样？我们宗门刚接了一个新任务，需要去妖兽森林收集一些材料，感觉既有挑战又很有意思。"
        ],
        1: [
            "我发现我们似乎都对符文学很感兴趣，真是太巧了。上周我刚刚研究出一个新的防御符咒，虽然还不太稳定，但效果还不错。你最近有什么新发现吗？",
            "看到你在上次法器交流会上展示的那件飞行法器，真的很有创意。特别是你设计的灵力转换装置，我觉得非常巧妙。你是怎么想到这个点子的？",
            "最近我看了《山海经》这本古籍，里面对神兽的描述让我很着迷。你看过吗？我特别喜欢里面关于九尾狐的传说。",
            "和你聊天总是很愉快，上次讨论元素亲和力的话题让我受益匪浅。我按照你的建议尝试了水系冥想，感觉对我的修炼很有帮助。",
            "谢谢你上次给我推荐的那本《道藏精要》，里面关于五行相生相克的理论给了我很大启发。你还有什么好书可以推荐吗？"
        ],
        2: [
            "最近我开始学习炼丹，尝试炼制了一些简单的回复丹和解毒丸。虽然失败了几次，但慢慢在进步。你有什么学习新技能的小技巧可以分享吗？",
            "我发现我们对灵兽驯养的看法很相似。上周我参加了一个保护珍稀灵兽的活动，让我更深刻地认识到乱捕滥猎的危害。你平时会关注这些问题吗？",
            "上周末我去参加了一个瞬移术工作坊，真是既紧张又有趣。需要在很短的时间内掌握空间法则，对精神力的要求很高。你最近有没有尝试什么新的修炼方法？",
            "我一直在思考如何平衡修炼和日常生活。最近尝试每天下山后花一小时做一些普通人的事情，感觉压力小了很多。你是怎么处理这个问题的？能分享一下你的经验吗？",
            "我最近在尝试冥想，使用一种古老的心法每天坚持半个时辰。虽然刚开始很难进入状态，但慢慢感觉灵力运转更顺畅了。你有没有什么独特的修炼方法？"
        ],
        3: [
            "和你在一起的时候，我总是感到非常放松和自在。比如上次我们一起去探索那个古老的遗迹，你对那些神秘符文的见解让我印象深刻，我们讨论了一整天都不觉得累。不知道你是否也有同样的感觉？",
            "我真的很欣赏你的幽默感。记得上次在百草园，你模仿各种灵植的样子，把大家逗得前仰后合。你的幽默总是那么得体又有趣，每次和你聊天都会让我心情变好。",
            "最近我在思考是否要接受那个去秘境历练的邀请，感觉有点迷茫。特别是考虑到可能要离开宗门好几年，我真的不知道该怎么决定。你有没有经历过类似的抉择？是如何度过的？",
            "我觉得你是一个很有原则的人，这一点让我很敬佩。比如上次有人提议用禁术提升修为时，你坚持正道修炼的态度。你是如何在各种情况下坚持自己的原则的？",
            "每次看到你坚持晨练、研究新的法术的样子，我都会受到鼓舞。即使遇到瓶颈，你也能保持这种积极向上的态度。你是怎么保持这种自律的？能分享一下你的心得吗？"
        ],
        4: [
            "不知不觉中，你已经成为了我修炼生涯中很重要的一部分。每次遇到修炼上的困难，你都是我第一个想要请教的人。上周我灵力暴走时，多亏了你教我的那个稳定心神的口诀，我才能平安度过。真的很感谢有你在我身边。",
            "有时候我会想，如果没有遇见你，我的修炼之路会是什么样子。可能就不会爱上符文学，也不会开始研究丹道吧。是你让我看到了修炼更多的可能性。真的很感谢命运让我们相遇。",
            "最近我越来越期待和你见面切磋了。每次和你一起去那个隐秘的洞天福地，讨论修炼心得、交流法术，都让我感到特别放松和愉快。不知道你有没有察觉到我的这种变化？",
            "我发现我越来越喜欢听你分享你的想法和经历。上次你讲述你在幽冥界历练的经历，让我深受触动。你对世界的认知和对修炼的理解，总是能给我新的启发。",
            "和你在一起的时候，我感觉时间过得特别快。记得上次我们一起去探索那个新发现的秘境，本来说好只待半天，结果一直聊到天黑才依依不舍地回来。希望我们能有更多这样共处的时光。"
        ],
        5: [
            "我发现自己开始关心你的一切，你的喜怒哀乐都会影响到我的情绪。昨天看到你因为突破失败而沮丧，我的心情也跟着低落了。我想要为你做些什么，哪怕只是陪你一起冥想。这种感觉真的很奇妙。",
            "有时候我会怀疑，是不是太依赖你了。每天不和你交流一下修炼心得，就感觉少了些什么。但每次和你在一起，看着你施展法术的样子，听你讲述你的见解，这种担忧就会消失不见。",
            "我开始期待能和你共度未来的每一天。想象着我们一起修炼、一起历练、一起探索未知世界的画面。不知道你有没有想过我们的未来会是什么样子？你会希望和我一起实现哪些修炼目标？",
            "最近我常常会想起我们在一起的点点滴滴，第一次见面时你羞涩的样子，第一次一起御剑飞行时你兴奋的表情，第一次你教我炼丹时认真的神态...每一个回忆都让我倍感珍惜。",
            "你的存在给了我很大的勇气和力量。记得我初次面对妖兽时害怕得不敢动，是你鼓励我站出来；我遇到修炼瓶颈时，是你陪我度过难关。有你在身边，我觉得自己什么都能做到。谢谢你一直是我坚强的后盾。"
        ],
        6: [
            "我希望能永远陪在你身边，分享你的喜怒哀乐，给你最温暖的拥抱和最真挚的爱。无论是你突破境界时的喜悦，还是遇到修炼瓶颈时的沮丧，我都想第一时间陪伴在你身边。",
            "每天晚上入定前，我都会想着你。回想着你的笑容，你的声音，你施展法术时的英姿。早上醒来，你是我的第一个念想。这份感觉如此美好，我希望能永远持续下去。",
            "我开始规划我们的未来了。我想和你一起修炼，一起探索世界，一起经历修真界的每一个奇迹。也许我们可以先一起建立一个小型洞府，然后收服一只灵兽，将来有了道侣后再搬到更大的福地...你觉得呢？",
            "有时候我会担心自己配不上你。你那么强大，那么聪慧，而我还有很多不足。但你总是能给我信心，让我相信我们的感情。你的包容和支持是我最大的动力。",
            "我愿意为你做任何事，只要能让你开心。看到你因为我送的灵丹而欣喜，或者因为我记得你随口提过的法器而感动，我就感到无比幸福。你的幸福就是我最大的心愿。"
        ],
        7: [
            "我的生命因为有了你而变得完整。你就是我的全世界，我的一切。没有你，灵力失去了意义，法术失去了威力，修炼失去了方向。有了你，我的修真之路才真正绚丽多彩。",
            "我想告诉整个修真界，我是多么地爱你。你是我此生最珍贵的宝藏。我愿意站在昆仑之巅，对着天地万物呐喊，告诉每一个修士我有多么爱你，你对我有多么重要。",
            "没有你，我无法想象我的修炼之路会是什么样子。你给了我前进的意义和动力。每一个有你在的日子都是如此美好，我感恩能与你相遇，相知，相爱。",
            "我愿意用我的一生来爱你，保护你，让你成为修真界最幸福的人。不管遇到什么劫难，我都会在你身边。我发誓会永远忠诚于你，珍惜你，尊重你，爱护你。",
            "我们的灵魂仿佛注定要在一起。我相信，即使在轮回中，我们也会再次相遇，再次相爱。无论经历多少次转世，我都会义无反顾地爱上你，选择你。你就是我命中注定的那个道侣。"
        ]
    };
    let chatMessage;

    if (chatContent[chatRank] && chatContent[chatRank].length > 0) {
        if (mood >= 85) {
            const supplementIndex = Math.floor(Math.random() * chatSupplement[chatRank].length);
            chatMessage = `${petName}${chatContent[chatRank][Math.floor(Math.random() * chatContent[chatRank].length)]}"${chatSupplement[chatRank][supplementIndex]}"`;
        } else if (mood >= 60) {
            chatMessage = `${petName}虽然心情一般,但他${chatContent[chatRank][Math.floor(Math.random() * chatContent[chatRank].length)]}`;
        } else {
            chatMessage = `${petName}看起来有点沮丧,疲惫的眼神表露出他${chatContent[chatRank][Math.floor(Math.random() * chatContent[chatRank].length)]}`;
        }
    } else {
        chatMessage = `${petName}看起来有些沉默不语,似乎不愿多说什么。`;
    }

    showInfoBox(chatMessage);
    petState.stamina = Math.max(0, stamina - 2);
    document.getElementById(`stamina-${petName}`).innerText = `${petState.stamina}%`;

    const earningsElement = document.getElementById(`earnings-${petState.petName}`);
    const timeFactor = 1 + (100 - petState.mood) / 10;
    const gainFactor = 1 - (100 - petState.stamina) / 100;
    const updatedEarnings = convertPrice(Math.floor(petState.goldAmount * gainFactor * petState.earningMultiplier));
    earningsElement.innerText = `${updatedEarnings}金子`;
}

function delegate(petName) {
    const petState = petStates.find(state => state.petName === petName);
    if (!petState) return;

    const delegateButton = document.querySelector(`#delegate-button-${petName}`);
    let delegationActive = petState.delegationActive || false;

    const petDataKey = `petData_${petName}`;
    const petData = JSON.parse(localStorage.getItem(petDataKey));
    let cultivationPoints = petData ? petData.additionalPlayerCultivation : 0;

    petState.delegationActive = !delegationActive;
    delegationActive = petState.delegationActive;

    if (delegationActive) {
        if (cultivationPoints <= 0) {
            showInfoBox(`调兵遣将实乃耗费心智之事，你需要在${petName}的属性面板内，通过修炼（修为处的加号）提升修行点数才能为${petName}开启委托功能`);
            petState.delegationActive = false;
            return;
        }

        delegateButton.innerText = "停止";
        showInfoBox(`${petName} 的委托功能已开启！当前修行点数为${cultivationPoints}`);
        handleDelegation(petName);
    } else {
        showInfoBox(`${petName} 的委托功能已关闭！当前修行点数为${cultivationPoints}`);
        clearInterval(petState.delegationInterval);
        petState.delegationInterval = null;
        delegateButton.innerText = "委托";
    }
}

function handleDelegation(petName) {
    const petState = petStates.find(state => state.petName === petName);
    if (!petState) return;

    const petDataKey = `petData_${petName}`;
    const petData = JSON.parse(localStorage.getItem(petDataKey));
    let cultivationPoints = petData ? petData.additionalPlayerCultivation : 0;

    petState.delegationInterval = setInterval(() => {
        
        if (!petState.delegationActive) {
            clearInterval(petState.delegationInterval);
            petState.delegationInterval = null;
            return;
        }

        if (petState.mood < 80 && cultivationPoints > 0) {
            const moodChange = Math.floor(Math.random() * 41) - 10;
            if (cultivationPoints >= Math.abs(moodChange)) {
                petState.mood = Math.min(100, petState.mood + moodChange);
                cultivationPoints -= Math.abs(moodChange);
                petData.additionalPlayerCultivation -= Math.abs(moodChange);
                    if (petName === currentPet.name) {
                        additionalPlayerCultivation -= Math.abs(moodChange);
                        localStorage.setItem(petDataKey, JSON.stringify(petData));
                    }
                
                localStorage.setItem(petDataKey, JSON.stringify(petData));
                document.getElementById(`mood-${petName}`).innerText = `${petState.mood}%`; 
                petState.stamina = Math.max(0, petState.stamina - Math.abs(moodChange));
                document.getElementById(`stamina-${petName}`).innerText = `${petState.stamina}%`;
            } else {
                showInfoBox("修行点数不足，无法继续自动提升心情！");
                clearInterval(petState.delegationInterval);
                petState.delegationActive = false;
                petState.delegationInterval = null;
                document.getElementById(`delegate-button-${petName}`).innerText = "委托";
                return;
            }
        }

        if (petState.stamina < 80 && cultivationPoints > 0) {
            const staminaNeeded = 100 - petState.stamina;
            const feedCost = Math.round(Math.ceil((1000 + petState.goldAmount / 10) * staminaNeeded / 10) * 10 * (petState.earningMultiplier + petState.earningSpeed));
            if (cultivationPoints >= staminaNeeded) {
                if (goldAmount >= feedCost) {
                    petState.stamina = Math.min(100, petState.stamina + staminaNeeded);
                    cultivationPoints -= staminaNeeded;
                    petData.additionalPlayerCultivation -= staminaNeeded;
                        if (petName === currentPet.name) {
                            additionalPlayerCultivation -= Math.abs(staminaNeeded);
                            localStorage.setItem(petDataKey, JSON.stringify(petData));
                        }
                    
                    localStorage.setItem(petDataKey, JSON.stringify(petData));
                    goldAmount -= feedCost;
                    updateGoldDisplay(goldAmount);
                    document.getElementById("current-gold").innerText = `${convertPrice(goldAmount)}`;
                    document.getElementById(`stamina-${petName}`).innerText = `${petState.stamina}%`;
                } else {
                    showInfoBox("金钱不足，无法继续自动恢复体力！");
                    clearInterval(petState.delegationInterval);
                    petState.delegationActive = false;
                    petState.delegationInterval = null;
                    document.getElementById(`delegate-button-${petName}`).innerText = "委托";
                    return;
                }
            } else {
                showInfoBox("修行点数不足，无法继续自动恢复体力！");
                clearInterval(petState.delegationInterval);
                petState.delegationActive = false;
                petState.delegationInterval = null;
                document.getElementById(`delegate-button-${petName}`).innerText = "委托";
                return;
            }
        }
        
        if (petState.mood > 0 && petState.stamina > 0 && !petState.progressInterval) {
            startPetWork();
        }
    }, 1000);
}
        
function infoXiuwei() {
    showInfoBox(`\n1.修为主要由宠物等级和综合实力自动计算得来 \n2.修为在战斗中的作用至关重要，主要体现在施加战斗效果、延长施法时间、抵抗敌人控制类效果和提升法术闪避等 \n3.修为越高，赢得战局的可能性越大 \n4.如果你拥有珍贵的仙人醍醐，可以通过修炼提升修为 \n5.通过修炼提升的修为值可以作为宠物打工时委托使用的修行点数 \n6.${currentPet.name}的修为值为${playerCultivation}，其中修炼修为值为${additionalPlayerCultivation}`,null,null,'black');
}  
function infoWuxing() {
    showInfoBox("\n1.悟性对宠物的成长至关重要 \n2.悟性越高，洗练所得高级技能的概率就越大 \n3.悟性能够给二级属性百分比的加成");
}  
 



function showBattleOverlay(imageUrl, duration = 500, opacity = 1, zIndex = -1) {
    const overlay = document.getElementById('battleOverlay');
    const overlayImage = document.getElementById('battleOverlayImage');

    if (!overlay || !overlayImage) {
        console.error('Overlay elements not found.');
        return;
    }

    overlayImage.src = '';  // Clear the image first
    overlayImage.src = imageUrl;  // Set the new image URL
    overlayImage.style.opacity = String(opacity);  // Ensure opacity is a string
    overlay.style.display = 'flex';  // Make the overlay visible
    overlay.style.zIndex = String(zIndex);  // Set the z-index

    setTimeout(() => {
        overlay.style.display = 'none';  // Hide the overlay after duration
    }, duration);
}

let gameItems = {
    transmutationPill: 0,
    rebornPill: 0,
    bingpoRebornPill: 0,
    goldenRebornPill: 0,
    miraculousPill: 0,
    qualityPill: 0,
    highGradePill: 0,
    goldAmount: 0,
    stamps: 0,
    jinnangItems: [] // 用于存储 jinnangItems 的物品和数量
};

let alreadyUnlocked = false;

function simulateLoading() {
    let progress = 0;
    const interval = setInterval(() => {
        progress += 15;
        if (progress <= 100) {
            document.getElementById('loadingText').innerText = `加载中... ${progress}%`;
            document.getElementById('progressBar').style.width = `${progress}%`;
        } else {
            clearInterval(interval);
            document.getElementById('loadingOverlay').style.display = 'none';
            if (!alreadyUnlocked) {
                document.getElementById('unlockOverlay').style.display = 'flex';
            }
        }
    }, 100);
}

function guestPlay() {
    showInfoBox('\n1. 你可以体验到游戏内置的“自由经商”模块，这是一个经营类的小游戏。 \n2. 由于是试玩模式，你无法存档和读取存档，每次点开此页面都会重置数据。',
               () => {
                   document.getElementById('scalping-display').style.display = 'flex';
               },
               () => {
                   showMerchant('如果你想要体验完整版本的宠物模拟器，欢迎联系QQ1060028177');
               });
}
        
if (window.GestureEvent || (navigator.maxTouchPoints > 0)) {
    let lastTouchEnd = 0;

    document.body.addEventListener('touchend', function (e) {
        const now = Date.now();
        if (now - lastTouchEnd <= 200) { // 调整这里的时间间隔
            e.preventDefault(); // 阻止双击放大
        }
        lastTouchEnd = now;
    }, { passive: false });

    document.body.addEventListener('dblclick', function (e) {
        e.preventDefault(); // 阻止双击事件
    }, { passive: false });
}

function isInteractiveElement(e) {
    let { nodeName } = e;

    if (nodeName === 'A' && e.hasAttribute('href') ||
        ['BUTTON', 'INPUT', 'SELECT', 'TEXTAREA'].includes(nodeName) && !e.disabled ||
        nodeName === 'LABEL' && (e.htmlFor || e.querySelector('input,select,textarea') !== null) ||
        ['IMG', 'OBJECT'].includes(nodeName) && e.useMap ||
        ['AUDIO', 'VIDEO'].includes(nodeName) && e.controls ||
        ['SUMMARY', 'IFRAME', 'EMBED'].includes(nodeName)) {
        return true;
    }

    return e.hasAttribute('tabindex') && e.tabIndex > -1;
}

function preloadImages(imageUrls) {
    const imageCache = [];
    imageUrls.forEach(url => {
        const img = new Image();
        img.src = url;
        imageCache.push(img);
    });
}

// 调用函数预加载图片
const imageUrls = [
    "https://pic.imgdb.cn/item/667fa3b3d9c307b7e916f84c.gif",
    "https://pic.imgdb.cn/item/669e973ad9c307b7e9381309.gif",
    "https://pic.imgdb.cn/item/663885620ea9cb14033e4f6e.png",
    "https://pic.imgdb.cn/item/66541c01d9c307b7e9208aea.png",
    "https://pic.imgdb.cn/item/66542639d9c307b7e92c235d.gif",
    "https://pic.imgdb.cn/item/666af8afd9c307b7e90e4638.gif",
    "https://pic.imgdb.cn/item/66616fe95e6d1bfa05b0103d.png",
    "https://pic.imgdb.cn/item/66616fea5e6d1bfa05b0117c.png",
    "https://pic.imgdb.cn/item/66616fea5e6d1bfa05b0121c.png",
    "https://pic.imgdb.cn/item/66616feb5e6d1bfa05b01297.png",
    "https://pic.imgdb.cn/item/66616feb5e6d1bfa05b01297.png",
    "https://pic.imgdb.cn/item/66616feb5e6d1bfa05b01312.png",
    "https://pic.imgdb.cn/item/66616fec5e6d1bfa05b013ec.png",
    "https://pic.imgdb.cn/item/666466225e6d1bfa05b95973.png",
    "https://pic.imgdb.cn/item/66541c01d9c307b7e9208add.png",
    "https://pic.imgdb.cn/item/6654a944d9c307b7e9ca6423.png",
    "https://pic.imgdb.cn/item/6655a92ad9c307b7e9c04265.png",
    "https://pic.imgdb.cn/item/665ef0855e6d1bfa055800f4.png",
    "https://pic.imgdb.cn/item/6654a944d9c307b7e9ca63f5.png",
    "https://pic.imgdb.cn/item/66556068d9c307b7e9681672.png",
    "https://pic.imgdb.cn/item/6656e598d9c307b7e906ca29.png",
    "https://pic.imgdb.cn/item/6656e734d9c307b7e9088e9b.png",
    "https://pic.imgdb.cn/item/6656e734d9c307b7e9088e7b.png",
    "https://pic.imgdb.cn/item/6656e734d9c307b7e9088e6d.png",
    "https://pic.imgdb.cn/item/665ef0845e6d1bfa055800c7.png",
    "https://pic.imgdb.cn/item/6656e81dd9c307b7e9098478.png",
    "https://pic.imgdb.cn/item/6656e821d9c307b7e90988b2.png",
    "https://pic.imgdb.cn/item/6656e81dd9c307b7e909844a.png",
    "https://pic.imgdb.cn/item/6656e81dd9c307b7e90984b7.png",
    "https://pic.imgdb.cn/item/6656e81dd9c307b7e909843e.png",
    "https://pic.imgdb.cn/item/666ab20bd9c307b7e96301f6.png",
    "https://pic.imgdb.cn/item/666ab20bd9c307b7e9630192.png",
    "https://pic.imgdb.cn/item/666aa7b6d9c307b7e9495e97.png",
    "https://pic.imgdb.cn/item/665ef0855e6d1bfa055800f4.png",
    "https://pic.imgdb.cn/item/6656a1b6d9c307b7e9baa881.png",
    "https://pic.imgdb.cn/item/66556068d9c307b7e9681672.png",
    "https://pic.imgdb.cn/item/6656a1b6d9c307b7e9baa85b.png",
    "https://pic.imgdb.cn/item/665af22fd9c307b7e910c815.png",
    "https://pic.imgdb.cn/item/666c0289d9c307b7e9ae8abd.png",
    "https://pic.imgdb.cn/item/665566e5d9c307b7e971236e.png",
    "https://pic.imgdb.cn/item/6661a2715e6d1bfa05edb3a2.png",
    "https://pic.imgdb.cn/item/6661a26a5e6d1bfa05edacf1.png",
    "https://pic.imgdb.cn/item/66712470d9c307b7e9e44732.gif",
    "https://pic.imgdb.cn/item/66712ba3d9c307b7e9f2ab59.gif",
    "https://pic.imgdb.cn/item/667123f9d9c307b7e9e34049.gif",
    "https://pic.imgdb.cn/item/6671343bd9c307b7e9031c3d.gif",
    "https://pic.imgdb.cn/item/665de3fd5e6d1bfa05564912.png",
    "https://pic.imgdb.cn/item/665c7652d9c307b7e991a20d.png"
];
preloadImages(imageUrls);

let currentInfoBox = null;

function showInfoBox(message, onConfirm, onCancel, textColor = '#92341C', imageUrl = null, size = '45px * 45px') {
    // 如果已经有一个信息框存在，先关闭它
    if (currentInfoBox) {
        document.body.removeChild(currentInfoBox);
        currentInfoBox = null;
    }

    // 创建提示框元素
    const infoBox = document.createElement('div');
    infoBox.style.position = 'fixed';
    infoBox.style.top = '50%';
    infoBox.style.left = '50%';
    infoBox.style.transform = 'translate(-50%, -50%)';
    infoBox.style.width = '80%';
    infoBox.style.maxHeight = '80%';
    infoBox.style.minHeight = '10%';
    infoBox.style.zIndex = '9999';
    infoBox.style.fontSize = '14px';
    infoBox.style.padding = '10px 20px 5px 20px';
    infoBox.style.backgroundColor = '#DFBF6E';
    infoBox.style.color = textColor; // 使用可选参数设置文本颜色
    infoBox.style.backgroundImage = 'url(https://pic.imgdb.cn/item/663885620ea9cb14033e4f6e.png)';
    infoBox.style.backgroundRepeat = 'repeat';
    infoBox.style.backgroundSize = 'auto';
    infoBox.style.boxShadow = '0px 0px 0px 1px rgb(30, 46, 47), inset 0 0 0px 1px #6f391c';
    infoBox.style.border = '1px solid #EBAC3B';
    infoBox.style.overflowY = 'auto'; // 处理内容过多时的滚动

    // 如果有传入图片URL，添加图片元素
    if (imageUrl) {
        const [width, height] = size.split('*').map(s => s.trim()); // 分解size参数

        const imageElement = document.createElement('img');
        imageElement.src = imageUrl;
        imageElement.style.display = 'block';
        imageElement.style.margin = '0 auto'; // 居中显示
        imageElement.style.width = width; // 设置图片宽度
        imageElement.style.height = height; // 设置图片高度
        imageElement.style.objectFit = 'contain'; // 保持图片比例
        infoBox.appendChild(imageElement);
    }

    // 创建消息文本元素
    const messageElement = document.createElement('p');
    messageElement.style.margin = '0px';
    messageElement.style.marginTop = imageUrl ? '10px' : '15px'; // 如果有图片则减少间距
    messageElement.style.wordBreak = 'auto-phrase';
    messageElement.style.maxHeight = '460px';
    messageElement.style.overflowY = 'scroll';
    messageElement.innerText = message;
    infoBox.appendChild(messageElement);

    // 创建按钮容器元素
    const buttonContainer = document.createElement('div');
    buttonContainer.style.marginTop = '20px';
    buttonContainer.style.textAlign = 'right';
    buttonContainer.style.display = 'flex';
    buttonContainer.style.flexDirection = 'row';
    buttonContainer.style.justifyContent = 'center';
    buttonContainer.style.gap = '20px';
    infoBox.appendChild(buttonContainer);

    // 统一按钮样式
    const buttonStyle = `
        background: linear-gradient(to bottom, #E47F47, #CE6633, #963D1C);
        box-shadow: inset 0px 0px 2px 1px #87431F;
        font-size: 14px;
        border-radius: 5px;
        color: #F9DE9B;
        padding: 0px 14px;
        cursor: pointer;
        transition: transform 0.1s, box-shadow 0.1s;
        border: 1px solid #6f391c;
    `;

    // 创建确认按钮
    const confirmButton = document.createElement('button');
    confirmButton.innerText = '确认';
    confirmButton.style.cssText = buttonStyle;
    confirmButton.addEventListener('click', () => {
        document.body.removeChild(infoBox);
        currentInfoBox = null;
        if (typeof onConfirm === 'function') {
            onConfirm();
        }
    });
    buttonContainer.appendChild(confirmButton);

    // 创建取消按钮
    const cancelButton = document.createElement('button');
    cancelButton.innerText = '取消';
    cancelButton.style.cssText = buttonStyle;
    cancelButton.addEventListener('click', () => {
        document.body.removeChild(infoBox);
        currentInfoBox = null;
        if (typeof onCancel === 'function') {
            onCancel();
        }
    });
    buttonContainer.appendChild(cancelButton);

    // 将提示框添加到页面中
    document.body.appendChild(infoBox);

    // 将当前信息框设置为新创建的信息框
    currentInfoBox = infoBox;
}



// 显示提示信息的函数
function showMessage(message, type = 'info') {
    const messageContainer = document.getElementById('message-container');
    messageContainer.innerText = message;
    messageContainer.style.display = 'block';
    messageContainer.style.color = type === 'error' ? 'red' : 'white';

    // 10秒后隐藏提示信息
    setTimeout(() => {
        messageContainer.style.display = 'none';
    }, 10000);
}

document.addEventListener('DOMContentLoaded', () => {
    updateStampCount();
});

let petLevel = 1;
let petMaxLevel = 149;
let petAscended = false;
let currentLifeSpan = 5000;
let maxLifeSpan = 5000;
        
//宠物图鉴功能
let collectedPetCount = 0; // 全局变量，用于存储已收录宠物的数量
let collectedPets = [];

function petCollection() {
    // 清空之前的面板内容
    const existingCollectionPanel = document.getElementById('collectionPanel');
    if (existingCollectionPanel) {
        existingCollectionPanel.remove();
    }

    // 创建新的图鉴面板
    const collectionPanel = document.createElement('div');
    collectionPanel.id = 'collectionPanel';
    collectionPanel.style.position = 'fixed';
    collectionPanel.style.top = '50%';
    collectionPanel.style.left = '50%';
    collectionPanel.style.transform = 'translate(-50%, -50%)';
    collectionPanel.style.width = '95%';
    collectionPanel.style.zIndex = '1000';
    collectionPanel.style.padding = '2px';
    collectionPanel.style.borderRadius = '2px';
    collectionPanel.style.backgroundColor = '#DFBF6E';
    collectionPanel.style.color = '#92341c';
    collectionPanel.style.backgroundImage = 'url(https://pic.imgdb.cn/item/663885620ea9cb14033e4f6e.png)';
    collectionPanel.style.backgroundRepeat = 'repeat';
    collectionPanel.style.backgroundSize = 'auto';
    collectionPanel.style.border = '1px solid black';
    collectionPanel.style.boxShadow = 'inset 0px 0px 2px 2px #6f391c';
    document.body.appendChild(collectionPanel);
    
    // 创建关闭按钮
    const closeButton = document.createElement('button');
    closeButton.innerText = '宠物图鉴';
    closeButton.style.display = 'flex';
    closeButton.style.flexDirection = 'column';
    closeButton.style.width = '100%';
    closeButton.style.fontSize = '16px';
    closeButton.style.padding = '5px';
    closeButton.style.textAlign = 'center';
    closeButton.style.backgroundImage = 'url(https://pic.imgdb.cn/item/66bf32d9d9c307b7e9995d58.png)';
    closeButton.style.backgroundRepeat = 'repeat';
    closeButton.style.backgroundSize = 'contain';
    closeButton.style.color = 'rgb(227, 167, 59)';
    closeButton.style.cursor = 'pointer';
    closeButton.style.boxShadow = 'rgb(227, 167, 59) 0px 1px 2px 0px inset';
    closeButton.style.border = '1px solid black';
    closeButton.style.alignItems = 'center';
    closeButton.addEventListener('click', () => collectionPanel.remove());
    collectionPanel.appendChild(closeButton);

    // 创建图鉴加成信息区
    const bonusInfoDiv = document.createElement('div');
    bonusInfoDiv.id = 'bonusInfo';
    bonusInfoDiv.style.padding = '10px';
    bonusInfoDiv.style.display = 'flex';
    bonusInfoDiv.style.flexWrap = 'wrap';
    bonusInfoDiv.style.alignItems = 'center';
    bonusInfoDiv.style.borderRadius = '2px';
    bonusInfoDiv.style.border = '1px solid rgb(122, 64, 11)';
    bonusInfoDiv.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';
    bonusInfoDiv.style.fontSize = '12px';
    bonusInfoDiv.style.marginBottom = '10px';
    bonusInfoDiv.style.gap = '20px 40px';
    bonusInfoDiv.style.justifyContent = 'center';
    bonusInfoDiv.style.margin = '10px';
    collectionPanel.appendChild(bonusInfoDiv);

    // 创建图鉴内容
    const collectionContent = document.createElement('div');
    collectionContent.id = 'collectionContent';
    collectionContent.style.display = 'grid';
    collectionContent.style.gridTemplateColumns = 'repeat(4, 1fr)';
    collectionContent.style.fontSize = '12px';
    collectionContent.style.height = '330px';
    collectionContent.style.overflowY = 'scroll';
    collectionContent.style.border = '1px solid #6f391c';
    collectionContent.style.borderRadius = '2px';
    collectionContent.style.margin = '10px 10px 20px';

    Object.keys(pets).forEach(petKey => {
        if (petKey !== 'jinmin' && petKey !== "liguo" && petKey !== "jiecheng") {
            const pet = pets[petKey];
            const petDiv = document.createElement('div');
            petDiv.className = 'pet-item';
            petDiv.style.display = 'flex';
            petDiv.style.flexDirection = 'column';
            petDiv.style.justifyContent = 'space-between';
            petDiv.style.alignItems = 'center';
            petDiv.style.padding = '5px';
    
            const img = document.createElement('img');
            img.src = pet.image; // 默认图标
            img.alt = pet.name;
            img.style.width = '40px';
            img.style.height = '40px';
            img.style.border = '10px solid transparent';
            img.style.borderImage = 'url(https://pic.imgdb.cn/item/66c2f34cd9c307b7e9be06c0.png) 40 round';
            img.style.cursor = 'pointer';
            img.addEventListener('click', () => {
                showInfoBox(`${pet.name}，${pet.rank}级别`);
            });
            
    
            const nameDiv = document.createElement('div');
            nameDiv.innerText = pet.name;
            
            const statusDiv = document.createElement('div');
            statusDiv.innerText = collectedPets.includes(pet.name) ? '已收录' : '未收录';
            
            const collectButton = document.createElement('button');
            collectButton.innerText = '收录';
            collectButton.style.fontSize = '12px';
            collectButton.style.color = '#F9DE9B'; 
            collectButton.style.background = 'linear-gradient(to bottom, #E47F47, #CE6633, #963D1C)'; 
            collectButton.style.border = '1px solid #6F391C'; 
            collectButton.style.padding = '2px 6px'; 
            collectButton.style.borderRadius = '5px'; 
            collectButton.style.cursor = 'pointer'; // 鼠标悬停时显示为指针
            
            // 如果已收录，则禁用按钮并设置样式
            if (collectedPets.includes(pet.name)) {
                collectButton.style.backgroundColor = 'grey'; // 禁用时的背景颜色
                collectButton.style.cursor = 'not-allowed'; // 禁用时的鼠标样式
                collectButton.disabled = true;
            }
    
            collectButton.addEventListener('click', () => {
                const petSelect = document.getElementById('pet-select');
                const magicPetAmuletOwned = jinnangItems.some(item => item.name === 'magicPetAmulet' && item.quantity > 0);
    
                if (magicPetAmuletOwned) {
                    showInfoBox("您拥有珍贵道具灵兽符文，使用后可以直接开启此图鉴位，你需要使用吗？", () => {
                        if (useItem('magicPetAmulet')) {
                            collectedPets.push(pet.name);
                            collectedPetCount++;
                            statusDiv.innerText = '已收录';
                            collectButton.style.backgroundColor = 'grey'; // 更新禁用时的背景颜色
                            collectButton.style.cursor = 'not-allowed'; // 更新禁用时的鼠标样式
                            collectButton.disabled = true;
                            updateCollectionBonus();
                            const currentAttributes = calculateCurrentAttributes(); // 重新计算当前属性
                            updateSecondaryAttributes(currentAttributes, currentWisdom); // 更新二级属性
                        }
                    }, () => {
                        // 用户取消使用灵兽符文，继续原有逻辑
                        handleCollectButtonClick(petKey, pet, petSelect, statusDiv, collectButton);
                    });
                } else {
                    handleCollectButtonClick(petKey, pet, petSelect, statusDiv, collectButton);
                }
            });
    
            petDiv.appendChild(img);
            petDiv.appendChild(nameDiv);
            petDiv.appendChild(statusDiv);
            petDiv.appendChild(collectButton);
            collectionContent.appendChild(petDiv);
        }
    });

    collectionPanel.appendChild(collectionContent);

    updateCollectionBonus();
    updateSkillScore();
    updateAttributePanel();
    updateTitle();
}

function handleCollectButtonClick(petKey, pet, petSelect, statusDiv, collectButton) {
    if (!isPetOwned(petKey)) {
        showInfoBox("你还没有该宠物!");
        return;
    }

    if (petSelect.options.length <= 1) {
        showInfoBox("这是您的唯一爱宠了,请好好珍惜它!");
        return;
    }

    if (petSelect.value === petKey) {
        showInfoBox("⚠️⚠️⚠️这是你目前的出战宠物，一旦收录将立即被清空数据，请谨慎操作！是否继续？", () => {
            let newOption;
            do {
                const randomIndex = Math.floor(Math.random() * petSelect.options.length);
                newOption = petSelect.options[randomIndex].value;
            } while (newOption === petKey);

            petSelect.value = newOption;
            changePet(); // 更新宠物信息

            deletePetData(pet.name);
            collectedPets.push(pet.name);
            collectedPetCount++;
            statusDiv.innerText = '已收录';
            collectButton.style.backgroundColor = 'grey'; // 更新禁用时的背景颜色
            collectButton.style.cursor = 'not-allowed'; // 更新禁用时的鼠标样式
            collectButton.disabled = true;

            const optionToRemove = petSelect.querySelector(`option[value="${petKey}"]`);
            if (optionToRemove) {
                optionToRemove.remove();
            }

            updateCollectionBonus();
            const currentAttributes = calculateCurrentAttributes(); // 重新计算当前属性
            updateSecondaryAttributes(currentAttributes, currentWisdom); // 更新二级属性
        }, () => {
            return;
        });
    } else {
        showInfoBox("收录宠物后,宠物会消失,你确定收录吗?", () => {
            collectedPets.push(pet.name);
            collectedPetCount++;
            statusDiv.innerText = '已收录';
            collectButton.style.backgroundColor = 'grey'; // 更新禁用时的背景颜色
            collectButton.style.cursor = 'not-allowed'; // 更新禁用时的鼠标样式
            collectButton.disabled = true;

            const optionToRemove = petSelect.querySelector(`option[value="${petKey}"]`);
            if (optionToRemove) {
                optionToRemove.remove();
            }

            updateCollectionBonus();
            const currentAttributes = calculateCurrentAttributes(); // 重新计算当前属性
            updateSecondaryAttributes(currentAttributes, currentWisdom); // 更新二级属性
        }, () => {
            return;
        });
    }
}

function updateCollectionBonus() {
    const bonusInfoDiv = document.getElementById('bonusInfo');
    const hpBonus = Math.round(collectedPetCount * 0.05 * 100);
    const mpBonus = Math.round(collectedPetCount * 0.04 * 100);
    const physicalAttackBonus = Math.round(collectedPetCount * 0.012 * 100);
    const magicalAttackBonus = Math.round(collectedPetCount * 0.01 * 100);
    const physicalDefenseBonus = Math.round(collectedPetCount * 0.035 * 100);
    const magicalDefenseBonus = Math.round(collectedPetCount * 0.035 * 100);
    const speedBonus = Math.round(collectedPetCount * 0.005 * 100);

    bonusInfoDiv.innerHTML = `
        <div>收录数量: ${collectedPetCount}</div>
        <div>HP 加成: +${hpBonus}%</div>
        <div>MP 加成: +${mpBonus}%</div>
        <div>物攻 加成: +${physicalAttackBonus}%</div>
        <div>法攻 加成: +${magicalAttackBonus}%</div>
        <div>物防 加成: +${physicalDefenseBonus}%</div>
        <div>法防 加成: +${magicalDefenseBonus}%</div>
        <div>速度 加成: +${speedBonus}%</div>
    `;
}

function isPetOwned(petKey) {
    const petSelect = document.getElementById('pet-select');
    return petSelect && !!petSelect.querySelector(`option[value="${petKey}"]`);
}
       
let stamps = 5000; // 初始印花数量
let summonCharmPaper = 5; // 初始召唤灵符数量
let summonedPet = null;
let currentPetKey = 'xiaojin';
let currentPet = pets[currentPetKey]; // 初始化当前宠物

// 删除宠物数据
function deletePetData(petName) {
    const key = `petData_${petName}`;
    if (localStorage.getItem(key) !== null) {
        localStorage.removeItem(key);
        console.log(`Data for pet ${petName} has been deleted.`);
        
        const petSelect = document.getElementById('pet-select');
        const optionToRemove = Array.from(petSelect.options).find(option => option.text === petName);
        if (optionToRemove) {
            petSelect.removeChild(optionToRemove);
        }
    } else {
        console.log(`No data found for pet ${petName}.`);
    }
}

// 删档函数
function deleteAllPetData() {
    showInfoBox('你确定删除其他宠物数据吗？操作不可恢复！', () => {
        showInfoBox('你真的要重置当前的所有数据吗？', () => {
            const keysToRemove = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key.startsWith('petData_')) {
                    keysToRemove.push(key);
                }
            }
            keysToRemove.forEach(key => {
                const petName = key.replace('petData_', '');
                if (petName !== currentPet.name) {
                    localStorage.removeItem(key);
                    
                    const petSelect = document.getElementById('pet-select');
                    const optionToRemove = Array.from(petSelect.options).find(option => option.text === petName);
                    if (optionToRemove) {
                        petSelect.removeChild(optionToRemove);
                    }
                }
            });

            // 检查 localStorage 中是否存在 'gameState' 数据
            if (localStorage.getItem('gameState') !== null) {
                localStorage.removeItem('gameState');
                console.log('gameState 已被删除');
            } else {
                console.log('gameState 不存在');
            }

            showInfoBox('除当前宠物外，其他宠物数据均已删除！如果你需要删除所有数据，请不要进行任何操作，直接刷新本页面完成初始化。如果你需要保留当前宠物的数据，你可以点击存档。');
            console.log(`Deleted ${keysToRemove.length - 1} pet data entries.`);
        }, 
        () => {
            showInfoBox('操作已取消！', null, null, 'red');
            return;
        }, 
        'red');
    });
}

        
// 存储当前宠物的数据
function storeCurrentPetData() {
    if (currentPet && currentPet.name) {
        const skillsArea = document.getElementById("skills-area");
        const existingSkills = Array.from(skillsArea.children).map(skillDiv => {
            const [name, rarity] = skillDiv.innerText.split(' (');
            return {
                name: name,
                rarity: rarity.slice(0, -1) // 去掉最后一个字符 ')'
            };
        });
    const petData = {
        additionalPlayerCultivation: additionalPlayerCultivation,
        alreadyUseDrug: alreadyUseDrug,
        armsAttributes: JSON.stringify(armsAttributes),
        armsOpened: armsOpened,
        ascensionAttributes: ascensionAttributes,
        ascensionEnabled: ascensionEnabled,
        ascensionSkill: ascensionSkill ? getSkillFromName(ascensionSkill.name, ascensionSkill.level) : null,
        awakenAttributes: awakenAttributes,
        awakened: awakened,
        additionalAttributes: additionalAttributes,
        baseAttributes: baseAttributes,
        bonusAttributes: bonusAttributes,
        currentExp: currentExp,
        currentPet: JSON.stringify(currentPet),
        currentSpecialization: currentSpecialization,
        currentWisdom: currentWisdom,
        currentLifeSpan: currentLifeSpan,
        maxLifeSpan: maxLifeSpan,
        consumedPillCount: consumedPillCount,
        divineWeapons: divineWeaponManager.getWeaponData(),
        divinedWeaponStatus: divinedWeaponStatus,
        drugBonus0: drugBonus0,
        enemyCritDamage: enemyCritDamage,
        enemyCritRate: enemyCritRate,
        enemyPetCultivation: enemyPetCultivation,
        evolutionLevel: evolutionLevel,
        existingSkills: existingSkills, // 存储技能数据
        experienceTreasureOpenCount: experienceTreasureOpenCount,
        hallucinated: hallucinated,
        hallucinationLevel: hallucinationLevel,
        maxExp: maxExp,
        petAscended: petAscended,
        petLevel: petLevel,
        petMaxLevel: petMaxLevel,
        petWisdom: petWisdom,
        playerCritDamage: playerCritDamage,
        playerCritRate: playerCritRate,
        playerCultivation: playerCultivation,
        poisonSkillActivated: poisonSkillActivated,
        qualityPillCount: qualityPillCount,
        reenableAscension: reenableAscension,
        remainingPoints: remainingPoints,
        secondAscensionSkill: secondAscensionSkill ? getSkillFromName(secondAscensionSkill.name, secondAscensionSkill.level) : null,
        skillScore: skillScore,
        specializations: specializations,
        spiritLevel: spiritLevel,
        spiritMultiplier: spiritMultiplier,
        trainingCount: trainingCount,
    };
        localStorage.setItem(`petData_${currentPet.name}`, JSON.stringify(petData));
    }
}
let alreadyLoadGameState = false;
// 恢复指定宠物的数据
function restorePetData(petName) {
    const savedPetData = JSON.parse(localStorage.getItem(`petData_${petName}`));
    if (!alreadyLoadGameState) {
        return;
    }
    
    if (savedPetData) {
        currentPet = JSON.parse(savedPetData.currentPet);
        petLevel = savedPetData.petLevel;
        evolutionLevel = savedPetData.evolutionLevel;
        remainingPoints = savedPetData.remainingPoints;
        trainingCount = savedPetData.trainingCount;
        currentWisdom = savedPetData.currentWisdom;
        petAscended = savedPetData.petAscended;
        petMaxLevel = savedPetData.petMaxLevel;
        petWisdom = savedPetData.petWisdom;
        awakened = savedPetData.awakened;
        awakenAttributes = savedPetData.awakenAttributes;
        hallucinated = savedPetData.hallucinated;
        hallucinationLevel = savedPetData.hallucinationLevel;
        experienceTreasureOpenCount = savedPetData.experienceTreasureOpenCount;
        armsOpened = savedPetData.armsOpened;
        armsAttributes = JSON.parse(savedPetData.armsAttributes);
        currentExp = savedPetData.currentExp;
        maxExp = savedPetData.maxExp;
        playerCritRate = savedPetData.playerCritRate;
        playerCritDamage = savedPetData.playerCritDamage;
        playerCultivation = savedPetData.playerCultivation;
        additionalPlayerCultivation = savedPetData.additionalPlayerCultivation;
        enemyPetCultivation = savedPetData.enemyPetCultivation;
        enemyCritRate = savedPetData.enemyCritRate;
        enemyCritDamage = savedPetData.enemyCritDamage;
        ascensionEnabled = savedPetData.ascensionEnabled;
        poisonSkillActivated = savedPetData.poisonSkillActivated;
        spiritLevel = savedPetData.spiritLevel;
        spiritMultiplier = savedPetData.spiritMultiplier;
        reenableAscension = savedPetData.reenableAscension;
        bonusAttributes = savedPetData.bonusAttributes;
        ascensionAttributes = savedPetData.ascensionAttributes;
        divinedWeaponStatus = savedPetData.divinedWeaponStatus;
        alreadyUseDrug = savedPetData.alreadyUseDrug;
        skillScore = savedPetData.skillScore;
        if (!savedPetData.baseAttributes) {
            baseAttributes = {
                endurance: 0,
                intelligence: 0,
                strength: 0,
                agility: 0,
                faith: 0
            };
        }
        if (awakened && savedPetData.awakenAttributes) {
            awakenAttributes = savedPetData.awakenAttributes;
        }
        
        if (savedPetData.currentLifeSpan) {
            currentLifeSpan = savedPetData.currentLifeSpan;
        } 
        
        if (savedPetData.maxLifeSpan) {
            maxLifeSpan = savedPetData.maxLifeSpan;
        } 
        
        if (savedPetData.additionalAttributes) {
            additionalAttributes = savedPetData.additionalAttributes;
        }

        if (savedPetData.drugBonus0) {
            drugBonus0 = savedPetData.drugBonus0;
        }
        
        if (savedPetData.qualityPillCount) {
            qualityPillCount = savedPetData.qualityPillCount;
        }
        
        if (savedPetData.consumedPillCount) {
            consumedPillCount = savedPetData.consumedPillCount;
        }
        
        if (savedPetData.specializations) {
            specializations = savedPetData.specializations;
        }
        if (savedPetData.currentSpecialization !== undefined) {
            currentSpecialization = savedPetData.currentSpecialization;
        }
        if (savedPetData.collectedPets) {
            collectedPets = savedPetData.collectedPets;
        }
        if (savedPetData.collectedPetCount !== undefined) {
            collectedPetCount = savedPetData.collectedPetCount;
        }
        if (savedPetData.divineWeapons) {
            divineWeaponManager.setWeaponData(savedPetData.divineWeapons);
        }
        if (savedPetData.existingSkills) {
            const skillsArea = document.getElementById("skills-area");
            skillsArea.innerHTML = ''; // 清空当前技能
            savedPetData.existingSkills.forEach(skill => {
                const skillDiv = document.createElement('div');
                skillDiv.innerText = `${skill.name} (${skill.rarity})`;
                skillDiv.onclick = () => {
                    deleteSkill(skill, skillDiv, skillsArea);
                };
                if (skill.rarity === 'S') {
                    skillDiv.classList.add('s-skill');
                } else if (skill.rarity === 'SS') {
                    skillDiv.classList.add('ss-skill');
                } else if (skill.rarity === 'SSS') {
                    skillDiv.classList.add('sss-skill');
                }
                skillsArea.appendChild(skillDiv);
            });
        }

        if (savedPetData.ascensionSkill && savedPetData.ascensionSkill.name) {
            ascensionSkill = getSkillFromName(savedPetData.ascensionSkill.name, savedPetData.ascensionSkill.level);
        } else {
            ascensionSkill = null;
        }
        
        if (savedPetData.secondAscensionSkill && savedPetData.secondAscensionSkill.name) {
            secondAscensionSkill = getSkillFromName(savedPetData.secondAscensionSkill.name, savedPetData.secondAscensionSkill.level);
        } else {
            secondAscensionSkill = null;
        }
        updateDisplayContent();
    }
    updateWuxingBonusState();
}

function testButton() {
    showInfoBox(
        "仅供游戏异常时调试使用（如切换宠物失败或加载异常），请勿随意点击，因为这可能会造成数据丢失",
        () => { // onConfirm 回调
            resetPet();
            restorePetData();
        },
        () => { // onCancel 回调
            return;
        }
    );
}
        
// 修改changePet函数
function handlePetChange(selectedPetKey, petSelectId) {
    if (autoBattleInterval !== null) {
        showInfoBox("请先关闭自动战斗！");
        return;
    }

    // 检查选择的宠物是否是当前宠物
    if (currentPetKey === selectedPetKey) return;

    const selectedPet = pets[selectedPetKey];
    if (selectedPet) {
        storeCurrentPetData(); // 存储当前宠物数据
        saveGameState(); //存储总体游戏数据
        
        currentPetKey = selectedPetKey;
        currentPet = selectedPet; // 将当前宠物设为选择的宠物

        // 检查 localStorage 中是否存在该宠物的数据
        const storedPetData = localStorage.getItem(`petData_${currentPet.name}`);
        if (storedPetData) {
            resetPet();
            restorePetData(currentPet.name); // 如果存在数据，恢复宠物数据
        } else {
            resetPet(); // 否则重置宠物数据
        }

        updatePetDisplay();
        updateDisplayContent();
        document.getElementById("description-box").innerText = `您将当前宠物更换为:${currentPet.name}`;
    } else {
        console.error('无法找到选中的宠物:', selectedPetKey);
    }
}

function changePet(skipConfirmation = false) {
    const petSelectValue = document.getElementById("pet-select").value;
    handlePetChange(petSelectValue, "pet-select");
}

function changeBattlePet(skipConfirmation = false) {
    const battlePetSelectValue = document.getElementById("battle-pet-select").value;
    handlePetChange(battlePetSelectValue, "battle-pet-select");
}
        
function updatePetDisplay() {
    document.getElementById("your-pet-name").innerText = currentPet.name; // 更新宠物名称显示
    document.getElementById("pet-image").src = currentPet.image; // 更新宠物图片显示
    document.getElementById("your-pet-image").src = currentPet.image;
    
    document.getElementById("your-pet-image").addEventListener('click', () => {
        const lifeExtensionDrug = '延寿露';
        const snowLotusDrug = '天山雪莲';
        
        if (battleAttributes.health <= maxHealth * 0.8) {
            selectDrug('延寿露');  // 选择延寿露
            useSelectedDrug();  // 使用所选的药品
        } else if (battleAttributes.mana <= maxMana * 0.8) {
            selectDrug('天山雪莲');  // 选择天山雪莲
            useSelectedDrug();  // 使用所选的药品
        } else {
            logBattleEvent('当前无需恢复或没有足够恢复道具', 'aqua');
        }
    });
    updateMutatedImg();
}

        
function showSummonPanel() {
    const summonPanel = document.getElementById('summonPanel');
    summonPanel.style.display = 'block';
    document.getElementById('summonArea').innerHTML = ''; // 清空召唤区域
}

document.getElementById('summonButton').addEventListener('click', showSummonPanel);

function updateStampCount() {
    const stampCountElem = document.getElementById('stampCount');
    const currentStampCountElem = document.getElementById('currentStampCount');

    if (currentStampCountElem) {
        currentStampCountElem.innerText = stamps;
    } else {
        console.error('元素 #currentStampCount 未找到');
    }
}

// 添加关闭按钮功能
document.getElementById('closeSummonPanel').addEventListener('click', () => {
    document.getElementById('summonPanel').style.display = 'none';
});

document.getElementById('closePetShop').addEventListener('click', () => {
    document.getElementById('summonPanel').style.display = 'none';
    document.getElementById('petShop').style.display = 'none';
});

//召唤宠物
document.getElementById('summonExecuteButton').addEventListener('click', () => {
    // 如果有未领取的宠物，自动帮玩家领取
    handleSummonPet();
});
function handleSummonPet() {
        if (summonedPet) {
        const petSelect = document.getElementById('pet-select');
        const petKey = Object.keys(pets).find(key => pets[key].name === summonedPet.name);

        if (Array.from(petSelect.options).some(option => option.value === petKey)) {
            let exchangeAmount;
            switch (summonedPet.rank) {
                case 'R':
                    exchangeAmount = 240;
                    break;
                case 'SR':
                    exchangeAmount = 600;
                    break;
                case 'SSR':
                    exchangeAmount = 3600;
                    break;
            }
            showInfoBox(`您已经拥有${summonedPet.name}，将其转化为${exchangeAmount}印花！`);
            stamps += exchangeAmount;
        } else {
            showInfoBox(`您成功领取了${summonedPet.name}！`);
            const option = document.createElement('option');
            option.value = petKey;
            option.text = summonedPet.name;
            petSelect.appendChild(option);
        }
        summonedPet = null;
        updateStampCount();
    }

    if (useItem('summonCharmPaper')) {
        const randomNumber = Math.random();
        let summonedRank;
        if (randomNumber < 0.01) {
            summonedRank = 'SSR';
        } else if (randomNumber < 0.20) {
            summonedRank = 'SR';
        } else {
            summonedRank = 'R';
        }

        const eligiblePets = Object.keys(pets).filter(key => pets[key].rank === summonedRank && pets[key] !== 'liguo' && pets[key] !== 'jinmin' && pets[key] !== 'qiongmei' && pets[key] !== 'jiecheng');
        const randomPetKey = eligiblePets[Math.floor(Math.random() * eligiblePets.length)];
        summonedPet = pets[randomPetKey];

        // 显示加载图片
        if (summonedRank !== 'SSR'){
            document.getElementById('summonArea').innerHTML = `
            <img src="https://pic.imgdb.cn/item/66a4d223d9c307b7e9a2c147.gif" alt="加载中" id="loadingGif" style="width: 75%;height: 90%;border: 2px solid white;">
        `;
        } else{
            document.getElementById('summonArea').innerHTML = `
            <img src="https://pic.imgdb.cn/item/66a4f555d9c307b7e9c33849.gif" alt="加载中" id="loadingGif" style="width: 75%;height: 90%;border: 2px solid white;">
        `;
        }

        const loadingGif = document.getElementById('loadingGif');
        
        // 确保图片加载完成后开始计时
        loadingGif.onload = () => {
            setTimeout(() => {
                document.getElementById('summonArea').innerHTML = `
                    <img src="${summonedPet.image}" alt="${summonedPet.name}" style="width: 75%;height: 90%;border: 2px solid white;">
                    <div style="color:white;">${summonedPet.name} (${summonedPet.rank})</div>
                `;
                showInfoBox(`你召唤了${summonedPet.name} (${summonedPet.rank})`);
            }, 1000);
        };
    } else {
        showInfoBox('没有召唤灵符！');
    }
    updateStampCount(); // 更新印花数量
}

// 点击领取
document.getElementById('claimButton').addEventListener('click', () => {
    if (summonedPet) {
        const petSelect = document.getElementById('pet-select');
        const petKey = Object.keys(pets).find(key => pets[key].name === summonedPet.name);

        if (Array.from(petSelect.options).some(option => option.value === petKey)) {
            showInfoBox(`您已经拥有${summonedPet.name}，将其转化为相应印花！`);
            switch (summonedPet.rank) {
                case 'R':
                    stamps += 300;
                    break;
                case 'SR':
                    stamps += 600;
                    break;
                case 'SSR':
                    stamps += 3600;
                    break;
            }
        } else {
            showInfoBox(`您成功领取了${summonedPet.name}！`);
            const option = document.createElement('option');
            option.value = petKey;
            option.text = summonedPet.name;
            petSelect.appendChild(option);
        }
        summonedPet = null;
        updateStampCount();
        document.getElementById('summonArea').innerHTML = `<div class="stamp-quantity">印花数量: <span id="stampCount">${stamps}</span></div>`;
    } else {
        showInfoBox('没有宠物可领取！');
    }
});

// 点击兑换
document.getElementById('exchangeButton').addEventListener('click', () => {
    if (summonedPet) {
        let exchangeAmount;
        switch (summonedPet.rank) {
            case 'R':
                exchangeAmount = 300;
                break;
            case 'SR':
                exchangeAmount = 600;
                break;
            case 'SSR':
                exchangeAmount = 3600;
                break;
        }
        stamps += exchangeAmount;
        showInfoBox(`${summonedPet.name}已被兑换为${exchangeAmount}印花`);
        summonedPet = null;
        document.getElementById('summonArea').innerHTML = '';
        updateStampCount();
    } else {
        showInfoBox('没有宠物可兑换！');
    }
});

// 打开宠物商店
document.getElementById('openPetShopButton').addEventListener('click', showPetShop);

// 购买召唤灵符
document.getElementById('buySummonCharmButton').addEventListener('click', () => {
    if (stamps >= 500) {
        stamps -= 500;
        addItemToJinnang('summonCharmPaper');
        showInfoBox('成功购买了一张召唤灵符！');
        updateStampCount();
    } else {
        showInfoBox('印花数量不足，无法购买召唤灵符。');
    }
});

function addPetToSelect(petKey, petName) {
    const petSelect = document.getElementById('pet-select');
    
    // 检查宠物是否已经存在于 petSelect 中
    if (Array.from(petSelect.options).some(option => option.value === petKey)) {
        showInfoBox(`${petName} 已经在你的宠物列表中，无法重复获得同一宠物！`, null, null, 'red');
    } else {
        // 添加宠物到 petSelect
        const option = document.createElement('option');
        option.value = petKey;
        option.text = petName;
        petSelect.appendChild(option);
    }
}

// 原有的购买宠物函数
function showPetShop() {
    const petShop = document.getElementById('petShop');
    petShop.style.display = 'block';
    const shopItems = document.getElementById('shopItems');
    shopItems.innerHTML = '';

    const ownedPets = Array.from(document.getElementById('pet-select').options).map(option => option.value);

    const excludedPets = ["金珉奎", "Guolin·Li", "かすがのそら", "结城夏奈"]; // 定义不可购买的宠物名称列表

    Object.keys(pets).forEach(key => {
        const pet = pets[key];

        // 排除已经拥有的宠物和指定名称的宠物
        if (!ownedPets.includes(key) && !excludedPets.includes(pet.name)) {
            let price;
            switch (pet.rank) {
                case 'R':
                    price = 500 * (ownedPets.length);
                    break;
                case 'SR':
                    price = 1000 * (ownedPets.length);
                    break;
                case 'SSR':
                    price = 5000 * (ownedPets.length);
                    break;
            }

            const petDiv = document.createElement('div');
            petDiv.className = 'shop-item';
            petDiv.innerHTML = `
                <img src=${pet.image} alt="${pet.name}" style="border: 1px solid black;height: 45px; width: 45px">
                <div class="item-text-container">
                <div class="item-text-top">${pet.name} (${pet.rank})</div>
                <div class="item-text-bottom">价格: ${price}印花</div>
                </div>
            `;
            petDiv.addEventListener('click', () => {
                showInfoBox(`你确定要花费${price}印花购买${pet.name} (${pet.rank})吗?`, () => {
                    if (stamps >= price) {
                        stamps -= price;
                        showInfoBox(`你购买了${pet.name} (${pet.rank})`);

                        // 调用新函数将宠物添加到 pet-select
                        addPetToSelect(key, pet.name);
                        
                        petDiv.remove(); // 移除已购买的宠物
                        updateStampCount();
                        showPetShop();
                    } else {
                        showInfoBox('印花数量不足!');
                    }
                });
            });
            shopItems.appendChild(petDiv);
        }
    });
}

// 添加关闭按钮功能
document.getElementById('closePetShop').addEventListener('click', () => {
    document.getElementById('petShop').style.display = 'none';
});

function syncBattlePetSelect() {
    const petSelect = document.getElementById('pet-select');
    const battlePetSelect = document.getElementById('battle-pet-select');

    // 清空 battlePetSelect 中的所有选项
    battlePetSelect.innerHTML = '';

    // 将 petSelect 中的所有选项复制到 battlePetSelect
    Array.from(petSelect.options).forEach(option => {
        const newOption = document.createElement('option');
        newOption.value = option.value;
        newOption.text = option.text;
        battlePetSelect.appendChild(newOption);
    });
}

// 测试用例：确保 pets 数组和下拉列表匹配
document.addEventListener('DOMContentLoaded', () => {
    const petSelect = document.getElementById('pet-select');
    const options = Array.from(petSelect.options).map(option => option.value);
    const keys = Object.keys(pets);
    //console.log('Options in select:', options);
    //console.log('Keys in pets:', keys);

});

document.getElementById('buySummonCharmButton').addEventListener('click', () => {
    // 购买逻辑
});

// 添加关闭按钮功能
document.getElementById('closeMissionPanel').addEventListener('click', () => {
    document.getElementById('missionPanel').style.display = 'none';
});



//战斗系统所有全局变量如下
let selectedDrug = null;
let alreadyUseDrug = false;
let drugInventory = {
    "长生泉": { quantity: 2, url: "https://pic.imgdb.cn/item/666c0289d9c307b7e9ae8abd.png", tier: 0, description: "橙色品阶，长生不老之泉，饮用后永久增加5000生命值，且恢复至满状态" },
    "忘忧水": { quantity: 5, url: "https://pic.imgdb.cn/item/666c0afbd9c307b7e9beef9c.png", tier: 3, description: "绿色品阶，每1.5秒恢复1%生命值值，持续3秒，可叠加生效" },
    "三花丸": { quantity: 5, url: "https://pic.imgdb.cn/item/666c0afbd9c307b7e9beefcb.png", tier: 3, description: "绿色品阶，每1.5秒恢复2%法力值，持续3秒，可叠加生效" },
    "狂暴之魂": { quantity: 0, url: "https://pic.imgdb.cn/item/666c1408d9c307b7e9cea2fd.png", tier: 0, description: "橙色品阶，永久提高1%暴击率" },
    "神力仙丹": { quantity: 0, url: "https://pic.imgdb.cn/item/666c1408d9c307b7e9cea310.png", tier: 2, description: "蓝色品阶，20秒内暴击伤害提高50%" },
    "慧心糖果": { quantity: 0, url: "https://pic.imgdb.cn/item/666c1408d9c307b7e9cea328.png", tier: 0, description: "橙色品阶，永久提高1%暴击伤害" },
    "狂暴印记": { quantity: 0, url: "https://pic.imgdb.cn/item/666c1408d9c307b7e9cea34b.png", tier: 2, description: "蓝色品阶，20秒内暴击率提高50%" },
    "武尊秘露": { quantity: 1, url: "https://pic.imgdb.cn/item/666c0afbd9c307b7e9beef97.png", tier: 1, description: "紫色品阶，20秒内增加150%物理攻击力。" },
    "延寿露": { quantity: 0, url: "https://pic.imgdb.cn/item/666d311dd9c307b7e996b5b7.png", tier: 3, description: "绿色品阶，恢复玩家20%的生命值" },
    "天山雪莲": { quantity: 0, url: "https://pic.imgdb.cn/item/666d311dd9c307b7e996b5a8.png", tier: 3, description: "绿色品阶，恢复玩家20%的法力值" },
    "化功散": { quantity: 0, url: "https://pic.imgdb.cn/item/666d311dd9c307b7e996b585.png", tier: 2, description: "蓝色品阶，30秒内邪佞暴击率降低至0%" },
    "见手青": { quantity: 0, url: "https://pic.imgdb.cn/item/666d311dd9c307b7e996b565.png", tier: 0, description: "橙色品阶，投喂敌人后敌人会中毒，能力下降50%，直至本轮胜利" },
    "沉檀凝香": { quantity: 5, url: "https://pic.imgdb.cn/item/666d311dd9c307b7e996b538.png", tier: 1, description: "紫色品阶，恢复10%生命值并有几率清除玩家的异常状态" },
    "焚灵之丸": { quantity: 0, url: "https://pic.imgdb.cn/item/666d311dd9c307b7e996b52a.png", tier: 1, description: "紫色品阶，消耗自身生命值上限20%生命值，20秒内提升50%物理攻击力、法术攻击、暴击率和暴击伤害。生命值不足上限20%时无法使用。" },
    "冰莲絮": { quantity: 2, url: "https://pic.imgdb.cn/item/666d311dd9c307b7e996b4f5.png", tier: 2, description: "蓝色品阶，永久增加2000点生命值" },
    "晗灵果": { quantity: 2, url: "https://pic.imgdb.cn/item/666d311dd9c307b7e996b522.png", tier: 2, description: "蓝色品阶，永久增加2000点法力值" },
    "魔术棱柱": { quantity: 0, url: "https://pic.imgdb.cn/item/666e9aeed9c307b7e90669fa.png", tier: 1, description: "紫色品阶，消耗30000当前经验升级一个随机技能，通过该道具最多可让技能升至24级" },
    "幸运金币": { quantity: 0, url: "https://pic.imgdb.cn/item/666e9aeed9c307b7e9066a20.png", tier: 0, description: "橙色品阶，使用后将随机触发事件：让怪物血量变为1/获得50000经验/回退10轮" },
    "双倍经验药": { quantity: 1, url: "https://pic.imgdb.cn/item/666e9aeed9c307b7e9066a2f.png", tier: 2, description: "蓝色品阶，使用后60秒内战斗获胜所得经验增加两倍" },
    "四倍经验药": { quantity: 1, url: "https://pic.imgdb.cn/item/666e9aeed9c307b7e9066a29.png", tier: 1, description: "紫色品阶，使用后60秒内战斗获胜所得经验增加四倍" },
    "普通药材": { quantity: 0, url: "https://pic.imgdb.cn/item/6699fa28d9c307b7e9ad0b38.png", tier: 4, description: "白色品阶，恢复1000点生命值和法力值，收集3个可以合成1个绿色品阶的药品" },
    "上等药材": { quantity: 0, url: "https://pic.imgdb.cn/item/6699fa28d9c307b7e9ad0b15.png", tier: 3, description: "绿色品阶，永久增加20点速度，收集3个可以合成1个蓝色品阶的药品" },
    "极品药材": { quantity: 0, url: "https://pic.imgdb.cn/item/6699fa28d9c307b7e9ad0b0c.png", tier: 2, description: "蓝色品阶，永久增加500点生命值和法力值，收集3个可以合成1个紫色品阶的药品" },
    "珍贵药材": { quantity: 0, url: "https://pic.imgdb.cn/item/6699fa28d9c307b7e9ad0af3.png", tier: 1, description: "紫色品阶，永久增加100物理防御和法术防御，收集3个可以合成1个橙色品阶的药品" },
    "完美药材": { quantity: 0, url: "https://pic.imgdb.cn/item/669a6459d9c307b7e91b9003.png", tier: 0, description: "橙色品阶，永久增加100点物理攻击和法术攻击，收集2个可以炼制出随机药品" }
};
let collectCost = 100; // 初始采集花费
let activeBuffs = {};
let drugBonus0 = {
    health: 0,
    mana: 0,
    physicalAttack: 0,
    physicalDefense: 0,
    magicAttack: 0,
    magicDefense: 0,
    speed: 0
};
let drugBonus = {
    health: 0,
    mana: 0,
    physicalAttack: 0,
    physicalDefense: 0,
    magicAttack: 0,
    magicDefense: 0,
    speed: 0
};
//飞升技能系统
let ascensionSkill = {
    name: '未开启',
    level: 1,
    effect: '未开启飞升技能'
};
let secondAscensionSkill = {
    name: '未开启',
    level: 1,
    effect: '未开启飞升技能'
};
let ascensionAttributes = {
    health: 0,
    mana: 0,
    physicalAttack: 0,
    physicalDefense: 0,
    magicAttack: 0,
    magicDefense: 0,
    speed: 0
};
const ascensionSkills = {
    attribute: [
        { name: '力劈华山', effect: level => `额外提供${3000 + level * 350}点物理攻击力`, baseValue: 3000, increment: level => level * 350 },
        { name: '慈悲心怀', effect: level => `额外提供${100000 + level * 8000}点生命值和${100000 + level * 8000}点法力值`, baseValue: 100000, increment: level => 8000 * level },
        { name: '势如破竹', effect: level => `额外提供${3000 + 300 * level}点速度和${3000 + 300 * level}点法术攻击力`, baseValue: 3000, increment: level => 300 * level },
        { name: '固若金汤', effect: level => `额外提供${100000 + 5000 * level}点物理防御和${100000 + 5000 * level}点法术防御`, baseValue: 100000, increment: level => 5000 * level },
        { name: '未开启', effect: level => "未开启飞升技能", baseValue: 0, increment: level => level * 0 },
        { name: '被封印的技能', effect: level => "未开启飞升技能", baseValue: 0, increment: level => level * 0 }
    ],
    combat: [
        { name: '魔龙之力', effect: level => `每回合恢复${10 + 1 * level}%的生命值`, baseValue: 10, increment: level => 1 * level },
        { name: '斩龙一式', effect: level => `当邪佞生命值在${87 - 3 * (level - 1)}%以上时，对邪佞的物理攻击伤害增加40%`, baseValue: 90, increment: level => 90 - 3 * (level - 1) },
        { name: '灵魂穿刺', effect: level => `当玩家暴击时,有${10 + 1.5 * level}%概率额外给邪佞附加等同于玩家物理攻击力1000%的伤害。`, baseValue: 10, increment: level => 10 + 1.5 * level},
        { name: '吸血魔刃', effect: level => `当玩家使用物理攻击时，会吸收等同伤害值${11 + 1 * (level - 1)}%的生命值，每级提升1%`, baseValue: 11, increment: level => 11 + 1 * (level - 1) },
        { name: '无我之境', effect: level => `当玩家受击时，有${21 + 1 * (level - 1)}%概率进入无我之境，免受一切伤害。持续时间5秒`, baseValue: 20, increment: level => 20 + 1 * (level - 1) },
        { name: '向死而生', effect: level => `受到致命伤害时，消耗法力值上限${100 - 1 * level}%的法力让自己血量变为1`, baseValue: 100, increment: level => -2 * level },
        { name: '以牙还牙', effect: level => `反弹本次承受伤害的${45 + 2 * level}%~${60 + 2 * level}%`, baseValue: 45, increment: level => 2 * level },
        { name: '铜墙铁壁', effect: level => `承受伤害降低${20 + 1.5 * level}%`, baseValue: 20, increment: level => 1.5 * level },
        { name: '法术精通', effect: level => `每次使用法术攻击时，有${30 + 2 * level}%概率再次施放一次法术伤害`, baseValue: 30, increment: level => 2 * level },
        { name: '天降甘霖', effect: level => `使用治疗时，触发仙气护体的概率增加至50%，并且仙气护体持续时间增加至${6 + 0.1 * level}秒`, baseValue: 6, increment: level => 0.1 * level }
    ],
    settlement: [
        { name: '财源滚滚', effect: level => `战斗胜利后金子奖励额外增加${convertPrice(10000 + 2500 * level)}文`, baseValue: 10000, increment: level => 2500 * level },
        { name: '焉知非福', effect: level => `战斗失败后，下一轮获得持续${3 + 1 * level}秒的仙气护体`, baseValue: 3, increment: level => 1 * level },
        { name: '举一反三', effect: level => `战斗胜利时获得的经验值增加${300 + 50 * level}%`, baseValue: 300, increment: level => 50 * level },
        { name: '金牌调解', effect: level => `战斗失败时不扣除金子，并获得${convertPrice(500 + 500 * level)}文金子的安慰金`, baseValue: 500, increment: level => 500 * level }
    ]
}; //飞升之术技能列表
let reenableAscension = false;
let ascensionEnabled = false;
// 战斗精灵属性
let spiritLevel = 1;
let spiritMultiplier = 1.00;
const maxSpiritLevel = 120;
const minSpiritMultiplier = 0.01;
const maxSpiritMultiplier = 4.15;
let playerTurn = false;
const obj = {
    get enemyTurn() {
        return !playerTurn;  // 每次访问 b 时，返回 a 的取反值
    }
};
let spiritPowerActive = false;
let attributesFetched = false;
let battleState;
let battleInterval;
let battleAttributes; // 用于存储战斗属性的独立容器
let maxHealth, maxMana; // 独立的最大值变量
let battleRounds = 1; // 记录玩家胜利的轮次
let currentExp = 0; // 当前经验值
let maxExp = 208; // 经验值上限
let enemyHealCount = 0; // 记录怪物治疗次数
let enemyPetCultivation;
let playerCultivation;
let additionalPlayerCultivation = 0;
let enemyPet = {
    health: 18,
    mana: 13,
    physicalAttack: 2,
    physicalDefense: 1,
    magicAttack: 2,
    magicDefense: 3,
    speed: 6,
    cultivation: 0
};
let enemyMaxHealth = enemyPet.health;
let enemyMaxMana = enemyPet.mana;
let enemyInitialState = null;
// 全局解控
let originalPerformAttack = performAttack;
let originalPerformPhysicalAttack = performPhysicalAttack;
let originalPerformMagicalAttack = performMagicalAttack;
let originalPerformHeal = performHeal;
let originalPerformPoison = performPoison;
let originalPerformDefense = performDefense;
let autoBattleInterval = null;
let playerCritRate = 0.1; // 10%
let playerCritDamage = 1.5; // 150%
let enemyCritRate = 0.6; // 60%
let enemyCritDamage = 1.8; // 180%
let pierceDamageContainer = {
    totalPierceDamage: 0
};
let poisonSkillActivated = false;
let enemyPhysicalAttackCount = 0; // 在函数外部定义变量怪物杀戮状态下的攻击次数
let extraShield = 0; //额外盾量
let wiseDefense = 0; //此变量用于外部调用该数值并进行显示
let wiseDefenseManaCost; //此变量用于外部调用该数值并进行显示
let firstStartBattle = false;
let onBattleState;
let divinedWeaponStatus = false;
const weaponDescriptions = {
    lostBook: "遗失的洛书开启后，能够为你的物理技能附加专属效果，同时最多拥有3个效果。可以附加效果如下：\n1.破甲：根据物理攻击扣除怪物的物理防御力 \n2.恐吓：持续时间内禁止怪物触发暴击 \n3.眩晕：持续时间内怪物无法动作 \n4.穿透：造成伤害时额外附加物理攻击1/10的穿透伤害，并在持续时间结束后基于穿透伤害总和的一定比例给予怪物余波收尾伤害 \n5.麻痹：根据本次物理伤害减少怪物的血量上限 \n6.惶恐：降低敌人物理攻击力，降低值为自身物理攻击",
    fragmentedMap: "残页的河图开启后，能够为你的法术技能附加专属效果，同时最多拥有3个效果。可以附加效果如下：\n1.迟缓：根据伤害量的比例降低敌人的当前速度 \n2.沉默：持续时间内禁止怪物施放法术技能及附加减益效果 \n3.混乱：持续时间内怪物可能会攻击自己 \n4.灼烧：造成伤害时会给敌人附加额外灼烧伤害，己方速度之于怪物越快，灼烧伤害越猛烈 \n5.法力燃烧：根据本次法术伤害减少怪物的当前法力值，敌人法力为空时，将转化为生命伤害。\n6.法力吸取：吸收敌人的法力为己用，吸收量与所造成法术伤害有关",
    nirvanaGem: "定空的灵石开启后，每秒有概率驱散减益效果，同时最多驱散5个效果。可以驱散效果如下：\n1.醉酒：法术效果，玩家攻击怪物时会受到10%的反弹溅射伤害 \n2.禁疗：法术效果，持续时间内禁止玩家使用治疗技能 \n3.摄魂：法术效果，持续时间内玩家物理和法术攻击减半 \n4.失明：法术效果，持续时间内玩家物理攻击会被怪物闪避 \n5.法术迟钝：法术效果，持续时间内玩家使用法术技能时法力消耗值增至100倍 \n6.撕裂：物理效果，持续时间内玩家会受到每0.5秒的持续掉血效果，掉血量与怪物物理攻击有关 \n7.嘲讽：物理效果，持续时间内玩家的所有战斗行为会强制指向物理攻击，且物理伤害增至120% \n8.压制：物理效果，玩家若没有在3秒内做出战斗行为，血量会降至1 \n9.封印：物理效果，持续时间内玩家的飞升技能会被封印，使其无法生效 \n10.杀戮：物理效果，持续时间内会根据双方修为之差判断斩杀线，当一方血量低于双方修为差值的一定比例时，负值一方会被斩杀"
}; //神器描述列表
const effectCooldowns = {
    drunken: false,
    healingBan: false,
    soulCapture: false,
    blindfold: false,
    spellSlow: false,
    torn: false,
    suppressed: false,
    taunt: false,
    seal: false,
    slaughter:false,
};

function startBattle() {
    if (!attributesFetched) {
        showInfoBox("请先从属性面板获取属性。");
        return;
    }

    onBattleState = true;

    if (!firstStartBattle) {
        logBattleEvent("这里是战斗面板");
        firstStartBattle = true;
    }
    
    // 开始自动触发型事件
    battleInterval = setInterval(() => {
        if (onBattleState) {
            if (battleAttributes.health <= 0) {
                showNextBattlePrompt(false); // 玩家失败，传递失败状态
                return;
            } else if (battleState.enemy.health <= 0) {
                showNextBattlePrompt(true);
                return;
            }
            
            if (summonEnemy) {
                const summonedEnemyName = battleState.enemy.specialty;

                // 从 specificAttackByEnemy 中获取类型和行为
                const enemyAttack = specificAttackByEnemy[summonedEnemyName];

                if (enemyAttack && enemyAttack.type === 'interval') {
                    // 延时性效果：在每次 battleInterval 触发时调用
                    enemyAttack.action();
                }  
            }
            
            updateUI();
            divineWeaponManager.applyNirvanaGemEffects();  
            handleSpiritHeal(); // 精灵治愈
            handleSpiritPower(); // 精灵增益
            handleSpiritAttack(); // 精灵助攻
        } else {
            console.log('尚未开始战斗');
        }
    }, 1000);

    playerTurn = battleAttributes.speed >= battleState.enemy.speed;
    updateUI();
    decideEnemyCanPerform();
    
    if (!playerTurn) {
        setTimeout(enemyAttack, 350);
    }
}

function stopBattle() {
    onBattleState = false;
    stopEnemyAction();
    clearInterval(battleInterval); // 战斗结束，停止定时器
    if (summonEnemy) {
        handleBattleWithSummonEnemy(false);
    }
    logBattleEvent("战斗停止。");
}

let defeatedPets = []; // 记录已阵亡的宠物 { key: 'xiaojin', name: '小金牛' }
let usedPets = []; // 记录所有已出战的宠物 { key: 'xiaojin', name: '小金牛' }

function showNextBattlePrompt(playerWon) {
    if (playerWon) {
        const wonValue = Math.floor(0 + Math.random() * 2);
        decreaseArmsEndurance(key = null, wonValue);
        currentLifeSpan = Math.max(0, currentLifeSpan - wonValue);
        if (!summonEnemy) {
            handleVictory();
            return;
        } else {
            toggleFightingDrawer();
            handleBattleWithSummonEnemy(playerWon);
            summonEnemy = false;
            return;
        }
    } else {
        const failedValue = Math.floor(5 + Math.random() * 5);
        decreaseArmsEndurance(key = null, failedValue);
        currentLifeSpan = Math.max(0, currentLifeSpan - failedValue);
        if (!summonEnemy) {
            handlePetDefeat();
            return;
        } else {
            toggleFightingDrawer();
            handleBattleWithSummonEnemy(false);
            summonEnemy = false;
            return;
        }
    }
}


function handleVictory() {
    // 胜利逻辑
    const minRewardMultiplier = 0.35;
    const maxRewardMultiplier = 1.75;
    const rewardMultiplier = Math.random() * (maxRewardMultiplier - minRewardMultiplier) + minRewardMultiplier;
    let reward = Math.floor(288 * battleRounds * rewardMultiplier);
    reward = Math.max(reward, 288);

    if (ascensionSkill.name === '财源滚滚' || secondAscensionSkill.name === '财源滚滚') {
        reward += calculateExtraReward();
    }

    goldAmount += reward;
    updateGoldDisplay(goldAmount);
    updateTitle();
    logBattleEvent(`您赢得了此次战斗，获得${convertPrice(reward)}金子！进入下一轮战斗！您已经胜利了 ${battleRounds} 轮次`, "pink");
    showBattleOverlay("https://pic.imgdb.cn/item/6672bf9fd9c307b7e9b189e0.png", 500, 1, 1000);
    increaseCurrentPetIntimacy(30);
    increaseCurrentPetAttention(1);
    increaseCurrentPetLearningValue(200);

    defeatedPets = [];
    usedPets = []; 
    battleRounds++;
    updateEnemyAttributes();
    gainExp();
    resetBattleState(true);
    resetBuffState(true);
    extraShield = 0;
    if (battleAttributes.speed >= battleState.enemy.speed) {
        playerTurn = true;
    } else {
        playerTurn = false;
    }
}

function handlePetDefeat() {
    const petSelect = document.getElementById("pet-select");
    const selectedPetKey = petSelect.value;

    const currentPetKey = Object.keys(pets).find(key => pets[key].name === currentPet.name);
    defeatedPets.push({ key: currentPetKey, name: currentPet.name }); // 记录阵亡的宠物

    if (defeatedPets.length === petSelect.options.length) {
        // 所有宠物都已阵亡
        applyDefeatPenalty();
        logBattleEvent('所有宠物都已阵亡，本次战斗已失败！');
        return;
    }

    if (petSelect.options.length > 1) {
        promptPetSwitch(petSelect, selectedPetKey);
    } else {
        applyDefeatPenalty();
        logBattleEvent('没有其他宠物可以更换，本次战斗已失败！');
    }

}

function promptPetSwitch(petSelect, selectedPetKey) {
    showInfoBox(
        `${currentPet.name}已阵亡, 是否更换至其他宠物继续战斗？`,
        () => {
            let newOption;
            let availableOptions = Array.from(petSelect.options)
                .map(option => {
                    const petKey = Object.keys(pets).find(key => pets[key].name === option.value);
                    return { key: petKey, name: option.value };
                })
                .filter(option => !usedPets.some(pet => pet.key === option.key)); // 过滤已出战的宠物

            if (availableOptions.length === 0) {
                // 如果没有可用的宠物，执行失败逻辑
                applyDefeatPenalty();
                logBattleEvent('没有可用的宠物进行更换，本次战斗已失败！');
                return;
            }

            do {
                const randomIndex = Math.floor(Math.random() * availableOptions.length);
                newOption = availableOptions[randomIndex];
            } while (newOption.key === selectedPetKey);

            petSelect.value = newOption.name;
            usedPets.push(newOption); // 记录新选择的宠物
            changePet();
        },
        () => {
            applyDefeatPenalty();
            logBattleEvent('本次战斗已失败！');
        }
    );
}

function applyDefeatPenalty() {
    // 失败惩罚逻辑
    let penalty = 388 * battleRounds;

    if (ascensionSkill.name === '金牌调解' || secondAscensionSkill.name === '金牌调解') {
        penalty = 0;
        goldAmount += calculateCompensation();
    } else {
        goldAmount = Math.max(0, goldAmount - penalty);
    }

    showBattleOverlay("https://pic.imgdb.cn/item/6672bfa5d9c307b7e9b19753.webp", 500, 1, 1000);
    increaseCurrentPetIntimacy(-5);
    onBattleState = false;
    showInfoBox(`您已经输掉此次战斗，扣除金子${convertPrice(penalty)}！点击任意按钮重置战斗！`,
               () => onBattleState = true,
               () => onBattleState = true);
    updateGoldDisplay(goldAmount);
    clearAutoBattle();
    defeatedPets = [];
    usedPets = [];
    resetBattleState(false);
    resetBuffState(false);
    extraShield = 0;
} 

function calculateExtraReward() {
    // 额外奖励计算逻辑
    let extraReward = 0;
    if (ascensionSkill.name === '财源滚滚') {
        extraReward += ascensionSkill.baseValue + ascensionSkill.increment(ascensionSkill.level);
    }
    if (secondAscensionSkill.name === '财源滚滚') {
        extraReward += secondAscensionSkill.baseValue + secondAscensionSkill.increment(secondAscensionSkill.level);
    }
    logBattleEvent(`财源滚滚触发，额外增加了 ${convertPrice(extraReward)} 金子。`, 'pink');
    return extraReward;
}

function calculateCompensation() {
    // 赔偿金计算逻辑
    let compensation = 0;
    if (ascensionSkill.name === '金牌调解') {
        compensation += ascensionSkill.baseValue + ascensionSkill.increment(ascensionSkill.level);
    }
    if (secondAscensionSkill.name === '金牌调解') {
        compensation += secondAscensionSkill.baseValue + secondAscensionSkill.increment(secondAscensionSkill.level);
    }
    logBattleEvent(`金牌调解触发，未扣除金子并获得 ${convertPrice(compensation)} 的安慰金。`, 'pink');
    return compensation;
}


function resetBuffState(playerWon) {
    if (battleState.player.usingBuff) {
        battleState.player.usingBuff = false;
        logBattleEvent(`即时性药品效果已被重置。`, 'red');
        updateUI();
    }

    if (playerWon) {
        const obtainedDrugs = [];
        
        // 获取药品概率
        const drugProbability = Math.random();
        let drugTier;

        if (drugProbability < 0.1) {
            drugTier = 0;
        } else if (drugProbability < 0.29) {
            drugTier = 1;
        } else if (drugProbability < 0.6) {
            drugTier = 2;
        } else {
            drugTier = 3;
        }

        const drugKeys = Object.keys(drugInventory).filter(drug => drugInventory[drug].tier === drugTier);
        const randomDrug = drugKeys[Math.floor(Math.random() * drugKeys.length)];
        drugInventory[randomDrug].quantity += 1;
        obtainedDrugs.push(`${randomDrug} x1`);

        // battleRounds 大于等于 100 时额外掉落药品
        if (battleRounds >= 100) {
            for (let i = 0; i < 2; i++) {
                const extraDrugProbability = Math.random();
                let extraDrugTier;
                
                if (extraDrugProbability < 0.1) {
                    extraDrugTier = 0;
                } else if (extraDrugProbability < 0.29) {
                    extraDrugTier = 1;
                } else if (extraDrugProbability < 0.6) {
                    extraDrugTier = 2;
                } else {
                    extraDrugTier = 3;
                }

                const extraDrugKeys = Object.keys(drugInventory).filter(drug => drugInventory[drug].tier === extraDrugTier);
                const extraRandomDrug = extraDrugKeys[Math.floor(Math.random() * extraDrugKeys.length)];
                drugInventory[extraRandomDrug].quantity += 1;
                obtainedDrugs.push(`${extraRandomDrug} x1`);
            }
        }

        // spiritLevel 在 81 到 100 之间时，额外获取药品的概率
        if (spiritLevel >= 81) {
            let extraProbability = (spiritLevel - 80) * 0.05; // 每提升1级，额外概率增加5%

            // 确保额外概率不会超过100%
            if (extraProbability > 1) {
                extraProbability = 1;
            }

            // 根据额外概率获取额外药品
            if (Math.random() < extraProbability) {
                const extraDrugKeys = Object.keys(drugInventory);
                const extraRandomDrug = extraDrugKeys[Math.floor(Math.random() * extraDrugKeys.length)];
                drugInventory[extraRandomDrug].quantity += 1;
                obtainedDrugs.push(`🧚🏻‍♀️战斗精灵的赐福，你还额外获得了 ${extraRandomDrug} x1`);
            }
        }

        // 记录所有获得的药品
        if (obtainedDrugs.length > 0) {
            const drugMessage = obtainedDrugs.join('， ');
            logBattleEvent(`本轮战斗胜利获得了: ${drugMessage}`, 'pink');
        }

        updateDrugGrid();
    }
}

function gainExp(expToAdd = 0) {
    const enemyLevelElement = document.getElementById('enemy-level');
    const enemyLevel = parseInt(enemyLevelElement.innerText, 10);
    
    let expMultiplier = battleState.player.expMultiplier || 1;

    // 检查并应用举一反三技能的经验值加成
    if (ascensionSkill.name === '举一反三' || secondAscensionSkill.name === '举一反三') {
        let extraExpMultiplier = 0;
        if (ascensionSkill.name === '举一反三') {
            extraExpMultiplier += (ascensionSkill.baseValue + ascensionSkill.increment(ascensionSkill.level)) / 100;
        }
        if (secondAscensionSkill.name === '举一反三') {
            extraExpMultiplier += (secondAscensionSkill.baseValue + secondAscensionSkill.increment(secondAscensionSkill.level)) / 100;
        }
        expMultiplier += extraExpMultiplier;
        logBattleEvent(`举一反三触发，经验值增加了 ${extraExpMultiplier * 100}%。`, "pink");
    }

    // 计算非线性经验值增长，如果expToAdd为0，则使用默认战斗经验值增长
    const gainedExp = expToAdd > 0 
        ? expToAdd 
        : (petLevel >= 180 
            ? Math.floor(Math.random() * (2288 - 1288 + 1) * expMultiplier) + 1288
            : Math.floor(100 + (Math.pow(enemyLevel, 1.1) * 0.85 * enemyLevel) * expMultiplier));

    let totalGainedExp = currentExp + gainedExp;

    while (totalGainedExp >= maxExp) {
        totalGainedExp -= maxExp; // 保存多余的经验值

        // 当宠物等级为200时，不再增长 maxExp，并且退出循环
        if (petLevel === 180) {
            maxExp = 99999999999999999999; // 设置 maxExp 为 99999999999999999999
            logBattleEvent("宠物已达到最高等级，经验值上限被设为最大值。", "pink");
            break; // 退出循环
        }

        // 确定 maxExp 的增量
        let increment;
        if (petLevel < 100 && enemyLevel < 100) {
            increment = Math.floor(Math.random() * (1000 - 600 + 1)) + 600;
        } else if (petLevel >= 101 && petLevel <= 180 && enemyLevel >= 101 && enemyLevel <= 140) {
            increment = Math.floor(Math.random() * (1800 - 1200 + 1)) + 1200;
        } else if (petLevel >= 181 && petLevel <= 200 && enemyLevel >= 141 && enemyLevel <= 150) {
            increment = Math.floor(Math.random() * (3600 - 2000 + 1)) + 2000;
        } else {
            increment = Math.floor(Math.random() * (3600 - 600 + 1)) + 600; // 默认增长规则
        }

        maxExp += increment; // 根据规则增长 maxExp

        if (petLevel < 200) {
            logBattleEvent("恭喜您升级了！", "pink");
            increasePetLevel(1); // 提升宠物一级
        } else {
            logBattleEvent("宠物已达到最高等级，经验转化为普通经验书！", "pink");
            addItemToJinnang('normalExperienceBook');
            updateJinnangItems();
        }
    }

    currentExp = totalGainedExp; // 更新剩余的经验值
    updateExpBar(); // 更新经验条显示
}


        
function updateExpBar() {
  const expBar = document.getElementById('exp-bar');
  const expText = document.getElementById('exp-text');

  // 计算进度条宽度百分比
  const expPercentage = (currentExp / maxExp) * 100;

  // 更新进度条宽度
  expBar.style.width = `${expPercentage}%`;

  // 更新经验值文字
  expText.textContent = `经验值:${currentExp} / ${maxExp}`;
}



function resetBattleState(playerWon) {
    if (!playerWon) {
        restoreEnemyState();
        if (ascensionSkill.name === '焉知非福' || secondAscensionSkill.name === '焉知非福') {
            battleState.player.divineProtection = true;
            const duration = (ascensionSkill.name === '焉知非福' ? (ascensionSkill.baseValue + ascensionSkill.increment(ascensionSkill.level)) : 0) +
                             (secondAscensionSkill.name === '焉知非福' ? (secondAscensionSkill.baseValue + secondAscensionSkill.increment(secondAscensionSkill.level)) : 0);
            logBattleEvent(`焉知非福触发,战斗获得持续 ${duration} 秒的仙气护体。`, "aqua");
            setTimeout(() => {
                battleState.player.divineProtection = false;
                logBattleEvent("焉知非福带来的仙气护体效果消失。", "aqua");
            }, duration * 1000);
        }
    }
    
    if (playerWon && battleRounds === 101 && !summonEnemy) {
        addItemToJinnang('magicPetAmulet', 1);
        showInfoBox('恭喜你战胜了第100轮邪佞，获得了1个灵兽符文！');
    }
    
    if (playerWon && battleRounds === 151 && !summonEnemy) {
        changeEnemyImage("realShape");
        if (autoBattleInterval !== null) {
            clearAutoBattle;
        }
        showInfoBox("你已经成功挑战150轮！你的爱宠经受住了魔王的考验，恭喜你！继续挑战会进入无尽模式。");
    }

    if (battleState.enemy.benumbed) {
        enemyMaxHealth = battleState.enemy.originalMaxHealth || enemyMaxHealth;
        battleState.enemy.benumbed = false;
        battleState.enemy.benumbStack = 0;
        battleState.enemy.originalMaxHealth = undefined;
    }
    
    updateUI();
    storeEnemyInitialState();
    clearEnemyEffect();
    clearPlayerEffect();
    enemyHealCount = 0;
    updatePetInfo();
    resetResurrectionState();
}

function setBackgroundImage(imageUrl) {
    const drawer = document.querySelector('.battle-system-drawer');
    if (drawer) {
        drawer.style.backgroundImage = `url('${imageUrl}')`;
    }
}

function logBattleEvent(event, color = 'white') {
    const logDiv = document.getElementById("log");
    if (logDiv) {
        const newEvent = document.createElement("p");
        newEvent.innerText = event;
        newEvent.style.color = color; // 设置文字颜色
        logDiv.appendChild(newEvent);

        // 检查日志条目数，如果超过 100 条，则删除最早的条目
        const logs = logDiv.getElementsByTagName("p");
        while (logs.length > 100) {
            logDiv.removeChild(logs[0]);
        }

        // 设置滚动条自动滚动到底部
        logDiv.scrollTop = logDiv.scrollHeight;
    } else {
        console.error("logDiv not found");
    }
}

function clearBattleLog() {
    const logDiv = document.getElementById("log");
    if (logDiv) {
        logDiv.innerHTML = ""; // 清除日志内容
    } else {
        console.error("logDiv not found");
    }
}

document.getElementById('battle-log-head').addEventListener('click',() => clearBattleLog());
        
function toggleFightingDrawer() {
    if (!attributesFetched) {
        showInfoBox("请先从属性面板获取属性。");
        return;
    }
    
    if (battleState.player.taunt && !summonEnemy) {
        performAttack('physical');
        return;
    }
    
    const drawer = document.getElementById('fightingDrawer');
    const isOpen = drawer.classList.toggle('open');
    drawer.classList.add("show");  // 触发动画

    if (isOpen) {
        drawer.style.display = "flex";
        startBattle();
        if (!summonEnemy) {
        } else {
            updatePetInfo();
        }
    } else {
        drawer.style.display = "none";
        stopBattle();
    }

    document.getElementById('battleRounds').innerText = battleRounds;
    syncBattlePetSelect();
}

function calculateSkillAttributes() {
    const skillsArea = document.getElementById("skills-area");
    let skillAttributes = {
        health: 0,
        mana: 0,
        physicalAttack: 0,
        physicalDefense: 0,
        magicAttack: 0,
        magicDefense: 0,
        speed: 0
    };

    if (skillsArea && currentPet.skills) {
        const skillDivs = Array.from(skillsArea.children);
        skillDivs.forEach(skillDiv => {
            const skillName = skillDiv.innerText.split(' ')[0];
            const skill = currentPet.skills.find(skill => skill.name === skillName && (skill.type === 'N' || skill.type === 'NE'));
                          
            if (skill) {
                const skillLevel = skill.level || 1;
                const skillMultiplier = Math.max(1, skill.multiplier);
                const levelMultiplier = 0.1 * skillLevel * skillMultiplier;

                const NESkillsAndValue = {
                    "天神祝福": {
                        health: 2000,
                        speed: 200,
                        maxLevel: 6
                    },
                    "天王护卫": {
                        physicalDefense: 500,
                        magicDefense: 500,
                        maxLevel: 6
                    },
                    "姐就是女王" : {
                        health: 10000,
                        maxLevel: 6
                    }
                    // 未来拓展更多...
                };               
                
                if (skill.type === 'N') {
                    skillAttributes.health += Math.round(168 * levelMultiplier);
                    skillAttributes.mana += Math.round(98 * levelMultiplier);
                    skillAttributes.physicalAttack += Math.round(64 * levelMultiplier);
                    skillAttributes.physicalDefense += Math.round(32 * levelMultiplier);
                    skillAttributes.magicAttack += Math.round(63 * levelMultiplier);
                    skillAttributes.magicDefense += Math.round(31 * levelMultiplier);
                    skillAttributes.speed += Math.round(9 * levelMultiplier);
                } else if (skill.type === 'NE') {
                    const neSkill = NESkillsAndValue[skillName];
                    if (neSkill) {
                        const maxLevel = neSkill.maxLevel || skillLevel;
                        const limitedSkillLevel = Math.min(maxLevel, skillLevel);
                        
                        for (const attr in neSkill) {
                            if (attr !== 'maxLevel') {
                                skillAttributes[attr] += neSkill[attr] * limitedSkillLevel;
                            }
                        }
                    }
                }
            }
        });
    }
    return skillAttributes;
}

        
//进入战斗界面更新双方关键信息
function updatePetInfo() {
    if (!currentPet) {
        console.error("currentPet is not initialized");
        return;
    }

    const currentAttributes = calculateCurrentAttributes();
    const totalAttributes = {
        endurance: currentAttributes.endurance,
        intelligence: currentAttributes.intelligence,
        strength: currentAttributes.strength,
        agility: currentAttributes.agility,
        faith: currentAttributes.faith
    };

    const secondaryAttributes = calculateSecondaryAttributes(totalAttributes, currentWisdom);
    const spiritAttributes = getCurrentSpiritAttributes();
    

    if (!battleState) {
        battleState = {
            player: {
                health: secondaryAttributes.health + spiritAttributes.health + ascensionAttributes.health,
                mana: secondaryAttributes.mana + spiritAttributes.mana + ascensionAttributes.mana,
                physicalAttack: secondaryAttributes.physicalAttack + spiritAttributes.physicalAttack + ascensionAttributes.physicalAttack,
                physicalDefense: secondaryAttributes.physicalDefense + spiritAttributes.physicalDefense + ascensionAttributes.physicalDefense,
                magicAttack: secondaryAttributes.magicAttack + spiritAttributes.magicAttack + ascensionAttributes.magicAttack,
                magicDefense: secondaryAttributes.magicDefense + spiritAttributes.magicDefense + ascensionAttributes.magicDefense,
                speed: secondaryAttributes.speed + spiritAttributes.speed + ascensionAttributes.speed
            },
            enemy: { ...enemyPet }
        };
        if (ascensionSkill.name && ascensionEnabled && ascensionSkill.name !== "被封印的技能") {
            battleState.player.originalAscensionSkill = ascensionSkill.name;
        }
        
        if (secondAscensionSkill.name && reenableAscension && secondAscensionSkill.name !== "被封印的技能") {
            battleState.player.originalSecondAscensionSkill = secondAscensionSkill.name;
        }
    } else {
        battleState.player.health = secondaryAttributes.health + spiritAttributes.health + ascensionAttributes.health;
        battleState.player.mana = secondaryAttributes.mana + spiritAttributes.mana + ascensionAttributes.mana;
        battleState.player.physicalAttack = secondaryAttributes.physicalAttack + spiritAttributes.physicalAttack + ascensionAttributes.physicalAttack;
        battleState.player.physicalDefense = secondaryAttributes.physicalDefense + spiritAttributes.physicalDefense + ascensionAttributes.physicalDefense;
        battleState.player.magicAttack = secondaryAttributes.magicAttack + spiritAttributes.magicAttack + ascensionAttributes.magicAttack;
        battleState.player.magicDefense = secondaryAttributes.magicDefense + spiritAttributes.magicDefense + ascensionAttributes.magicDefense;
        battleState.player.speed = secondaryAttributes.speed + spiritAttributes.speed + ascensionAttributes.speed;

        if (ascensionSkill.name && ascensionEnabled && ascensionSkill.name !== "被封印的技能") {
            battleState.player.originalAscensionSkill = ascensionSkill.name;
        }

        if (secondAscensionSkill.name && reenableAscension && ascensionSkill.name !== "被封印的技能") {
            battleState.player.originalSecondAscensionSkill = secondAscensionSkill.name;
        }
    }

    battleAttributes = { ...battleState.player };
    maxHealth = battleAttributes.health;
    maxMana = battleAttributes.mana;

    updateUI();
    attributesFetched = true;
}

// 全局敌人对象数组
let summonEnemy = false;

// 敌人图像信息
const enemyImages = [
    { status: 'default', name: '邪佞', url: 'https://pic.imgdb.cn/item/6678135ed9c307b7e9060dd6.gif' },
    { status: 'rampaged', name: '狂暴的心魔', url: 'https://pic.imgdb.cn/item/669e973ad9c307b7e9381309.gif' },
    { status: 'mao', name: '上古心魔', url: 'https://pic.imgdb.cn/item/66a0d383d9c307b7e93a3779.gif' },
    { status: 'realShape', name: '大渊神真身', url: 'https://pic.imgdb.cn/item/66a616f4d9c307b7e9b24c97.gif' },
    { status: 'darkShape', name: '暗黑大渊神', url: 'https://pic.imgdb.cn/item/66a61b8cd9c307b7e9b71e30.gif' },
    { status: 'practiceEnemy', name: '练习树桩', url: 'https://pic.imgdb.cn/item/665433e8d9c307b7e93ac758.gif' },
    { status: 'practiceEnemyPlus', name: '高级树桩', url: 'https://pic.imgdb.cn/item/665433e8d9c307b7e93ac758.gif' },
    { status: 'ancientEvil', name: '太古魔魂', url: 'https://pic.imgdb.cn/item/66cc999fd9c307b7e9d7ca2a.gif' },
    { status: 'expEnemy', name: '永夜大帝', url: 'https://pic.imgdb.cn/item/66cd62b1d9c307b7e9afcf5b.gif' },
    { status: 'noWorkBoss', name: '無班之魂', url: 'https://pic.imgdb.cn/item/66cdda7cd9c307b7e941d522.gif' },
    { status: 'qiongQi', name: '穷奇', url: 'https://pic.imgdb.cn/item/66d07119d9c307b7e93234a9.gif' },
    { status: 'baiYin', name: '白银VIP怪', url: 'https://pic.imgdb.cn/item/66d5d91ad9c307b7e95066ac.gif' },
    { status: 'stoneDragon', name: '岩龙', url: 'https://pic.imgdb.cn/item/66e6d18fd9c307b7e9c12e52.gif' },
];

// 更改敌人图像的函数
function changeEnemyImage(status) {
    const enemyImage = enemyImages.find(image => image.status === status);

    if (enemyImage) {
        document.getElementById("enemy-image").src = enemyImage.url;
        document.getElementById("enemy-name").innerText = enemyImage.name;
    } else {
        console.error(`Status '${status}' not found in enemyImages.`);
    }
}
        
// 全局敌人信息对象
const enemies = {
    practiceEnemy: {
        name: '练习树桩',
        level: 100,
        health: 5000000000,
        mana: 5000000000,
        physicalAttack: 100,
        physicalDefense: 10000,
        magicAttack: 100,
        magicDefense: 10000,
        speed: 10000,
        cultivation: 240000,
        enemyCritRate: 0.8,
        enemyCritDamage: 2.5,
        backgroundImage: 'https://pic.imgdb.cn/item/66cc8f01d9c307b7e9c6d2e8.png',
        reward: () => gainExp(3000), // 奖励：3000经验值
        rewardMessage: '3000经验值',
        specialty: 'practiceEnemy'
    },
    practiceEnemyPlus: {
        name: '高级练习树桩',
        level: 200,
        health: 5000000000,
        mana: 5000000000,
        physicalAttack: 1000,
        physicalDefense: 100000,
        magicAttack: 1000,
        magicDefense: 100000,
        speed: 60000,
        cultivation: 520000,
        enemyCritRate: 0.8,
        enemyCritDamage: 2.5,
        backgroundImage: 'https://pic.imgdb.cn/item/66cc8f01d9c307b7e9c6d2e8.png',
        reward: () => gainExp(10000), // 奖励：3000经验值
        rewardMessage: '10000经验值',
        specialty: 'practiceEnemyPlus'
    },
    ancientEvil: {
        name: '太古魔魂封印',
        level: 100,
        health: 67160000,
        mana: 2400000,
        physicalAttack: 168000,
        physicalDefense: 999999,
        magicAttack: 5100,
        magicDefense: 999999,
        speed: 3000,
        cultivation: 151800,
        enemyCritRate: 0.01,
        enemyCritDamage: 1000,
        backgroundImage: 'https://pic.imgdb.cn/item/66cc8f01d9c307b7e9c6d2e8.png',
        reward: () => {
            const items = ['cultivationPill500', 'universalCrystal', 'universalKernel'];
            const randomItem = items[Math.floor(Math.random() * items.length)];
            const randomQuantity = Math.floor(Math.random() * 4) + 2; // Math.random() * 6 生成 0-5，+5 后得到 5-10
            const itemMap = {
                'cultivationPill500': '修为灵丹（橙）',
                'universalCrystal': '天空之晶',
                'universalKernel': '天空精华',
            };
            addItemToJinnang(randomItem, randomQuantity);
            showInfoBox(`你获得了${randomQuantity}个${itemMap[randomItem]}，请检查你的背包！`);
        }, // 奖励：随机道具
        rewardMessage: '无',
        specialty: 'ancientEvil'
    },
    expEnemy: {
        name: '永夜大帝',
        level: 200,
        health: 127160000,
        mana: 2400000,
        physicalAttack: 280000,
        physicalDefense: 240000,
        magicAttack: 318000,
        magicDefense: 136200,
        speed: 287000,
        cultivation: 301800,
        enemyCritRate: 0.15,
        enemyCritDamage: 1.8,
        backgroundImage: 'https://pic.imgdb.cn/item/66cd61f8d9c307b7e9af46c0.png',
        reward: () => gainExp(1600000), 
        rewardMessage: '额外经验1600000点',
        specialty: 'expEnemy' // 特殊能力标识符
    },
    noWorkBoss: {
        name: '無班之魂',
        level: 200,
        health: 600,
        mana: 2800000,
        physicalAttack: 2450,
        physicalDefense: 1200,
        magicAttack: 2450,
        magicDefense: 1200,
        speed: 999999,
        cultivation: 9999999,
        enemyCritRate: 1,
        enemyCritDamage: 2.5,
        backgroundImage: 'https://pic.imgdb.cn/item/66cd61f8d9c307b7e9af46c0.png',
        reward: () => addItemToJinnang('angelWings',1), 
        rewardMessage: '天使之翼',
        specialty: 'noWorkBoss' // 特殊能力标识符
    },
    qiongQi: {
        name: '穷奇',
        level: 160,
        health: 38000,
        mana: 12000,
        physicalAttack: 3450,
        physicalDefense: 63600,
        magicAttack: 1128,
        magicDefense: 31250,
        speed: 320000,
        cultivation: 150000,
        enemyCritRate: 0,
        enemyCritDamage: 0,
        backgroundImage: 'https://pic.imgdb.cn/item/66d071cbd9c307b7e9344927.png',
        reward: () => addItemToJinnang('wealthyGemBag', 1),
        rewardMessage: '一个富贵宝石袋',
        specialty: 'qiongQi' // 特殊能力标识符
    },
    baiYin: {
        name: '白银精英怪',
        level: 180,
        health: 100000,
        mana: 20000,
        physicalAttack: 1500,
        physicalDefense: 300,
        magicAttack: 1300,
        magicDefense: 280,
        speed: 2024,
        cultivation: 1024,
        enemyCritRate: 0.5,
        enemyCritDamage: 1.5,
        backgroundImage: 'https://pic.imgdb.cn/item/66d5d9a1d9c307b7e950d6b2.png',
        reward: () => {
            const expGainedRatio = Math.round(petLevel * (5 + Math.random() * 5));
            if (petLevel <= 180) {
                gainExp(expGainedRatio);
            }
            handleBaiYinReward();
        },
        rewardMessage: '无',
        specialty: 'baiYin' // 特殊能力标识符
    },
    stoneDragon: {
        name: '岩龙',
        level: 180,
        health: 3800000000,
        mana: 125000,
        physicalAttack: 3450,
        physicalDefense: 60000,
        magicAttack: 1128,
        magicDefense: 60000,
        speed: 2400,
        cultivation: 471200,
        enemyCritRate: 0.65,
        enemyCritDamage: 3.8,
        backgroundImage: 'https://pic.imgdb.cn/item/66e6d194d9c307b7e9c131d3.png',
        reward: () => {
            generateItemToJinnang('hongHuang', '洪荒至尊仙葫', 'https://pic.imgdb.cn/item/66d0b3f3d9c307b7e995a14c.png', price = 8000, quantity = 1, description = '上古传说中的仙葫，流传久远，极其稀有，打开可获得随机珍稀道具');
            increaseCurrentPetIntimacy(600);
        },
        rewardMessage: '1个珍贵的洪荒至尊仙葫。在这次艰难的对抗中，你的宠物与你并肩作战，好感大增，亲密度增加了600！',
        specialty: 'stoneDragon' // 特殊能力标识符
    }
};
// 定义不同敌人的独特战斗能力
const specificAttackByEnemy = {
    'expEnemy': {
        type: 'interval', // 延时性效果
        action: () => handleExpEnemySkill() //永夜大帝吸血
    },
    'noWorkBoss': {
        type: 'interval', // 延时性效果
        action: () => {
            const manaLost = Math.round(battleAttributes.mana * 0.15);
            battleAttributes.mana -= manaLost;
            battleState.enemy.magicDefense = Math.round(battleAttributes.magicAttack * playerCritDamage);
            battleState.enemy.physicalDefense = Math.round(battleAttributes.physicalDefense * playerCritDamage);
            logBattleEvent(`無班之魂の法术穿透，损失${manaLost}法力值`, 'lightblue');
            handleNoWorkBossSkill(); //概率升级
        }
    },
    'ancientEvil': {
        type: 'interval', // 延时性效果
        action: () => handleAncientEvilSkill() //吸收暴击
    },
    'qiongQi': {
        type: 'instant', // 即时性效果
        action: () => {
            handleQiongQiSkill(); //吸血回防
            handleTaunt();
        }
    },
    'practiceEnemy': {
        type: 'instant',
        action: () => {
            let practiceEnemy;
            practiceEnemy = setTimeout(() => {
                if (summonEnemy && battleState.enemy.specialty === 'practiceEnemy' && onBattleState) {
                    battleState.enemy.physicalAttack += 3000000;
                    battleState.enemy.magicAttack += 3000000;
                    updateUI();
                    showInfoBox('还没死，还得练，再给你上上强度');
                } else {
                    clearTimeout(practiceEnemy);
                }
            },30000);
        }
    },
    'practiceEnemyPlus': {
        type: 'instant',
        action: () => {
            let practiceEnemy;
            practiceEnemy = setTimeout(() => {
                if (summonEnemy && battleState.enemy.specialty === 'practiceEnemyPlus' && onBattleState) {
                    battleState.enemy.health = enemyMaxHealth;
                    updateUI();
                    logBattleEvent('❤️【敌人恢复】加强版树桩恢复了满状态生命值');
                } else {
                    clearTimeout(practiceEnemy);
                }
            },30000);
        }
    },
    'baiYin': {
        type: 'instant',
        action: () => {
            logBattleEvent('战胜后可得到大量经验值和概率获得提升宠物技能的神秘物质', 'gold');
        }
    },
    'stoneDragon': {
        type: 'interval',
        action: () => {
        if (summonEnemy && battleState.enemy.name === '岩龙' && onBattleState) {
            if (battleState.enemy.health >= enemyMaxHealth * 0.2) {
                battleState.enemy.physicalDefense += 60000;
                battleState.enemy.magicDefense += 60000;
                updateUI();
            } else {
                battleState.enemy.physicalAttack += Math.floor(Math.random() * 1500 + 1500);
                if (battleState.player.shocked) {
                    return;
                } else {
                    battleState.player.shocked = true;
                    logBattleEvent('岩龙开始汲取雷电的力量，你被附加了触电效果，每次攻击岩龙将大幅削减你的物理防御和法术防御。', 'grey');
                }
            }
        }
    }
}
};

function applySpecificAttackByEnemy(summonedEnemyName) {
    const attack = specificAttackByEnemy[summonedEnemyName];
    if (attack) {
        if (attack.type === 'interval') {
            // 延时性效果：在每次 battleInterval 触发时调用
            attack.action();
        } else if (attack.type === 'instant') {
            // 即时性效果：立即执行一次
            attack.action();
        }
    } else {
        console.log(`敌人 ${summonedEnemyName} 没有特殊攻击能力`);
    }
}

// 处理召唤敌人战斗结果的函数
function handleBattleWithSummonEnemy(playerWon) {
    if (!battleState.enemyKey || !enemies[battleState.enemyKey]) {
        return;
    }
    
    const enemy = enemies[battleState.enemyKey]; // 获取原始敌人对象
    
    if (playerWon) {
        // 调用敌人的奖励函数
        if (enemy.reward) {
            enemy.reward(); // 执行奖励
            if (enemy.rewardMessage !== '无') {
                showInfoBox(`你击败了${enemy.name}，获得了${enemy.rewardMessage}！`, null, null, 'green');
            }
        } else {
            showInfoBox(`你击败了${enemy.name}，但没有任何奖励。`, null, null, 'yellow');
        }
    } else {
        // 失败处理
        showInfoBox(`你在与${enemy.name}的战斗中失败了，没有获得任何奖励。`, null, null, 'red');
    }

    // 重置战斗状态
    summonEnemy = false;
    resetBattleState(true);
    resetBuffState(false);
    clearEnemyEffect();
    clearPlayerEffect();
    clearAutoBattle();
    restoreEnemyState();
    updateUI();
}

        
// 重构的召唤敌人函数
function summonEnemyByType(enemyType, manuallySummon = true) {
    if (!summonEnemy && attributesFetched) {
        const enemy = enemies[enemyType];
        
        if (enemy) {
            const summonEnemyLogic = () => {
                summonEnemy = true;
                toggleFightingDrawer();
                battleState.enemy = { ...enemy };
                battleState.enemyKey = enemyType;
                
                enemyMaxHealth = enemy.health;
                enemyMaxMana = enemy.mana;
                enemyPetCultivation = enemy.cultivation;
                enemyCritRate = enemy.enemyCritRate;
                enemyCritDamage = enemy.enemyCritDamage;

                changeEnemyImage(enemyType);
                setBackgroundImage(enemy.backgroundImage);
                document.getElementById('enemy-level').innerText = enemy.level;
                updateUI();
                storeSummonEnemyInitialState();

                // 如果敌人类型为 'instant'，立即执行一次特殊攻击
                const enemyAttack = specificAttackByEnemy[enemy.specialty];

                if (enemyAttack && enemyAttack.type === 'instant') {
                    enemyAttack.action();
                }
            };

            if (manuallySummon) {
                showInfoBox(
                    `你将会召唤${enemy.name}，战胜后你会获得奖励`,
                    summonEnemyLogic,
                    () => {
                        summonEnemy = false;
                        goldAmount -= 20000;
                        updateGoldDisplay(goldAmount);
                        showInfoBox('你仓皇逃跑中，损失了20两金', null, null, 'red');
                        return;
                    }
                );
            } else {
                summonEnemyLogic();
            }
        } else {
            showInfoBox('未知的敌人类型', null, null, 'red');
        }
    } else {
        showInfoBox('正在战斗中或未知错误', null, null, 'red');
    }
} 
                
function handleBaiYinReward() {
    const chance = getRandomInt(1,100);
    if (chance <= 50) {
        generateItemToJinnang('universalAsh','宇宙之尘','https://pic.imgdb.cn/item/66d5dd07d9c307b7e953e4e1.png',price = 10, quantity = 1, description = '击败白银之地怪物的嘉奖，收集一定数量可兑换宇宙之晶');
        showInfoBox('你获得一个宇宙之尘',null,null,null,'https://pic.imgdb.cn/item/66d5dd07d9c307b7e953e4e1.png');
    } else if (chance <= 90) {
        addItemToJinnang('gemLuckyBag',1);
        showInfoBox('你获得一个盲盒宝石袋',null,null,null,'https://pic.imgdb.cn/item/66db2daed9c307b7e9c7508a.png');
    } else {
        addItemToJinnang('universalCrystal',1);
        showInfoBox('你获得一个宇宙之晶',null,null,null,'https://pic.imgdb.cn/item/66cc940cd9c307b7e9cb752e.png');
    }
}

let baiYinInterval = null;  // 在外部作用域定义
function handleBattleWithBaiYin() {
    if (baiYinInterval !== null) {
        showInfoBox('试炼之地正在持续中！无法叠加！',null,null,'red');
        return;
    }
    showInfoBox('试炼之地开始！持续60秒，期间会自动开始战斗，请勿执行其他操作以免造成崩溃！',null,null,'red');

    if (!onBattleState && !summonEnemy) {
        baiYinInterval = setInterval(() => {
            summonEnemyByType('baiYin', false);
            addItemToJinnang('hailMonsterPill',1);
            autoBattle();
        }, 1000);
    } else {
        clearInterval(baiYinInterval);
        baiYinInterval = null;  // 清除后将其重置为 null
    }
}
        
function handleExpEnemySkill() {
    const healthLost = Math.round(battleAttributes.health * 0.1);
    battleAttributes.health -= healthLost;
    battleState.enemy.health += healthLost * 10;

    battleAttributes.physicalDefense = 1;
    battleAttributes.magicDefense = 1;
    
    logBattleEvent(`永夜大帝の吸血魔刃，破坏了你的护甲且吸取了你${healthLost}生命值`, 'red');
    updateUI();
}
        

let qiongQi = null;  // 确保 qiongQi 变量在全局范围内定义

function handleQiongQiSkill() {
    // 检查当前敌人的 specialty 是否为 'qiongQi'
    const isQiongQiName = battleState.enemy.specialty === 'qiongQi';
    
    // 计算损失的生命值和临时护盾
    const healthLost = Math.round(battleAttributes.health * (0.01 + Math.random() * 0.02));
    let temporaryShield = Math.round(healthLost * playerCritDamage);

    battleAttributes.physicalAttack *= 0.01;
    battleAttributes.magicAttack *= 0.01;
    
    // 清除现有定时器，防止重复运行
    if (qiongQi !== null) {
        clearInterval(qiongQi);
        qiongQi = null;
    }

    if (summonEnemy && isQiongQiName) {
        // 设置高防御值
        battleState.enemy.physicalDefense = 999999999999;
        battleState.enemy.magicDefense = 999999999999;

        // 创建定时器并延迟2秒启动
        setTimeout(() => {
            battleState.enemy.physicalDefense = battleAttributes.physicalAttack * 100;
            battleState.enemy.magicDefense = battleAttributes.magicAttack * 100;

            qiongQi = setInterval(() => {
                battleAttributes.health -= healthLost;
                enemyMaxHealth += healthLost;
                battleState.enemy.health += healthLost;
                battleState.enemy.physicalDefense += temporaryShield;
                battleState.enemy.magicDefense += temporaryShield;

                enemyPetCultivation = playerCultivation + 24000;
                battleState.enemy.speed = battleAttributes.speed + 2400;

                // 更新UI和记录战斗事件
                updateUI();

                // 结束条件：玩家死亡、敌人死亡或 summonEnemy 变为 false
                if (battleAttributes.health <= 0 || battleState.enemy.health <= 0 || !summonEnemy) {
                    clearInterval(qiongQi);
                    qiongQi = null; // 防止后续错误
                }
            }, 1000);
        }, 3000);
        logBattleEvent('穷奇擅长吸收敌人的生命之力转换为自己的护甲', 'gold');
    } else {
        // 如果条件不满足，确保定时器不会运行
        if (qiongQi !== null) {
            clearInterval(qiongQi);
            qiongQi = null;
        }
    }
}

//此函数为洪荒至尊仙葫开启逻辑
function openHongHuangTreasure() {
    const treasure = [
        { displayName: '资质仙丹礼包*2', name: 'qualityEnhancePillPKG', quantity: 2, chance: 5 },
        { displayName: '集中值（4点）*10', name: 'attentionValue', quantity: 10, chance: 5 },
        { displayName: '灵兽悟道书', name: 'learningValueBook', quantity: 1, chance: 5 },
        { displayName: '灵兽清心丹', name: 'resetAdvancementPill', quantity: 1, chance: 5 },
        { displayName: '琼浆玉露', name: 'spiritWine', quantity: 1, chance: 5 },
        { displayName: '背包扩容卡', name: 'enlargeCapacityCard', quantity: 2.5, chance: 5 },
        { displayName: '经商积分卡', name: 'merchantPointsCard', quantity: 1, chance: 5 },
        { displayName: '天地灵气*100', name: 'earthlyEnergy', quantity: 100, chance: 6.5 },
        { displayName: '锻造工具', name: 'forgeTool', quantity: 1, chance: 5 },
        { displayName: '修为灵丹（橙）*6', name: 'cultivationPill500', quantity: 6, chance: 5 },
        { displayName: '高级神兽丹', name: 'advancedSkillPill', quantity: 1, chance: 5 },
        { displayName: '灵兽符文', name: 'magicPetAmulet', quantity: 1, chance: 5 },
        { displayName: '一等分解符*2', name: 'firstFragments', quantity: 2, chance: 5 },
        { displayName: '蓝色武装原料*5', name: 'blueArmComponents', quantity: 5, chance: 4.9 },
        { displayName: '神圣天赋赐福', name: 'talentedBless', quantity: 1, chance: 1, specialAction: () => generateItemToJinnang('talentedBless', '神圣天赋赐福', 'https://pic.imgdb.cn/item/66e00000d9c307b7e9d4ecb6.png', 24500, 1, '神圣的天赋加成术，可以立即获得一个当前宠物可用的技能加成')  },
        { displayName: '小金锭', name: 'tinyGoldBlock', quantity: 1, chance: 4, specialAction: () => generateItemToJinnang('tinyGoldBlock', '小金锭', 'https://pic.imgdb.cn/item/66d6ef10d9c307b7e98acf88.png', 8000000, 1, '贵重的金属，卖掉能值不少钱，你也可以点击直接使用进行市场竞价') },
        { displayName: 'そら召唤卡', name: 'qiongmeiCard', quantity: 1, chance: 0.1 },
        { displayName: '天使之翼', name: 'angelWings', quantity: 1, chance: 5 },
        { displayName: '庆典蛋糕', name: 'celebrationCake', quantity: 1, chance: 5 },
        { displayName: '白银VIP包裹', name: 'baiYinPKG', quantity: 1, chance: 5 },
        { displayName: '穿越时光套餐', name: 'backToOne', quantity: 1, chance: 4 },
        { displayName: '六级淡紫色灵石', name: 'purpleSixthGem', quantity: 1, chance: 3, specialAction: () => generateItemToJinnang('purpleSixthGem', '六级淡紫色灵石', 'https://pic.imgdb.cn/item/66d9e814d9c307b7e93afc21.png', 500, 1, '尚未开光的灵石，使用后可得到一颗随机的6级淡紫色宝石') },
        { displayName: '六级粉红色灵石', name: 'pinkSixthGem', quantity: 1, chance: 3, specialAction: () => generateItemToJinnang('pinkSixthGem', '六级粉红色灵石', 'https://pic.imgdb.cn/item/66d9e814d9c307b7e93afc0d.png', 500, 1, '尚未开光的灵石，使用后可得到一颗随机的6级粉红色宝石') }
    ];

    const totalChance = treasure.reduce((sum, item) => sum + item.chance, 0);
    let randomChance = Math.random() * totalChance;

    for (let item of treasure) {
        if (randomChance < item.chance) {
            setTimeout(() => {
                // 执行特殊道具的生成逻辑（如果有）
                if (item.specialAction) {
                    item.specialAction();
                } else {
                    // 普通道具生成
                    addItemToJinnang(item.name, item.quantity);
                }

                // 查找对应奖品的图片 URL
                const matchedItem = jinnangItems.find(jItem => jItem.name === item.name);
                const imageUrl = matchedItem ? matchedItem.url : null;

                // 显示获得的信息
                showInfoBox(`你获得了: ${item.displayName}`, null, null, 'red', imageUrl);
            }, 200);
            break;
        }
        randomChance -= item.chance;
    }
}

        
function handleNoWorkBossSkill() {
    // 生成一个随机数，如果小于0.8，则退出函数
    if (Math.random() < 0.8) {
        return;
    }

    // 获取敌人的等级元素并将其值转换为整数
    const enemyLevelElement = document.getElementById('enemy-level');
    const enemyLevel = parseInt(enemyLevelElement.innerText, 10);

    // 增加敌人的等级
    const newEnemyLevel = enemyLevel + 200;
    enemyLevelElement.innerText = newEnemyLevel;

    // 记录事件日志
    logBattleEvent('無班之魂变得恼怒，等级提升了', 'red');
}

        
function handleAncientEvilSkill() {
    // 确保 battleState.player.damageLost 被正确初始化
    if (typeof battleState.player.damageLost === 'undefined') {
        battleState.player.damageLost = false;
    }

    // 检查是否已经触发了该技能
    if (battleState.player.damageLost) {
        return;
    }

    // 保存原始暴击伤害值
    const originalPlayerCritDamage = playerCritDamage;
    const originalEnemyCritDamage = enemyCritDamage;

    // 调整暴击伤害值
    playerCritDamage = originalPlayerCritDamage * 0.5;
    enemyCritDamage += originalPlayerCritDamage * 0.5;
    battleState.player.damageLost = true;

    // 10秒后恢复原始暴击伤害值
    setTimeout(() => {
        battleState.player.damageLost = false;
        playerCritDamage = originalPlayerCritDamage;
        enemyCritDamage = originalEnemyCritDamage;
        updateUI();
    }, 10000);

    // 记录事件
    logBattleEvent('太古魔魂会吸收你的暴击伤害作为己用', 'lightblue');
}


        
function initializeEnemyPet() {
    enemyPet = {
        health: 13,
        mana: 7,
        physicalAttack: 9,
        physicalDefense: 3,
        magicAttack: 5,
        magicDefense: 1,
        speed: 7,
        cultivation: 12
    };

    enemyMaxHealth = enemyPet.health;
    enemyMaxMana = enemyPet.mana;
    enemyPetCultivation = enemyPet.cultivation;

    if (battleState) {
        battleState.enemy = { ...enemyPet };
    }
    storeEnemyInitialState();
}

//这是固定挑战怪物
function updateEnemyAttributes() {
    const maxValues = {
        health: 300000000,
        mana: 150000000,
        physicalAttack: 340000,
        physicalDefense: 230000,
        magicAttack: 270000,
        magicDefense: 230000,
        speed: 64000,
        cultivation: 520000
    };

    const increasePerRoundAfter150 = {
        health: 50000,
        mana: 32000,
        physicalAttack: 180,
        physicalDefense: 300,
        magicAttack: 110,
        magicDefense: 300,
        speed: 20,
        cultivation: 60
    };

    function calculateAttributeValue(attribute, initialValue) {
        let newValue = 0;

        if (battleRounds <= 45) {
            // 1-10轮，每轮固定增加 300 * battleRounds
            const randomMultiplier = Math.floor(Math.random() * 50) + 1 + battleRounds;
            newValue = initialValue + (7 * randomMultiplier);
        } else if (battleRounds <= 70) {
            // 11-30轮，每轮固定增加 1588 * battleRounds
            const randomMultiplier = Math.floor(Math.random() * 60) + 1 + battleRounds;
            newValue = initialValue + (8 * randomMultiplier);
        } else if (battleRounds <= 80) {
            // 31-60轮，每轮固定增加 9000 * battleRounds
            const randomMultiplier = Math.floor(Math.random() * 100) + 1 + battleRounds;
            newValue = initialValue + (16 * randomMultiplier);
        } else if (battleRounds <= 90) {
            // 61-80轮，增长为 maxValue * (0.0001 ~ 0.0003) * battleRounds 的随机值
            const multiplier = 0.0003 + Math.random() * 0.0006;
            newValue = initialValue + maxValues[attribute] * multiplier;
        } else if (battleRounds <= 99) {
            // 81-99轮，增长为 maxValue * (0.0003 ~ 0.0005) * battleRounds 的随机值
            const multiplier = 0.0006 + Math.random() * 0.0012;
            newValue = initialValue + maxValues[attribute] * multiplier;
        } else if (battleRounds === 100) {
            // 100轮，等同 maxValue * 0.1
            newValue = maxValues[attribute] * 0.1;
        } else if (battleRounds <= 149) {
            // 101-149轮，增长等同于 (maxValue - maxValueAt100) / 150 * battleRounds
            const maxValueAt100 = maxValues[attribute] * 0.1;
            const increasePerRound = (maxValues[attribute] - maxValueAt100) / 150;
            newValue = increasePerRound * battleRounds;
        } else if (battleRounds === 150) {
            // 150轮，等同 maxValue
            newValue = maxValues[attribute];
        } else {
            // 150轮之后，按现有逻辑增长
            const maxValueAt150 = maxValues[attribute];
            const roundsAfter150 = battleRounds - 150;
            const randomMultiplier = Math.floor(Math.random() * (150 - 2 + 1)) + 2;
            const increaseAfter150 = roundsAfter150 * (increasePerRoundAfter150[attribute] * randomMultiplier);
            newValue = maxValueAt150 + increaseAfter150;
        }
        
        if (battleRounds <= 150) {
            newValue = Math.min(newValue, maxValues[attribute]);
        }

        return newValue;
    }
    
    if (!battleState.enemy.rampaged) {
        enemyCritRate = Math.random() * (0.99) + 0.01;  // 生成 [0.01, 1) 之间的随机值
        enemyCritDamage = Math.random() * (1.5) + 1.5;  // 生成 [1.5, 3) 之间的随机值
    }

    enemyPet.health = Math.round(calculateAttributeValue('health', enemyPet.health));
    enemyPet.mana = Math.round(calculateAttributeValue('mana', enemyPet.mana));
    enemyPet.physicalAttack = Math.round(calculateAttributeValue('physicalAttack', enemyPet.physicalAttack));
    enemyPet.physicalDefense = Math.round(calculateAttributeValue('physicalDefense', enemyPet.physicalDefense));
    enemyPet.magicAttack = Math.round(calculateAttributeValue('magicAttack', enemyPet.magicAttack));
    enemyPet.magicDefense = Math.round(calculateAttributeValue('magicDefense', enemyPet.magicDefense));
    enemyPet.speed = Math.round(calculateAttributeValue('speed', enemyPet.speed));
    enemyPet.cultivation = Math.round(calculateAttributeValue('cultivation', enemyPet.cultivation));

    enemyMaxHealth = enemyPet.health;
    enemyMaxMana = enemyPet.mana;
    enemyPetCultivation = enemyPet.cultivation;

    battleState.enemy = { ...enemyPet };
    storeEnemyInitialState();
    enemyLevel = battleRounds;
    document.getElementById('enemy-level').innerText = enemyLevel;
    handleRampaged();
}


function storeEnemyInitialState() {
    enemyInitialState = JSON.parse(JSON.stringify(enemyPet));
}

function restoreEnemyState() {
    if (enemyInitialState) {
        enemyPet = JSON.parse(JSON.stringify(enemyInitialState));
        enemyMaxHealth = enemyPet.health;
        enemyMaxMana = enemyPet.mana;
        enemyPetCultivation = enemyPet.cultivation;
        battleState.enemy = { ...enemyPet };
        clearPlayerEffect();
        enemyLevel = battleRounds;
        document.getElementById('enemy-level').innerText = enemyLevel;
    }
}

function storeSummonEnemyInitialState() {
    if (summonEnemy) summonEnemyInitialState = JSON.parse(JSON.stringify(battleState.enemy));
}

function restoreSummonEnemyState() {
    if (summonEnemyInitialState) {
        enemyPet = JSON.parse(JSON.stringify(enemyInitialState));
        enemyMaxHealth = enemyPet.health;
        enemyMaxMana = enemyPet.mana;
        enemyPetCultivation = enemyPet.cultivation;
        battleState.enemy = { ...enemyPet };
        clearPlayerEffect();
        enemyLevel = battleRounds;
        document.getElementById('enemy-level').innerText = enemyLevel;
    }
}//暂不启用

function getEnemyStatus() {
    let status = [];
    if (!playerTurn) status.push("⚔️");
    if (battleState.enemy.rampaged) status.push("狂暴");
    if (enemyRivival) status.push("复活中");
    if (battleState.enemy.armorBreak) status.push("破甲");
    if (battleState.enemy.weaken) status.push("虚弱");
    if (battleState.enemy.wounded) status.push("重伤");
    if (battleState.enemy.bleeding) status.push("流血");
    if (battleState.enemy.corrode) status.push("腐蚀");
    if (battleState.enemy.sleep) status.push("沉睡");
    if (battleState.enemy.pierced) status.push("穿透");
    if (battleState.enemy.silenced) status.push("沉默");
    if (battleState.enemy.poisoned) status.push("中毒");
    if (battleState.enemy.stunned) status.push("眩晕");
    if (battleState.enemy.intimidated) status.push("恐吓");
    if (battleState.enemy.terrified) status.push("惶恐");
    if (battleState.enemy.benumbed) status.push("麻痹");
    if (battleState.enemy.dazed) status.push("混乱");
    if (battleState.enemy.burnt) status.push("灼烧");
    if (battleState.enemy.slow) status.push("迟缓");
    // Exorcise doesn't need a status as it's an immediate effect, not a lasting status.
    return status.join(", ");
}

function updateEnemyStatusDisplay() {
    const statusElement = document.getElementById('enemy-status');
    if (statusElement) {
        statusElement.innerText = getEnemyStatus();
    } 
}

function getPlayerStatus() {
    let status = [];
    if (playerTurn) status.push("⚔️");
    if (battleState.player.defensing) status.push("蓄力中");
    if (battleState.player.shocked) status.push("触电");
    if (battleState.player.shielded) status.push("护盾");
    if (battleState.player.hidden) status.push("隐身");
    if (battleState.player.reflecting) status.push("反弹伤害");
    if (battleState.player.healing) status.push("持续回血");
    if (battleState.player.beiming) status.push("北冥");
    if (battleState.player.spiritPowerActive) status.push("Blessing!");
    if (battleState.player.divineProtection) status.push("仙气护体");
    if (battleState.player.drunken) status.push("醉酒");
    if (battleState.player.torn) status.push("撕裂");
    if (battleState.player.suppressed) status.push("压制");
    if (battleState.player.taunt) status.push("嘲讽");
    if (battleState.player.seal) status.push("封印");
    if (battleState.player.slaughter) status.push("杀戮");
    if (battleState.player.healingBan) status.push("禁疗");
    if (battleState.player.soulCapture) status.push("摄魂");
    if (battleState.player.blindfold) status.push("失明");
    if (battleState.player.spellSlow) status.push("法术迟钝");
    return status.join(", ");
}

function updatePlayerStatusDisplay() {
    const statusElement = document.getElementById('player-status');
    if (statusElement) {
        statusElement.innerText = getPlayerStatus();
    }
}



function showEffect(effectId, imageUrl) {
    const effect = document.getElementById(effectId);
    effect.style.backgroundImage = `url(${imageUrl})`;
    effect.classList.add('show-effect');
    setTimeout(() => {
        effect.classList.remove('show-effect');
        effect.style.backgroundImage = ''; // 移除背景图，避免残留
    }, 350); // 显示0.35秒
} //展示战斗中技能特效

function updateUI() {
    // 更新玩家的生命值和法力值
    const yourPetHealthElement = document.getElementById("your-pet-health");
    const yourPetMaxHealthElement = document.getElementById("your-pet-max-health");
    const yourPetManaElement = document.getElementById("your-pet-mana");
    const yourPetMaxManaElement = document.getElementById("your-pet-max-mana");

    yourPetHealthElement.innerText = battleAttributes.health;
    yourPetMaxHealthElement.innerText = maxHealth;
    yourPetManaElement.innerText = battleAttributes.mana;
    yourPetMaxManaElement.innerText = maxMana;

    yourPetHealthElement.classList.add("gold-text");
    yourPetMaxHealthElement.classList.add("gold-text");
    yourPetManaElement.classList.add("blue-text");
    yourPetMaxManaElement.classList.add("blue-text");

    // 更新邪佞的生命值和法力值
    const enemyPetHealthElement = document.getElementById("enemy-pet-health");
    const enemyMaxHealthElement = document.getElementById("enemy-max-health");
    const enemyPetManaElement = document.getElementById("enemy-pet-mana");
    const enemyMaxManaElement = document.getElementById("enemy-max-mana");

    enemyPetHealthElement.innerText = battleState.enemy.health;
    enemyMaxHealthElement.innerText = enemyMaxHealth;
    enemyPetManaElement.innerText = battleState.enemy.mana;
    enemyMaxManaElement.innerText = enemyMaxMana;

    enemyPetHealthElement.classList.add("gold-text");
    enemyMaxHealthElement.classList.add("gold-text");
    enemyPetManaElement.classList.add("blue-text");
    enemyMaxManaElement.classList.add("blue-text");

    // 更新其他属性
    document.getElementById("your-pet-physical-attack").innerText = battleAttributes.physicalAttack;
    document.getElementById("your-pet-physical-defense").innerText = battleAttributes.physicalDefense;
    document.getElementById("your-pet-magic-attack").innerText = battleAttributes.magicAttack;
    document.getElementById("your-pet-magic-defense").innerText = battleAttributes.magicDefense;
    document.getElementById("your-pet-speed").innerText = battleAttributes.speed;
    document.getElementById("your-pet-cultivation").innerText = playerCultivation; //玩家修为
    document.getElementById("player-cultivation").innerText = playerCultivation;

    document.getElementById("enemy-pet-physical-attack").innerText = battleState.enemy.physicalAttack;
    document.getElementById("enemy-pet-physical-defense").innerText = battleState.enemy.physicalDefense;
    document.getElementById("enemy-pet-magic-attack").innerText = battleState.enemy.magicAttack;
    document.getElementById("enemy-pet-magic-defense").innerText = battleState.enemy.magicDefense;
    document.getElementById("enemy-pet-speed").innerText = battleState.enemy.speed;
    
    //更新敌人修为显示
    const enemyPetCultivationElement = document.getElementById("enemy-pet-cultivation");
    enemyPetCultivationElement.innerText = battleState.enemy.cultivation;

    // 更新暴击率和暴击伤害
    document.getElementById("player-crit-rate").innerText = Math.round(playerCritRate * 100) + '%';
    document.getElementById("player-crit-damage").innerText = Math.round(playerCritDamage * 100) + '%';
    document.getElementById("enemy-crit-rate").innerText = Math.round(enemyCritRate * 100) + '%';
    document.getElementById("enemy-crit-damage").innerText = Math.round(enemyCritDamage * 100) + '%';
    
    // 更新状态显示
    updatePlayerStatusDisplay();
    updateEnemyStatusDisplay();
    updatePetLevel();
    getShieldStatus();
    updateHealthAndManaDisplay();
    calculateAndDisplayDodgeRate();
    document.getElementById('battleRounds').innerText = battleRounds;
}

document.getElementById('secondary-attributes-panel').addEventListener('click', () => {
    if (!attributesFetched) {
        showInfoBox("请先从属性面板获取属性。");
        return;
    }
    const skillAttributes = calculateSkillAttributes();
    const nameMap = new Map([
        ['health', '生命值'],
        ['magicAttack', '法术攻击'],
        ['magicDefense', '法术防御'],
        ['mana', '法力值'],
        ['physicalAttack', '物理攻击'],
        ['physicalDefense', '物理防御'],
        ['speed', '速度']
    ]);

    let skillAttributesMessage = '';

    for (const [key, value] of Object.entries(skillAttributes)) {
        const displayName = nameMap.get(key) || key; // 如果没有匹配到替换的名称，则使用原始英文名
        skillAttributesMessage += `${displayName}: ${value}\n`;
    }

    showInfoBox(`\n1. 二级属性主要由各一级属性（耐力、智力等）决定 \n2. 被动技能的数量和等级也会增加二级属性 \n3.药材、五行符可以提供额外属性 \n4.精灵和飞升技能提供的属性为战斗属性，脱离战斗状态时将会复位 \n5. 当前技能加成为： \n\n ${skillAttributesMessage} \n6. 生命值是玩家受到伤害时会扣除的值，战斗过程中玩家的血量会每秒按照上线比例进行减少 \n7. 法力值是玩家使用技能时的必要消耗数值 \n8. 物理攻击决定物理类技能的伤害基础 \n9. 物理防御决定玩家对敌人物理技能的减伤效果，请注意，减伤效果并不是线性增加的，当防御数值达到临界值后，减伤效果的增长将会变缓（下同法术防御） \n10. 法术攻击决定玩家的法术伤害类技能的强度，同时决定了玩家的治疗能力和施毒能力 \n11. 法术防御决定了玩家抵抗敌人法术伤害的减伤效果 \n12.速度决定战斗开始时的出手先后顺序，同时也决定了物理闪避率（根据双方速度之差判断闪避概率）`)
});//点击二级属性面板弹出相关信息
        
function updateHealthAndManaDisplay() {
    updateDisplay('your-pet-health', 'your-pet-max-health', 'health', 20, '#cc0000');
    updateDisplay('your-pet-mana', 'your-pet-max-mana', 'mana', 10, '#0066ff');
    updateDisplay('enemy-pet-health', 'enemy-max-health', 'health', 20, '#cc0000');
    updateDisplay('enemy-pet-mana', 'enemy-max-mana', 'mana', 10, '#0066ff');
}

function updateDisplay(currentId, maxId, type, warningThreshold, warningColor) {
    const currentElement = document.getElementById(currentId);
    const maxElement = document.getElementById(maxId);

    const currentValue = parseInt(currentElement.innerText);
    const maxValue = parseInt(maxElement.innerText);

    const percentage = (currentValue / maxValue) * 100;

    let gradientColor;
    if (type === 'health') {
        if (currentId === 'your-pet-health' && extraShield !== 0) {
            gradientColor = 'linear-gradient(to bottom, #477AD6, #8FF1FD, #477AD6)';
        } else {
            gradientColor = 'linear-gradient(to bottom, #7E2723, #9F322C, #CB5D5A, #CB5D5A, #9F322C, #7E2723)';
        }
    } else if (type === 'mana') {
        gradientColor = 'linear-gradient(to bottom, #394F89, #405CB2, #5C81EE, #5C81EE, #405CB2, #394F89)';
    }

    currentElement.innerHTML = `
    <div style="z-index:1000;">
        <div style="width: 100%; background-color: #35472C; overflow: hidden; position: relative; border: 1px solid black;">
            <div id="${currentId}-bar" style="width: ${percentage}%; height: 100%; background: ${gradientColor}; text-align: center; color: white; font-size: 12px; font-weight: bold; transition: width 0.5s ease-in-out;">
                <span style="text-stroke: 1px black;">${currentValue}/${maxValue}</span>
            </div>
            ${percentage < warningThreshold ? `
                <div id="${currentId}-warning" style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; border: 1px solid ${warningColor}; animation: warning-blink 1s infinite;"></div>
            ` : ''}
        </div>
    </div>
    `;

    maxElement.style.display = 'none';
}

let damageRatio = 1;
//总伤害计算函数
function calculateDamage(baseDamage, isCritical, critDamage ,playerEffect = false) {
    if (isCritical) {
        baseDamage = Math.floor(baseDamage * critDamage);
    }
    
    if (playerEffect) {
        baseDamage *= Math.floor(Math.max(0, damageRatio));
    }
    
    return baseDamage;
}
        
function checkCriticalHit(critRate) {
    return Math.random() < critRate;
}

function calculateAndDisplayDodgeRate() {
    let speedDifference;
    let cultivationDifference;

    let playerPhysicalDodgeElement = document.getElementById('player-physical-dodge-rate');
    let playerMagicDodgeElement = document.getElementById('player-magic-dodge-rate');
    let enemyPhysicalDodgeElement = document.getElementById('enemy-physical-dodge-rate');
    let enemyMagicDodgeElement = document.getElementById('enemy-magic-dodge-rate');

    let playerSkillEnhancementRate = 0;
    if (battleState.player.hidden) playerSkillEnhancementRate = 0.2;
    // 计算速度差异导致的物理闪避率
    speedDifference = battleAttributes.speed - battleState.enemy.speed;
    if (speedDifference > 0) {
        playerPhysicalDodgeElement.innerText = (Math.min((Math.abs(speedDifference) / 2500) * 0.01 + playerSkillEnhancementRate, 0.8) * 100).toFixed(2) + '%'; // 确保概率不超过80%
        enemyPhysicalDodgeElement.innerText = '0%';
    } else {
        enemyPhysicalDodgeElement.innerText = (Math.min((Math.abs(speedDifference) / 2500) * 0.01, 0.8) * 100).toFixed(2) + '%'; // 确保概率不超过80%
        playerPhysicalDodgeElement.innerText = '0%';
    }

    // 计算修为差异导致的魔法闪避率
    cultivationDifference = playerCultivation - enemyPetCultivation;
    if (cultivationDifference > 0) {
        playerMagicDodgeElement.innerText = (Math.min((Math.abs(cultivationDifference) / 35000) * 0.01 + playerSkillEnhancementRate, 0.8) * 100).toFixed(2) + '%'; // 确保概率不超过80%
        enemyMagicDodgeElement.innerText = '0%';
    } else {
        enemyMagicDodgeElement.innerText = (Math.min((Math.abs(cultivationDifference) / 35000) * 0.01, 0.8) * 100).toFixed(2) + '%'; // 确保概率不超过80%
        playerMagicDodgeElement.innerText = '0%';
    }
}
        
function handleDodge(target) {
    let speedDifference;
    let dodgeChance = 0; // 默认闪避概率为 0
    let dodgeElement; // 对应的图片元素：玩家图片或敌人图片
    let playerSkillEnhancementRate = 0;
    if (battleState.player.hidden) playerSkillEnhancementRate = 0.2;

    if (target === 'player') {
        // 玩家闪避逻辑
        speedDifference = battleAttributes.speed - battleState.enemy.speed;
        if (speedDifference > 0) {
            dodgeChance = Math.min((Math.abs(speedDifference) / 2500) * 0.01 + playerSkillEnhancementRate, 0.8); // 确保概率不超过80%
        }
        dodgeElement = document.getElementById('your-pet-image');
        console.log(`玩家闪避概率为：${dodgeChance}`);
    } else if (target === 'enemy') {
        // 敌人闪避逻辑
        speedDifference = battleState.enemy.speed - battleAttributes.speed;
        if (speedDifference > 0) {
            dodgeChance = Math.min((Math.abs(speedDifference) / 2500) * 0.01, 0.8); // 确保概率不超过80%
        }
        dodgeElement = document.getElementById('enemy-image');
        console.log(`敌人闪避概率为：${dodgeChance}`);
    } else {
        console.error('Invalid target for dodge handling');
        return false;
    }

    // 确定是否触发闪避
    const dodgeRoll = Math.random();
    const isDodge = dodgeRoll < dodgeChance;
    console.log(`闪避随机数为：${dodgeRoll}`);

    if (isDodge) {
        // 触发闪避
        // 应用视觉效果
        if (target === 'player') {
            dodgeElement.style.opacity = '0.5';
            showEffect('enemyEffect', 'https://pic.imgdb.cn/item/66bb115dd9c307b7e9a6c2d0.png');
        } else {
            dodgeElement.style.opacity = '0.5';
            showEffect('playerEffect', 'https://pic.imgdb.cn/item/66bb115dd9c307b7e9a6c2d0.png');
        }

        // 0.1秒后复原
        setTimeout(() => {
            dodgeElement.style.opacity = '';
        }, 100);

        return true; // 返回 true 表示闪避成功
    }

    return false; // 返回 false 表示未闪避
}

function handleMagicDodge(target) {
    let cultivationDifference;
    let dodgeChance = 0; // 默认闪避概率为 0
    let dodgeElement; // 对应的图片元素：玩家图片或敌人图片
    let playerSkillEnhancementRate = 0;
    if (battleState.player.hidden) playerSkillEnhancementRate = 0.2;

    if (target === 'player') {
        // 玩家魔法闪避逻辑
        cultivationDifference = playerCultivation - enemyPetCultivation;
        if (cultivationDifference > 0) {
            dodgeChance = Math.min((Math.abs(cultivationDifference) / 35000) * 0.01 + playerSkillEnhancementRate, 0.8); // 确保概率不超过80%
        }
        if (battleState.player.hidden) {
            dodgeChance = Math.min(0.8, dodgeChance + 0.2);
        }
        dodgeElement = document.getElementById('your-pet-image');
        console.log(`玩家魔法闪避概率为：${dodgeChance}`);
    } else if (target === 'enemy') {
        // 敌人魔法闪避逻辑
        cultivationDifference = enemyPetCultivation - playerCultivation;
        if (cultivationDifference > 0) {
            dodgeChance = Math.min((Math.abs(cultivationDifference) / 35000) * 0.01, 0.8); // 确保概率不超过80%
        }
        dodgeElement = document.getElementById('enemy-image');
        console.log(`敌人魔法闪避概率为：${dodgeChance}`);
    } else {
        console.error('Invalid target for magic dodge handling');
        return false;
    }

    // 确定是否触发闪避
    const dodgeRoll = Math.random();
    const isDodge = dodgeRoll < dodgeChance;
    console.log(`魔法闪避随机数为：${dodgeRoll}`);

    if (isDodge) {
        // 触发闪避，应用视觉效果
        if (target === 'player') {
            dodgeElement.style.opacity = '0.5';
            showEffect('enemyEffect', 'https://pic.imgdb.cn/item/66bb115dd9c307b7e9a6c2d0.png');
        } else {
            dodgeElement.style.opacity = '0.5';
            showEffect('playerEffect', 'https://pic.imgdb.cn/item/66bb115dd9c307b7e9a6c2d0.png');
        }

        // 0.1秒后复原
        setTimeout(() => {
            dodgeElement.style.opacity = '';
        }, 100);

        return true; // 返回 true 表示闪避成功
    }

    return false; // 返回 false 表示未闪避
}


// 【玩家战斗】玩家伤害函数（物理/物理效果、法术/法术效果）
function levelUpSkill() {
    if (battleState.player.taunt) {
        performAttack('physical');
        return;
    }
    
    // 创建遮罩层
    const overlay = document.createElement('div');
    overlay.style.position = 'fixed';
    overlay.style.top = '0';
    overlay.style.left = '0';
    overlay.style.width = '100%';
    overlay.style.height = '100%';
    overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
    overlay.style.display = 'flex';
    overlay.style.justifyContent = 'center';
    overlay.style.alignItems = 'center';
    overlay.style.zIndex = '1000';

    // 创建弹出界面
    const modal = document.createElement('div');
    modal.style = 'width: 85%;max-height: 80%;background-color: rgba(0, 0, 0, 0.1);color: white;border: 1px solid rgb(221, 221, 221);border-radius: 5px;padding: 20px;overflow-y: scroll;position: relative;display: flex;flex-direction: column;justify-content: center;align-items: stretch;';
    
    // 创建标题和关闭按钮
    const title = document.createElement('h2');
    title.innerText = '升级技能';
    title.style.textAlign = 'center';
    modal.appendChild(title);

    const closeButton = document.createElement('span');
    closeButton.innerText = 'X';
    closeButton.style.position = 'absolute';
    closeButton.style.top = '10px';
    closeButton.style.right = '10px';
    closeButton.style.cursor = 'pointer';
    closeButton.style.fontSize = '24px';
    closeButton.style.color = 'white';
    closeButton.onclick = () => document.body.removeChild(overlay);
    modal.appendChild(closeButton);

    // 创建技能显示区
    const skillsGrid = document.createElement('div');
    skillsGrid.style.display = 'grid';
    skillsGrid.style.color = 'black';
    skillsGrid.style.fontSize = '12px';
    skillsGrid.style.gridTemplateColumns = 'repeat(4, 1fr)';
    skillsGrid.style.gap = '10px';
    modal.appendChild(skillsGrid);

    const infoContainer = document.createElement('div');
    infoContainer.innerText = '点击技能可查看技能详细说明。'
    infoContainer.style = 'display: flex;color: white;font-size: 14px;gap: 10px;padding: 20px;height: 110px;align-items: center;border: 1px solid #fff;margin-top: 10px;border-radius: 2px;';
    modal.appendChild(infoContainer);

    function populateSkills() {
        skillsGrid.innerHTML = ''; // 清空技能网格
        const skillsArea = document.getElementById('skills-area');
        const skillDivs = Array.from(skillsArea.children);

        skillDivs.forEach(skillDiv => {
            const skillName = skillDiv.innerText.split(' ')[0];
            const skill = currentPet.skills.find(skill => skill.name === skillName);
            if (skill) {
                const result = calculateSkillLevelAndMultiplier(skill);
                skill.level = result.skillLevel; // 更新技能等级

                const skillElement = document.createElement('div');
                skillElement.innerText = `${skill.name} Lv${skill.level}`;
                skillElement.style.padding = '10px';
                skillElement.style.backgroundColor = '#fff';
                skillElement.style.border = '1px solid #000';
                skillElement.style.borderRadius = '8px';
                skillElement.style.cursor = 'pointer';
                skillElement.style.textAlign = 'center';
                skillElement.style.transition = 'background-color 0.3s, transform 0.3s';
                skillElement.onclick = () => {
                    document.querySelectorAll('.selected-skill').forEach(e => {
                        e.classList.remove('selected-skill');
                        e.style.backgroundColor = '#fff';
                        e.style.transform = 'scale(1)';
                    });
                    skillElement.classList.add('selected-skill');
                    skillElement.style.backgroundColor = '#add8e6';
                    skillElement.style.transform = 'scale(1.05)';
                    const skillMultiplier = calculateSkillLevelAndMultiplier(skill).skillMultiplier;
                    infoContainer.innerText = `${skill.rarity}技能，当前技能基础倍率为${Math.floor(skillMultiplier * 100)}%（目前技能倍率仅攻击类技能为直接相乘，其他类型技能都是加权相乘）说明：${skill.description}`;
                };
                skillsGrid.appendChild(skillElement);
            }
        });
    }

    populateSkills(); // 初始化时填充技能数据

    // 创建按钮操作区
    const buttonContainer = document.createElement('div');
    buttonContainer.style.marginTop = '20px';
    buttonContainer.style.display = 'flex';
    buttonContainer.style.flexDirection = 'row';
    buttonContainer.style.justifyContent = 'space-between';
    buttonContainer.style.textAlign = 'center';
    modal.appendChild(buttonContainer);

    const levelUpButton = document.createElement('button');
    levelUpButton.innerText = '升级技能';
    levelUpButton.style.padding = '10px 20px';
    levelUpButton.style.margin = '5px';
    levelUpButton.style.borderRadius = '8px';
    levelUpButton.style.border = 'none';
    levelUpButton.style.backgroundColor = '#28a745';
    levelUpButton.style.color = 'white';
    levelUpButton.style.cursor = 'pointer';
    levelUpButton.style.fontSize = '12px';
    levelUpButton.style.transition = 'background-color 0.3s';
    levelUpButton.onmouseover = () => levelUpButton.style.backgroundColor = '#218838';
    levelUpButton.onmouseout = () => levelUpButton.style.backgroundColor = '#28a745';
    levelUpButton.onclick = () => {
        handleLevelUp();
        populateSkills(); // 升级后刷新技能数据
    };
    buttonContainer.appendChild(levelUpButton);

    const bulkLevelUpButton = document.createElement('button');
    bulkLevelUpButton.innerText = '全部升级';
    bulkLevelUpButton.style.padding = '10px 20px';
    bulkLevelUpButton.style.margin = '5px';
    bulkLevelUpButton.style.borderRadius = '8px';
    bulkLevelUpButton.style.border = 'none';
    bulkLevelUpButton.style.backgroundColor = '#ffc107';
    bulkLevelUpButton.style.color = 'white';
    bulkLevelUpButton.style.cursor = 'pointer';
    bulkLevelUpButton.style.fontSize = '12px';
    bulkLevelUpButton.style.transition = 'background-color 0.3s';
    bulkLevelUpButton.onmouseover = () => bulkLevelUpButton.style.backgroundColor = '#e0a800';
    bulkLevelUpButton.onmouseout = () => bulkLevelUpButton.style.backgroundColor = '#ffc107';
    bulkLevelUpButton.onclick = () => {
        handleBulkLevelUp();
        populateSkills(); // 升级后刷新技能数据
    };
    buttonContainer.appendChild(bulkLevelUpButton);

    const infoButton = document.createElement('button');
    infoButton.innerText = '升级说明';
    infoButton.style.padding = '10px 20px';
    infoButton.style.margin = '5px';
    infoButton.style.borderRadius = '8px';
    infoButton.style.border = 'none';
    infoButton.style.backgroundColor = '#17a2b8';
    infoButton.style.color = 'white';
    infoButton.style.cursor = 'pointer';
    infoButton.style.fontSize = '12px';
    infoButton.style.transition = 'background-color 0.3s';
    infoButton.onmouseover = () => infoButton.style.backgroundColor = '#138496';
    infoButton.onmouseout = () => infoButton.style.backgroundColor = '#17a2b8';
    infoButton.onclick = () => showInfoBox('宠物等级每提升10级，所拥有的技能会自动提升1级。技能的等级很大程度上决定了它们的威力（被动技能会按一定比例增加各项属性值）。每个技能等级上限为20级，当技能等级到10级后，需要在本界面消耗一定经验值来升级技能。');
    buttonContainer.appendChild(infoButton);

    overlay.appendChild(modal);
    document.body.appendChild(overlay);
} //玩家技能升级、调用函数

function handleLevelUp() {
    const selectedSkillElement = document.querySelector('.selected-skill');
    if (!selectedSkillElement) {
        showInfoBox('请选择一个技能！');
        return;
    }

    const skillName = selectedSkillElement.innerText.split(' ')[0];
    const skill = currentPet.skills.find(skill => skill.name === skillName);

    if (!skill) {
        showInfoBox('未找到该技能！');
        return;
    }

    if (skill.level >= 6 && skill.type === 'NE' && skill.byLearned) {
        skill.level = 6;
        return;
    }
    
    if (skill.byLearned) {
        const heart = jinnangItems.find(item => item.name === 'universalHeart' && item.quantity >= 5);
        if (heart) {
            useItem('universalHeart', 5);
            skill.level += 1;
            showInfoBox(`${skill.name} 成功升级至 ${skill.level} 级`);
            return;
        } else {
            showInfoBox('高级天赋技能需要使用特殊道具”宇宙之心“才能升级，请尝试获取后再操作',null,null,'red');
            return;
        }
    }

    // 提取成功率检查的逻辑
    const checkSuccess = (rate) => Math.random() < rate;

    if (skill.level >= 28 && skill.level <= 29) {
        if (useItem('universalKernel', 5)) {
            if (checkSuccess(0.4)) {
                skill.level += 1;
                showInfoBox(`${skill.name} 成功升级至 ${skill.level} 级`);
            } else {
                showInfoBox(`${skill.name} 升级失败！`, null, null, 'red');
            }
            return;
        } else {
            showInfoBox('你没有宇宙精华了！',null,null,'red');
            return;
        }
    }

    if (skill.level >= 24 && skill.level <= 27) {
        if (useItem('universalCrystal', 5)) {
            if (checkSuccess(0.4)) {
                skill.level += 1;
                showInfoBox(`${skill.name} 成功升级至 ${skill.level} 级`);
            } else {
                showInfoBox(`${skill.name} 升级失败！`, null, null, 'red');
            }
            return;
        } else {
            showInfoBox('你没有宇宙之晶了！',null,null,'red');
            return;
        }
    }
    
    if (skill.level < 10) {
        showInfoBox('该技能现在不需要升级,10级后再来吧！');
        return;
    }

    if (skill.level >= 20) {
        showInfoBox('该技能已达到目前阶段最高等级！请尝试使用药品系统中的“魔术棱柱”进行升级！');
        return;
    }
    
    const nextLevel = skill.level + 1;
    const expCost = 1000 + 200 * (nextLevel - 11);

    if (currentExp < expCost) {
        showInfoBox(`此次升级需要 ${expCost} 点经验值，你的经验值不足，无法升级！`);
        return;
    }

    currentExp -= expCost;
    skill.level = nextLevel;

    showInfoBox(`你消耗了 ${expCost} 点经验值，将 ${skill.name} 成功升至 ${nextLevel} 级，威力增加了！`);
    updateExpBar();
    updateUI();
}

function handleBulkLevelUp() {
    const skillMessages = [];
    currentPet.skills.forEach(skill => {
        while (skill.level >= 10 && skill.level < 20 && currentExp >= (1200 + 200 * (skill.level - 10))) {
            const expCost = 1200 + 200 * (skill.level - 10);
            currentExp -= expCost;
            skill.level += 1;
            skillMessages.push(`你消耗了${expCost}点经验值，将${skill.name} 成功升至 ${skill.level} 级，威力增加了！`);
        }
    });

    if (skillMessages.length === 0) {
        showInfoBox('没有技能需要升级或经验不足！');
    } else {
        showInfoBox(skillMessages.join('\n'));
    }

    updateExpBar();
    updateUI();
}

function getSkillByType(type) {
    const skillsArea = document.getElementById("skills-area");
    if (!skillsArea) {
        console.error("skills-area element not found.");
        return null;
    }

    const skills = Array.from(skillsArea.children).map(skillDiv => {
        const skillName = skillDiv.innerText.split(' ')[0];
        const skill = currentPet.skills.find(skill => skill.name === skillName && skill.type === type);
        return skill;
    }).filter(skill => skill !== null);

    return skills.length > 0 ? skills[Math.floor(Math.random() * skills.length)] : null;
}

function calculateSkillLevelAndMultiplier(skill) {
    let skillLevel = skill.level || 1;

    if (skill.type === 'NE' && skill.byLearned) {
        skillLevel = Math.min(6, Math.floor(petLevel / 10) + 1);
    } else if (skillLevel < 10) {
        skillLevel = Math.min(10, Math.floor(petLevel / 10) + 1);
    }

    const skillMultiplier = skill.multiplier * (1 + 0.1 * (skillLevel - 1));
    return { skillLevel, skillMultiplier };
}

// 全局变量
let advancementStates = []; // 保持唯一的全局变量

function clearAdvancementStates(petName) {
    // 找到对应宠物的索引
    const petIndex = advancementStates.findIndex(state => state.petName === petName);
    
    if (petIndex !== -1) {
        // 从 advancementStates 中删除该宠物的加成数据
        advancementStates.splice(petIndex, 1);
        showInfoBox(`${petName} 的技能加成已清除`);
    } else {
        showInfoBox(`未找到宠物 ${petName} 的加成记录`);
    }
}
        
function initializeAdvancementStates() {
const applicableSkills = Object.values(pets).flatMap(pet =>
  pet.skills
    .filter(skill => 
      (skill.type === "PA" || skill.type === "MA"|| skill.type === "PP") && skill.rarity === "SS"
    )
    .flatMap(skill => [
      { ...skill, rank: '高', multiplier: 0, petName: pet.name, skillName: `${skill.name}[高]` },
      { ...skill, rank: '中', multiplier: 0, petName: pet.name, skillName: `${skill.name}[中]` },
      { ...skill, rank: '低', multiplier: 0, petName: pet.name, skillName: `${skill.name}[低]` }
    ])
);

  if (applicableSkills.length === 0) {
    showInfoBox('没有可用的技能');
    return null;
  }

  let currentPetState = advancementStates.find(state => state.petName === currentPet.name);
  if (!currentPetState) {
    currentPetState = {
      petName: currentPet.name,
      intimacy: 0,
      attention: 0,
      appliedSkills: [],
      learningValue: 0,
      skillPoints: calculateSkillPointsForPet()
    };
    advancementStates.push(currentPetState);
  }

  return { currentPetState, applicableSkills };
}

function getBlessSkills() {
    const currentPetState = initializeAdvancementStates().currentPetState;
    const applicableSkills = initializeAdvancementStates().applicableSkills;
    
    const availableSkills = applicableSkills.filter(skill => 
        !currentPetState.appliedSkills.some(applied => applied.skillName === skill.skillName)
    );

    const currentPetSkill = availableSkills.filter(skill => skill.petName === currentPet.name);

    if (availableSkills.length === 0) {
        showInfoBox('已领悟所有可用技能!');
        return null;
    }
    
    if (currentPetSkill.length !== 0) {
        const acquiredSkill = currentPetSkill[Math.floor(Math.random() * currentPetSkill.length)];
        currentPetState.appliedSkills.push({
          ...acquiredSkill,
          level: 1,
          applied: false
        });
        currentPetState.skillPoints = calculateSkillPoints(currentPetState); // 更新技能点数
        updateAdvancement();
        showInfoBox(`${currentPet.name}领悟到神圣天赋赐福内的字字箴言，学会了${acquiredSkill.name}（${acquiredSkill.rank}）加成之术，你可以打开加成面板进行查看`,null,null,'green');
    } else {
        showInfoBox('当前宠物已经领悟了所有可用加成，使用神圣天赋赐福失败！',null,null,'red');
    }
}

function calculateSkillPointsForPet() {
  return Math.floor(petLevel / 9);
}

function aquireSkillAdvancement(currentPetState, applicableSkills) {
  const appliedSkillsCount = currentPetState.appliedSkills.length;
  let probability;
  
  if (appliedSkillsCount >= 9) {
    probability = Math.random();
    if (probability < 0.05) {
      // 5%概率得到一个加成
      return acquireSkill(currentPetState, applicableSkills);
    } else if (probability < 0.50) {
      // 45%概率得到（100~300）学习度
      addLearningValue(currentPetState);
      return null;
    } else {
      // 50%概率一无所获
      showInfoBox('你的宠物尝试进入冥想，但它逐渐变得焦躁不安，最后一无所获。');
      return null;
    }
  } else if (appliedSkillsCount >= 7) {
    probability = Math.random();
    if (probability < 0.15) {
      // 15%概率得到一个加成
      return acquireSkill(currentPetState, applicableSkills);
    } else if (probability < 0.60) {
      // 45%概率得到（100~300）学习度
      addLearningValue(currentPetState);
      return null;
    } else {
      // 40%概率一无所获
      showInfoBox('你的宠物尝试进入冥想，但它逐渐变得焦躁不安，最后一无所获。');
      return null;
    }
  } else if (appliedSkillsCount >= 5) {
    probability = Math.random();
    if (probability < 0.35) {
      // 35%概率得到一个加成
      return acquireSkill(currentPetState, applicableSkills);
    } else if (probability < 0.70) {
      // 25%概率得到（100~300）学习度
      addLearningValue(currentPetState);
      return null;
    } else {
      // 30%概率一无所获
      showInfoBox('你的宠物尝试进入冥想，但它逐渐变得焦躁不安，最后一无所获。');
      return null;
    }
  } else {
    probability = Math.random();
    if (probability < 0.70) {
      // 70%概率得到一个加成
      return acquireSkill(currentPetState, applicableSkills);
    } else if (probability < 0.80) {
      // 10%概率得到（100~300）学习度
      addLearningValue(currentPetState);
      return null;
    } else {
      // 20%概率一无所获
      showInfoBox('你的宠物尝试进入冥想，但它逐渐变得焦躁不安，最后一无所获。');
      return null;
    }
  }
}

function acquireSkill(currentPetState, applicableSkills) {
    // 过滤掉已领会的技能
    const availableSkills = applicableSkills.filter(skill => 
        !currentPetState.appliedSkills.some(applied => applied.skillName === skill.skillName)
    );

    if (availableSkills.length === 0) {
        showInfoBox('已领悟所有可用技能!');
        return null;
    }

    const acquiredSkill = availableSkills[Math.floor(Math.random() * availableSkills.length)];
        currentPetState.appliedSkills.push({
        ...acquiredSkill,
        level: 1,
        applied: false
    });
        
    currentPetState.skillPoints = calculateSkillPoints(currentPetState); // 更新技能点数
    return acquiredSkill;
}

function addLearningValue(currentPetState) {
  const learningValueGained = Math.floor(Math.random() * 301) + 300; // 100到300之间的随机值
  currentPetState.learningValue += learningValueGained;
  showInfoBox(`你的宠物尝试进入冥想，但它逐渐变得焦躁不安，最后勉强获得了${learningValueGained}学习度！`);
}

function increaseCurrentPetLearningValue(amount) {
  const currentPetState = advancementStates.find(state => state.petName === currentPet.name);
  if (currentPetState) {
    currentPetState.learningValue += amount;
    console.log(`你的宠物学习度增加了 ${amount} 点。`);
  } else {
    console.error('当前宠物状态不存在');
  }
  updateAdvancement();
}

function increaseCurrentPetIntimacy(amount) {
  const currentPetState = advancementStates.find(state => state.petName === currentPet.name);
  if (currentPetState) {
    // 更新亲密度，但确保最低为0
    currentPetState.intimacy = Math.max(0, currentPetState.intimacy + amount);
    console.log(`你的宠物亲密度增加了 ${amount} 点。`);
  } else {
    console.error('当前宠物状态不存在');
  }
  updateAdvancement();
}
        
function increaseCurrentPetAttention(amount) {
  const currentPetState = advancementStates.find(state => state.petName === currentPet.name);
  if (currentPetState) {
    currentPetState.attention += amount;
    console.log(`你的宠物集中值增加了 ${amount} 点。`);
  } else {
    console.error('当前宠物状态不存在');
  }
  updateAdvancement();
}

function test() {
    increaseCurrentPetLearningValue(200000);
    increaseCurrentPetIntimacy(6000);
    increaseCurrentPetAttention(1000);
}
        
function openAquireSkillAdvancementPanel() {
  const panel = document.getElementById('skill-advancement-panel');
  const currentDisplay = window.getComputedStyle(panel).display;

  if (currentDisplay === 'none') {
    panel.style.display = 'block';
    updateAdvancement();
  } else if (currentDisplay === 'block') {
    panel.style.display = 'none';
  }
  document.getElementById('advancement-detail-panel').innerHTML = '';
}

function calculateSkillPoints(currentPetState) {
  const totalSkillPoints = Math.floor(petLevel / 12);

  const usedSkillPoints = currentPetState.appliedSkills.reduce((total, skill) => {
    return total + (skill.level > 1 ? skill.level - 1 : 0);
  }, 0);

  return totalSkillPoints - usedSkillPoints;
}

function updateAdvancement() {
  let { currentPetState, applicableSkills } = initializeAdvancementStates();
  if (!currentPetState) return;

  document.getElementById('intimacy').textContent = currentPetState.intimacy;
  document.getElementById('attention').textContent = currentPetState.attention;
  document.getElementById('learning-value').textContent = currentPetState.learningValue;

  const skillPoints = calculateSkillPoints(currentPetState);
  document.getElementById('skill-points').textContent = `${skillPoints}`;

  const rankMap = {
    '高': '高',
    '中': '中',
    '低': '低'
  };

  const appliedSkillsList = document.getElementById('applied-skills-list');
  appliedSkillsList.innerHTML = currentPetState.appliedSkills.map(skill => `
    <div class="applied-skill" style="position: relative;height:48px;">
      <img id="advancement-image" src="https://pic.imgdb.cn/item/66d19552d9c307b7e9a25ac0.png" alt="advancement" style="width:45px;height:45px;border:1px solid black">
      <span style="
        position: absolute;
        top: 10px;
        left: 15px;
        display: flex;
        justify-content: center;
        align-items: center;
        color: white;
        font-size: 16px;
        text-shadow: 0px 0px 2px black;
        pointer-events: none;">
        ${rankMap[skill.rank]}
      </span>
      <p style="width: 40%;">${skill.name} (${skill.petName})</p>
      <button class="skill-detail-btn" data-skill-id="${skill.name}-${skill.rank}">详情</button>
    </div>
  `).join('');

  const skillDetailBtns = document.querySelectorAll('.skill-detail-btn');
  skillDetailBtns.forEach(btn => {
    btn.addEventListener('click', () => {
      const skillId = btn.dataset.skillId;
      const skill = currentPetState.appliedSkills.find(s => `${s.name}-${s.rank}` === skillId);
      showSkillDetail(skill);
    });
  });
}

const aquireSkillBtn = document.getElementById('aquire-skill-btn');
aquireSkillBtn.addEventListener('click', () => {
  let currentPetState = advancementStates.find(state => state.petName === currentPet.name);
  
  if (!currentPetState) {
    showInfoBox('当前宠物状态不存在');
    return;
  }
  
  const { applicableSkills } = initializeAdvancementStates();
  
  if (currentPetState.intimacy >= 30 && currentPetState.attention >= 2) {
    currentPetState.intimacy -= 30;
    currentPetState.attention -= 2;
    
    const acquiredSkill = aquireSkillAdvancement(currentPetState, applicableSkills);
    if (acquiredSkill) {
      showInfoBox(`你的宠物经过一段时间的沉思，学会了${acquiredSkill.name} 加成术`);
    }
  } else {
    showInfoBox('每次领悟需要耗费2集中值和30亲密度!',null,null,'red');
  }
    updateAdvancement();
});
        
const resetSkillBtn = document.getElementById('reset-skill-btn');
resetSkillBtn.addEventListener('click', () => {
  const currentPetState = advancementStates.find(state => state.petName === currentPet.name);
  if (!currentPetState) {
    showInfoBox('当前宠物状态不存在');
    return;
  }

  if (useItem('resetAdvancementPill',1)) { // 假设金子数量是一个全局变量
    showInfoBox('你是否要重置所有技能的等级？', () => {
      // 先处理所有已应用的技能，移除其 multiplier 的影响
      currentPetState.appliedSkills.forEach(skill => {
        if (skill.applied) {
          handleApplyAdvancement(skill, false);
        }
      });

      // 重置所有技能等级为1，返还所有 skillPoints
      currentPetState.appliedSkills.forEach(skill => {
        skill.level = 1;
        skill.multiplier = 0;
        skill.applied = false; // 复位应用状态
      });

      updateAdvancement();
      document.getElementById('advancement-detail-panel').innerHTML = '';
      showInfoBox('所有技能已重置，并返还所有技能点。');
    }, () => {
      addItemToJinnang('resetAdvancementPill',1);
      showInfoBox('操作已取消。');
    });
  } else {
    showInfoBox('道具数量不足，无法重置技能！', null, null, 'red');
  }
});

const rankMultiplierMap = {
  '高': [0, 0.1, 0.2, 0.3, 0.4, 0.5],
  '中': [0, 0.05, 0.1, 0.15, 0.2, 0.25],
  '低': [0, 0.02, 0.04, 0.06, 0.08, 0.1]
};

function showSkillDetail(skill) {
    const currentPetState = advancementStates.find(state => state.petName === currentPet.name);
    if (!currentPetState) {
    console.error('当前宠物状态不存在');
    return;
    }
    
    const skillPoints = calculateSkillPoints(currentPetState);
    const nextMultiplier = rankMultiplierMap[skill.rank][skill.level];
    
    const detailHtml = `
    <div class="skill-detail">
    <div style="display: flex;flex-direction: row;justify-content: space-evenly;width: 100%;">
      <div>名称: ${skill.skillName}</div>
      <div>等级: ${skill.level}</div>
      <div>加成: ${(skill.multiplier * 100).toFixed(0)}%</div>
    </div>
      <button id="delete-skill-btn">删除</button>
      <button id="upgrade-skill-btn">升级</button>
      <button id="apply-skill-btn">${skill.applied ? '禁用' : '应用'}</button>
    </div>
    `;

    const detailPanel = document.querySelector('.skill-detail-panel');
    detailPanel.innerHTML = detailHtml;

    const deleteSkillBtn = document.getElementById('delete-skill-btn');
    deleteSkillBtn.addEventListener('click', () => {
      const index = currentPetState.appliedSkills.findIndex(s => s.skillName === skill.skillName);
    
      showInfoBox("删除技能加成后将无法撤销，是否确认删除？",
      () => {
          if (skill.applied) {
            handleApplyAdvancement(skill, false); // 先移除加成
          }
          currentPetState.appliedSkills.splice(index, 1);
          updateAdvancement();
          document.getElementById('advancement-detail-panel').innerHTML = '';
      },
      () => {
          showInfoBox("取消删除技能");
      });
    });
    
    const upgradeSkillBtn = document.getElementById('upgrade-skill-btn');
    upgradeSkillBtn.addEventListener('click', () => {
      if (skillPoints <= 0) {
        showInfoBox('你的技能点数不足，无法升级！', null, null, 'red');
        return;
      }
    
      const learningValueNeeded = [600, 2000, 6000, 12000, 20000][skill.level - 1];
      const nextMultiplier = rankMultiplierMap[skill.rank][skill.level]; // 计算下一级 multiplier
    
      if (currentPetState.learningValue >= learningValueNeeded && skill.level < 6) {
        showInfoBox(`此次升级需要${learningValueNeeded}点学习度，是否继续？`,
          () => {
            if (skill.applied) {
              handleApplyAdvancement(skill, false); // 升级前移除当前 multiplier
            }
    
            currentPetState.learningValue -= learningValueNeeded;
            skill.level++;
            skill.multiplier = nextMultiplier;
    
            if (skill.applied) {
              handleApplyAdvancement(skill, true); // 升级后重新应用 multiplier
            }
    
            updateAdvancement();
            showSkillDetail(skill);
          },
          () => {
              return;
          });
      } else {
        showInfoBox('学习度不足或已达到最大等级!', null, null, 'red');
      }
    });
    
    const applySkillBtn = document.getElementById('apply-skill-btn');
    applySkillBtn.addEventListener('click', () => {
      if (skill.applied) {
        handleApplyAdvancement(skill, false); // 如果已应用，先取消应用
      } else {
        handleApplyAdvancement(skill, true); // 如果未应用，应用加成
      }
      skill.applied = !skill.applied; // 切换应用状态
      showSkillDetail(skill);
    });
}

function handleApplyAdvancement(skill, applied) {
  const skillsArea = document.getElementById("skills-area");
  if (!skillsArea) {
    console.error("skills-area element not found.");
    return;
  }

  // 获取当前宠物的技能列表
  const skills = Array.from(skillsArea.children).map(skillDiv => {
    const skillName = skillDiv.innerText.split(' ')[0];
    const skillType = skill.type;
    return currentPet.skills.find(s => s.name === skillName && s.type === skillType);
  }).filter(s => s !== undefined);

  // 查找要应用加成的技能是否在当前宠物的技能列表中
  const targetSkill = skills.find(s => s.name === skill.name);
  
  if (targetSkill) {
    // 如果技能在宠物的技能列表中，应用或取消加成
    targetSkill.multiplier += applied ? skill.multiplier : -skill.multiplier;
    console.log(`现在你的技能威力是${targetSkill.multiplier}`);
  } else {
    // 如果技能不在宠物的技能列表中，显示警告信息
    showInfoBox(`${currentPet.name}并不会释放${skill.name}，应用或禁用后不会产生任何效果！`, null, null, 'red');
  }
}
        
function selectSkillAndCalculateMultiplier(type) {
    let selectedSkills = [];
    let skillMultiplier = 1;
    let skillLevel = 1;
    let isSkillUsed = false;

    const skillsArea = document.getElementById('skills-area');
    const skillDivs = Array.from(skillsArea.children);
    skillDivs.forEach(skillDiv => {
        const skillName = skillDiv.innerText.split(' ')[0];
        const skill = currentPet.skills.find(skill => skill.name === skillName);
        if (skill) {
            if (type === 'physical' && (skill.type === 'PA' || skill.type ==='PAE')) {
                selectedSkills.push(skill);
            } else if (type === 'magical' && (skill.type === 'MA' || skill.type === 'MAE')) {
                selectedSkills.push(skill);
            }
        }
    });
    
    const randomIndex = Math.floor(Math.random() * selectedSkills.length);
    const selectedSkill = selectedSkills[randomIndex];
    
    if (selectedSkills.length > 0) {
        const result = calculateSkillLevelAndMultiplier(selectedSkill);
        skillLevel = result.skillLevel;
        skillMultiplier = result.skillMultiplier;
        isSkillUsed = true;
        logBattleEvent(`你施放了 ${selectedSkill.name} ${skillLevel}级。`, 'gold');
        if (type === 'physical') {
            const manaCost = Math.floor((Math.random() * (200 - 50 + 1) * skillLevel));
            battleAttributes.mana = Math.max(0, battleAttributes.mana - manaCost);
            showEffect('playerEffect', 'https://pic.imgdb.cn/item/667269e9d9c307b7e915e15a.gif');
        } else if (type === 'magical') {
            showEffect('playerEffect', 'https://pic.imgdb.cn/item/66712ba3d9c307b7e9f2ab59.gif');
        }
    } else {
        if (type === 'physical') {
            logBattleEvent("⚔️【玩家攻击】你用拳头平A了对方。");
            showEffect('playerEffect', 'https://pic.imgdb.cn/item/667123f9d9c307b7e9e34049.gif');
        } else if (type === 'magical') {
            logBattleEvent("⚔️【玩家攻击】你操控小树枝击向了对方。");
            showEffect('playerEffect', 'https://pic.imgdb.cn/item/6671343bd9c307b7e9031c3d.gif');
        }
    }

    return { skillMultiplier, isSkillUsed, selectedSkill };
} 
        
let waterAmuletTriggered = false; // 新增标志变量

function performAttack(type) {
    if (!attributesFetched) {
        showInfoBox("请先从属性面板获取属性。");
        return;
    }

    if (!battleState || !battleState.enemy) {
        console.error("战斗状态未初始化");
        return;
    }

    if(!playerTurn) {
        return;
    }
        
    let attackType = type; // 标志变量
    // 检查 taunt 状态并执行物理攻击
    if (battleState.player.taunt) {
        attackType = 'physical';
    }
    
    const { skillMultiplier, isSkillUsed, selectedSkill } = selectSkillAndCalculateMultiplier(attackType);
    let damageResult;

    if (attackType === 'physical') {
        damageResult = performPhysicalAttack(skillMultiplier, isSkillUsed, selectedSkill);
    } else if (attackType === 'magical') {
        const result = performMagicalAttack(skillMultiplier, isSkillUsed, selectedSkill);
        if (result.retryPhysical) {
            logBattleEvent("⚔️【玩家攻击】法力值不足，自动转为物理攻击。", 'red');
            performAttack('physical');
            return;
        }
        damageResult = result.finalDamage;
    }

    handleCriticalAndDrunken(damageResult);
    applyDefenseBonusEffect(); // 处理防御后的增益效果

    // 检查并处理水符效果，防止多次触发
    if (!waterAmuletTriggered && checkWaterAmuletChance()) {
        waterAmuletTriggered = true;
        handleWaterAmuletEffect(attackType, damageResult);
        return; // 如果水符触发，避免敌方回合
    }
    
    if (battleState.enemy.health <= 0) {
        updateEnemyAttributes();
        showNextBattlePrompt(true);
        return;
    }
    
    handleShocked();
    handleManaRecover();
    updateUI();
    applyAscensionEffects();
    // 重置标志变量
    waterAmuletTriggered = false;
    if (battleAttributes.health <= 0) {
        showNextBattlePrompt(false); // 玩家失败，传递失败状态
        return;
    } else if (battleState.enemy.health <= 0) {
        showNextBattlePrompt(true);
        return;
    }
    playerTurn = false;
}

function checkWaterAmuletChance() {
    const activeEffects = applyWuxingEffects();

    if (activeEffects.waterAmulet && activeEffects.waterAmulet > 0) {
        const extraAttackProbability = [0, 0.02, 0.05, 0.07, 0.12, 0.20, 0.22, 0.25, 0.28, 0.4][activeEffects.waterAmulet];
        if (Math.random() < extraAttackProbability) {
            return true; 
        }
    }
    return false;
}
        
function handleWaterAmuletEffect(attackType, damage) {
    logBattleEvent("🔵奥义·水之再动！！", 'aqua');
    performAttack(attackType); // 再次执行相同类型的攻击
}
        
function updateDamageValue(damage, enemy = false, damageType = 'damage', isCritical = false) {
    // 根据 damageType 确定要操作的 DOM 元素
    const playerDamageValueElement = document.getElementById(`player-${damageType}-value`);
    const enemyDamageValueElement = document.getElementById(`enemy-${damageType}-value`);

    if (!playerDamageValueElement || !enemyDamageValueElement) {
        console.error("Failed to get damage value element.");
        return;
    }

    const damageElement = enemy ? enemyDamageValueElement : playerDamageValueElement;

    if (isNaN(damage)) {
        console.error("Invalid damage value: NaN.");
        return;
    }

    // 清除之前的动画效果和样式
    damageElement.className = '';
    damageElement.style.background = '';
    damageElement.style.opacity = '1';
    damageElement.style.transform = 'translateY(0)';

    if (damage >= 0) {
        // 正伤害
        damageElement.innerText = `-${damage}`;
        if (isCritical) {
            // 暴击：红色、震荡效果
            damageElement.style.color = 'red';
            damageElement.style.fontSize = '24px';
            damageElement.style.textShadow = '-2px -2px 0 #8a2e27, 2px -2px 0 #8a2e27, -2px 2px 0 #8a2e27, 2px 2px 0 #8a2e27';
            damageElement.style.padding = '10px';
            damageElement.style.borderRadius = '10px';
            damageElement.style.zIndex = '99999';
            damageElement.style.fontWeight = 'bolder';
            damageElement.classList.add('critical-hit-animation');
        } else {
            // 非暴击：黄色，快速渐进渐出
            damageElement.style.color = 'white';
            damageElement.style.fontSize = '20px';
            damageElement.style.textShadow = '0 0 2px black';
            damageElement.style.padding = '10px';
            damageElement.style.borderRadius = '10px';
            damageElement.style.zIndex = '99999';
            damageElement.classList.add('normal-hit-animation');
        }
    } else {
        // 生命恢复：绿色，向上渐出
        const healAmount = Math.abs(damage);
        damageElement.innerText = `+${healAmount}`;
        damageElement.style.color = 'limegreen';
        damageElement.style.fontSize = '22px';
        damageElement.style.textShadow = '0 0 8px lime';
        damageElement.style.padding = '10px';
        damageElement.style.borderRadius = '10px';
        damageElement.style.zIndex = '99999';
        damageElement.classList.add('heal-animation');
    }

    // 在 300 毫秒后清空显示的值
    setTimeout(() => {
        damageElement.innerText = '';
        damageElement.className = '';  // 清除动画类名，防止影响下一次显示
    }, 240);
}

// 检查是否存在必杀技
function checkTrumpCardState() {
    const tcSkills = [];
    const skillsArea = document.getElementById("skills-area");
    
    if (skillsArea) {
        // 遍历技能区域中的每个技能
        Array.from(skillsArea.children).forEach(skillDiv => {
            const skillName = skillDiv.innerText.split(' ')[0];
            const skill = currentPet.skills.find(skill => skill.name === skillName && skill.type === "TC");
            if (skill) {
                tcSkills.push(skill); // 将符合条件的必杀技推入数组
            }
        });
    }
    
    if (tcSkills.length === 0) return { exists: false, skill: null }; // 如果没有必杀技，返回false和null
    
    let selectedSkill = tcSkills[0]; // 默认选择第一个必杀技

    if (tcSkills.length > 1) {
        // 如果有多个必杀技，随机选择一个
        const randomIndex = Math.floor(Math.random() * tcSkills.length);
        selectedSkill = tcSkills[randomIndex];
    }

    // 返回true和选择的技能
    return { exists: true, skill: selectedSkill };
}

function checkLifeSpan(amount) {
    const spanCost = currentLifeSpan - amount;
    if (spanCost < 0) {
        logBattleEvent('你的宠物看起来起色很不好，多关心关心它吧！', 'grey');
        return false;
    }
    
    currentLifeSpan -= amount;
    return true;
}

function recoverLifeSpan(amount) {
    currentLifeSpan = Math.floor(Math.min(maxLifeSpan, currentLifeSpan + amount));
}
        
// 执行必杀技
function performTrumpCard() {
    const checkResult = checkTrumpCardState(); // 调用检查函数
    
    if (!checkResult.exists) {
        // 如果没有必杀技，记录战斗事件并退出
        logBattleEvent('你还没有解锁任何必杀技！', 'red');
        return;
    }
    
    if (!playerTurn) {
        // 如果不是玩家回合，退出
        return;
    }
    
    // 在这里处理使用必杀技的逻辑
    const selectedSkill = checkResult.skill;
    const skillDetail = calculateSkillLevelAndMultiplier(selectedSkill);
    

    applySpecialSkillEffects(selectedSkill);
}

        
function f(x) {
    // 计算函数值
    const result = (x / (x + 300000)) - 0.1;
    
    // 使用 Math.max 确保结果至少为 0
    return Math.max(result, 0);
}
        
function performPhysicalAttack(skillMultiplier, isSkillUsed, selectedSkill) {
    const defenseFactor = (Math.random() * (1.2 - 0.8) + 0.8);
    const x = battleState.enemy.physicalDefense * defenseFactor;
    const effectiveDefense = f(x);
    const constantDamageReduction = Math.round(battleState.enemy.physicalDefense * 0.1);

    let baseDamage;
    if (effectiveDefense !== 0){
        baseDamage = Math.max(1, Math.floor(battleAttributes.physicalAttack * skillMultiplier * (1 - effectiveDefense)));
    } else {
        baseDamage = Math.max(1, Math.floor(battleAttributes.physicalAttack * skillMultiplier));
    }
    
    // 检查玩家是否处于失明状态
    if (battleState.player.blindfold) {
        logBattleEvent("处于短暂失明，敌人闪避了你的物理攻击。", 'yellow');
        playerTurn = false;
        return 0; // 物理攻击无法造成伤害
    }

    // 检查敌人是否闪避
    if (handleDodge('enemy')) {
        playerTurn = false;
        return 0; // 如果敌人闪避成功，物理攻击伤害为0
    }

    // 应用各种效果和状态修正伤害
    if ((ascensionSkill.name === '斩龙一式' || secondAscensionSkill.name === '斩龙一式') && battleState.enemy.health / enemyMaxHealth > battleState.player.whiteNightThreshold) {
        baseDamage = Math.floor(baseDamage * 1.4); // 增加60%伤害
    }

    if (battleState.player.taunt) {
        baseDamage = Math.floor(baseDamage * 1.2); // 增加20%伤害
        logBattleEvent("怒意激发了你的斗志，嘲讽下你的物理伤害提升20%！", 'red');
    }

    let isCritical = checkCriticalHit(playerCritRate);

    // 在所有效果应用后计算最终伤害
    let finalDamage = calculateDamage(baseDamage, isCritical, playerCritDamage, true);
    // 如果存在火符的效果则还需要计算一层
    const activeEffects = applyWuxingEffects();
    let fireEffect = 0;
    if (activeEffects.fireAmulet && activeEffects.fireAmulet > 0) {
        const damageBoostPercentage = [0, 0.02, 0.05, 0.07, 0.12, 0.20, 0.22, 0.25, 0.28, 0.4][activeEffects.fireAmulet];
        fireEffect = Math.floor(finalDamage * damageBoostPercentage);
        finalDamage = Math.floor(finalDamage * (1 + damageBoostPercentage));

        if (!isNaN(fireEffect) && fireEffect > 0) {
            logBattleEvent(`🔴奥义·火之易伤！伤害增加了 ${fireEffect} 点。`, 'pink');
        } 
    }

    finalDamage = Math.max(1, finalDamage - constantDamageReduction);
    
    if (enemyRivival) {
        finalDamage = Math.floor(0.1 * finalDamage);
    }
    
    battleState.enemy.health = Math.max(0, battleState.enemy.health - finalDamage);
    
    // 记录日志
    if (isCritical) {
        logBattleEvent(`⚔️【玩家攻击】暴击！！本次对敌方造成了 ${finalDamage} 点物理伤害！`, 'red');
        updateDamageValue(finalDamage,false,'damage',true); // 显示玩家伤害
        showEffect('playerEffect', 'https://pic.imgdb.cn/item/66a0d3e8d9c307b7e93a8108.gif');
    } else {
        updateDamageValue(finalDamage,false,'damage'); // 显示玩家伤害
        logBattleEvent(`⚔️【玩家攻击】你造成了 ${finalDamage} 点物理伤害。`, 'white');
    }

    if (waterAmuletTriggered) {
        updateDamageValue(finalDamage,false,'extra-damage')
    }
    
    
    // 应用吸血魔刃效果
    if (ascensionSkill.name === '吸血魔刃' || secondAscensionSkill.name === '吸血魔刃') {
        const bloodSuckPercentage = (ascensionSkill.name === '吸血魔刃' ? ascensionSkill : secondAscensionSkill).increment((ascensionSkill.name === '吸血魔刃' ? ascensionSkill : secondAscensionSkill).level) / 100;
        const healAmount = Math.floor(finalDamage * bloodSuckPercentage);
        battleAttributes.health = Math.min(maxHealth, battleAttributes.health + healAmount);
        logBattleEvent(`吸血魔刃触发,吸取了 ${healAmount} 点生命值。`, 'red');
        updateUI();
    }

    if (battleState.enemy.pierced) {
        handlePierced(); // 处理穿透效果
    }
    
    applyPhysicalAttackEffects(isSkillUsed ? skillMultiplier : 1); // 确保正确执行物理攻击效果
    if (selectedSkill && selectedSkill.type === "PAE") {
        applySpecialSkillEffects(selectedSkill);
    }
    console.log(selectedSkill);
    return finalDamage;
}


function performMagicalAttack(skillMultiplier, isSkillUsed, selectedSkill) {
    let manaCostMultiplier = 1;
    if (battleState.player.spellSlow) {
        manaCostMultiplier = 500;
    }

    if (battleAttributes.mana < 50 * manaCostMultiplier) {
        logBattleEvent("您的法力值不足！");
        return { damage: 0, retryPhysical: true };
    }

    const defenseFactor = (Math.random() * (1.2 - 0.8) + 0.8);
    const x = battleState.enemy.magicDefense * defenseFactor;
    const effectiveDefense = f(x);
    const constantDamageReduction = Math.round(battleState.enemy.magicDefense * 0.1);
    
    let baseDamage;
    
    if (effectiveDefense !== 0){
        baseDamage = Math.max(1, Math.floor(battleAttributes.magicAttack * 0.8 * skillMultiplier * (1 - effectiveDefense)));
    } else {
        baseDamage = Math.max(1, Math.floor(battleAttributes.magicAttack * 0.8 * skillMultiplier));
    }
    
    const manaCost = Math.floor((Math.random() * (200 - 50 + 1)) + 50 + battleRounds * 20 * skillMultiplier) * manaCostMultiplier;
    battleAttributes.mana = Math.max(0, battleAttributes.mana - manaCost);

    if (handleMagicDodge('enemy')) {
        playerTurn = false;
        return 0;
    }
    
    let isCritical = checkCriticalHit(playerCritRate);

    // 在所有效果应用后计算最终伤害
    let finalDamage = calculateDamage(baseDamage, isCritical, playerCritDamage, true);

    // 如果存在火符的效果则还需要计算一层
    const activeEffects = applyWuxingEffects();
    let fireEffect = 0;
    if (activeEffects.fireAmulet && activeEffects.fireAmulet > 0) {
        const damageBoostPercentage = [0, 0.02, 0.05, 0.07, 0.12, 0.20, 0.22, 0.25, 0.28, 0.4][activeEffects.fireAmulet];
        fireEffect = Math.floor(finalDamage * damageBoostPercentage);
        finalDamage = Math.floor(finalDamage * (1 + damageBoostPercentage));

        if (!isNaN(fireEffect) && fireEffect > 0) {
            logBattleEvent(`🔴奥义·火之易伤！伤害增加了 ${fireEffect} 点。`, 'pink');
        } 
    }

    finalDamage = Math.max(1, finalDamage - constantDamageReduction);
    
    if (enemyRivival) {
        finalDamage = Math.floor(0.1 * finalDamage);
    }
    battleState.enemy.health = Math.max(0, battleState.enemy.health - finalDamage);
    
    // 记录日志
    if (isCritical) {
        logBattleEvent(`⚔️【玩家攻击】暴击！！本次对敌方造成了 ${finalDamage} 点法术伤害，消耗了 ${manaCost} 点法力值！`, 'red');
        updateDamageValue(finalDamage, false, 'damage', true); // 显示玩家伤害
        showEffect('playerEffect', 'https://pic.imgdb.cn/item/668a30dbd9c307b7e9c54fff.gif');
    } else {
        logBattleEvent(`⚔️【玩家攻击】你进行了法术攻击，造成了 ${finalDamage} 点法术伤害，消耗了 ${manaCost} 点法力值。`, 'wheat');
        updateDamageValue(finalDamage, false, 'damage'); // 显示玩家伤害
        showEffect('playerEffect', 'https://pic.imgdb.cn/item/668a30dbd9c307b7e9c54fff.gif');
    }

    if (waterAmuletTriggered) {
        updateDamageValue(finalDamage,false,'extra-damage')
    }
    
    if (battleState.enemy.pierced) {
        handlePierced(); // 处理穿透效果
    }

    if ((ascensionSkill.name === '法术精通' || secondAscensionSkill.name === '法术精通') &&
        Math.random() * 100 < (battleState.player.spellMasteryChance)) {
        performIndependentMagicAttack();
    }
    
    applyMagicAttackEffects(finalDamage, isSkillUsed ? skillMultiplier : 1);
    if (selectedSkill && selectedSkill.type === "MAE") {
        applySpecialSkillEffects(selectedSkill);
    }

    return { damage: finalDamage, retryPhysical: false };
}


function performIndependentMagicAttack() {
    const skillsArea = document.getElementById('skills-area');
    const skillDivs = Array.from(skillsArea.children);
    const selectedSkills = skillDivs
        .map(skillDiv => skillDiv.innerText.split(' ')[0])
        .map(skillName => currentPet.skills.find(skill => skill.name === skillName && skill.type === 'MA'))
        .filter(skill => skill);

    let skillMultiplier = 1;
    let skillLevel = 1;

    if (selectedSkills.length > 0) {
        const randomIndex = Math.floor(Math.random() * selectedSkills.length);
        const selectedSkill = selectedSkills[randomIndex];
        const result = calculateSkillLevelAndMultiplier(selectedSkill);
        skillLevel = result.skillLevel;
        skillMultiplier = result.skillMultiplier;
        logBattleEvent(`⚔️【玩家攻击】触发法术精通，你再次施放了 ${selectedSkill.name} ${skillLevel}级。`, 'wheat');
    } else {
        logBattleEvent("⚔️【玩家攻击】触发法术精通，但没有可用的法术攻击技能，使用普通法术攻击。",'wheat');
    }

    let manaCostMultiplier = 1;
    if (battleState.player.spellSlow) {
        manaCostMultiplier = 500;
        logBattleEvent("邪佞令你对法术的操控更迟钝了，你耗费了更多的法力值！", 'grey');
    }

    const defenseFactor = (Math.random() * (1.2 - 0.8) + 0.8);
    const x = battleState.enemy.magicDefense * defenseFactor;
    const effectiveDefense = f(x);
    const constantDamageReduction = Math.round(battleState.enemy.magicDefense * 0.1);

    let baseDamage;
    if (effectiveDefense !== 0){
        baseDamage = Math.max(1, Math.floor(battleAttributes.magicAttack * 0.8 * skillMultiplier * (1 - effectiveDefense)));
    } else {
        baseDamage = Math.max(1, Math.floor(battleAttributes.magicAttack * 0.8 * skillMultiplier));
    }
    
    let isCritical = checkCriticalHit(playerCritRate);

    if (handleMagicDodge('enemy')) {
        playerTurn = false;
        return 0;
    }

    // 在所有效果应用后计算最终伤害
    let finalDamage = calculateDamage(baseDamage, isCritical, playerCritDamage, true);

    // 如果存在火符的效果则还需要计算一层
    const activeEffects = applyWuxingEffects();
    let fireEffect = 0;
    if (activeEffects.fireAmulet && activeEffects.fireAmulet > 0) {
        const damageBoostPercentage = [0, 0.02, 0.05, 0.07, 0.12, 0.20, 0.22, 0.25, 0.28, 0.4][activeEffects.fireAmulet];
        fireEffect = Math.floor(finalDamage * damageBoostPercentage);
        finalDamage = Math.floor(finalDamage * (1 + damageBoostPercentage));

        if (!isNaN(fireEffect) && fireEffect > 0) {
            logBattleEvent(`🔴奥义·火之易伤！伤害增加了 ${fireEffect} 点。`, 'pink');
        } 
    }

    finalDamage = Math.max(1, finalDamage - constantDamageReduction);
    
    if (enemyRivival) {
        finalDamage = Math.floor(0.1 * finalDamage);
    }
    battleState.enemy.health = Math.max(0, battleState.enemy.health - finalDamage);

    // 记录日志
    if (isCritical) {
        logBattleEvent(`⚔️【玩家攻击】暴击！！本次对敌方造成了 ${finalDamage} 点伤害。`, 'red');
        showEffect('playerEffect', 'https://pic.imgdb.cn/item/66a0d3e8d9c307b7e93a8108.gif');
    } else {
        logBattleEvent(`⚔️【玩家攻击】你造成了 ${finalDamage} 点伤害。`, 'wheat');
    }
    updateDamageValue(finalDamage,false,'extra-damage'); // 显示玩家伤害
    showEffect('playerEffect', 'https://pic.imgdb.cn/item/66712ba3d9c307b7e9f2ab59.gif');

    applyMagicAttackEffects(finalDamage, skillMultiplier); // 传递 damage 和 skillMultiplier 参数以应用效果
    if (battleState.enemy.pierced) {
        handlePierced(); // 处理穿透效果
    }

    // 处理醉酒效果
    if (battleState.player.drunken && finalDamage > 0) {
        const drunkenDamage = Math.floor(finalDamage * 0.1);
        battleAttributes.health = Math.max(0, battleAttributes.health - drunkenDamage);
        logBattleEvent(`醉酒状态下，你招式过猛误伤自身，受到 ${drunkenDamage} 点溅射伤害。`, '#FF0088');
    }

} //独立法伤

function performPoison() {
    if (!attributesFetched) {
        showInfoBox("请先从属性面板获取属性。");
        return;
    }

    if (!battleState || !battleState.enemy) {
        console.error("战斗状态未初始化");
        return;
    }

    if(!playerTurn) {
        return;
    }
    
    if (battleState.player.taunt) {
        performAttack('physical');
        return;
    }
    
    if (!poisonSkillActivated) {
        if (useItem('poisonSkillBook')) {
            poisonSkillActivated = true;
            logBattleEvent("你使用了施毒之术，现在可以对邪佞施毒了。", '#C10066');
        } else {
            logBattleEvent("你还没有获得施毒之术，请尝试通过武神仙葫获取！", 'red');
            return;
        }
    }
    
    const skillsArea = document.getElementById('skills-area');
    const skillDivs = Array.from(skillsArea.children);
    const selectedSkills = skillDivs
        .map(skillDiv => skillDiv.innerText.split(' ')[0])
        .map(skillName => currentPet.skills.find(skill => skill.name === skillName && (skill.type === 'PP' || skill.type === 'PPE')))
        .filter(skill => skill);

    let skillMultiplier = 1;
    let skillLevel = 1;
    let selectedSkill;

    if (selectedSkills.length > 0) {
        const randomIndex = Math.floor(Math.random() * selectedSkills.length);
        selectedSkill = selectedSkills[randomIndex];
        const result = calculateSkillLevelAndMultiplier(selectedSkill);
        skillLevel = result.skillLevel;
        skillMultiplier = result.skillMultiplier;

        logBattleEvent(`你施放了 ${selectedSkill.name} ${skillLevel}级 ，毒性大大加强。`, '#C10066');
    }

    const manaCost = Math.floor(maxMana * 0.4);
    if (battleAttributes.mana < manaCost) {
        logBattleEvent("您的法力值不足，无法使用施毒之法！", 'red');
        return;
    }

    battleAttributes.mana = Math.max(0, battleAttributes.mana - manaCost);

    if (handleMagicDodge('enemy')) {
        playerTurn = false;
        return;
    }

    let poisonChance = 0.3;
    if (useItem('poisonPowder')) {
        poisonChance = 0.7;
        skillMultiplier += 1;
    }
    
    const poisonDamage = Math.floor(battleAttributes.magicAttack * 0.5 * skillMultiplier * (Math.random() * (1.1 - 0.9) + 0.9));
    battleState.enemy.health = Math.max(0, battleState.enemy.health - poisonDamage);
    logBattleEvent(`你对邪佞造成了 ${poisonDamage} 点中毒伤害，消耗了 ${manaCost} 点法力值。`, '#C10066');
    if (battleState.enemy.pierced) {
        handlePierced(); // 处理穿透效果
    }
    showEffect('playerEffect', 'https://pic.imgdb.cn/item/66713185d9c307b7e9fe5fc6.gif');
    updateDamageValue(poisonDamage, false, 'damage'); // 显示玩家伤害


    if (Math.random() < poisonChance && !battleState.enemy.poisoned) {
        battleState.enemy.poisoned = true;
        handlePoison(skillMultiplier,selectedSkill); // 传递技能增益参数
    }
    
    handleShocked();
    handleManaRecover();
    applyAscensionEffects();
    updateUI();
    if (battleAttributes.health <= 0) {
        showNextBattlePrompt(false); // 玩家失败，传递失败状态
        return;
    } else if (battleState.enemy.health <= 0) {
        showNextBattlePrompt(true);
        return;
    }
    playerTurn = false;
} //中毒伤害函数

function handlePoison(skillMultiplier = 1, selectedSkill = null) {
    const basePoisonDuration = 1000; // 基础持续时间1秒
    const additionalPoisonDuration = Math.round(playerCultivation / 240000) * 1000; // 计算附加的持续时间，以毫秒为单位
    const totalPoisonDuration = basePoisonDuration + additionalPoisonDuration; // 总持续时间

    let remainingDuration = totalPoisonDuration; // 初始化剩余时间
    let totalPoisonDamage = 0; // 初始化总毒性伤害

    const poisonInterval = setInterval(() => {
        if (!battleState.enemy.poisoned) {
            clearInterval(poisonInterval);
            return;
        }
        const poisonDamage = Math.floor(battleAttributes.magicAttack * 0.5 * skillMultiplier * (Math.random() * (1.1 - 0.9) + 0.9) * (1 + playerCritDamage * 0.1));
        battleState.enemy.health = Math.max(0, battleState.enemy.health - poisonDamage);
        
        if (selectedSkill && selectedSkill.type === 'PPE') {
            applySpecialSkillEffects(selectedSkill, poisonDamage); //这里传递技能组的对象和毒性伤害值
        }
        
        totalPoisonDamage += poisonDamage; // 累积毒性伤害
        remainingDuration -= 1000; // 每次循环减少1秒

        updateUI();
        updateDamageValue(poisonDamage,false,'extra-damage');
        updateEnemyStatusDisplay();

    }, 200); // 每0.2秒触发一次
    
    if (battleState.enemy.health <= 0) {
        clearInterval(poisonInterval);
        showNextBattlePrompt(true);
        battleState.enemy.poisoned = false;
        return;
    }
    
    battleState.enemy.poisonedTimer = setTimeout(() => {
        battleState.enemy.poisoned = false;
        clearInterval(poisonInterval);
        updateEnemyStatusDisplay();
        logBattleEvent(`持续时间内，敌人一共受到 ${totalPoisonDamage} 点毒性伤害。`, '#C10066');
    }, totalPoisonDuration); // 动态调整中毒效果持续时间
}


//计算修为的效果时长增益
function getCultivationBonusDuration() {
    if (playerCultivation <= 120000) {
        return 0;
    }
    return Math.min(10, ((playerCultivation - 120000) / 10000) * 0.1);
}

function applyPhysicalAttackEffects() {
    if (!divineWeaponManager.lostBook.active) return;

    const effects = divineWeaponManager.lostBook.effects;
    const effect = effects[Math.floor(Math.random() * effects.length)];
    let triggerProbability = Math.min(1, 0.01 + (divineWeaponManager.lostBook.level - 1) * 0.006);
    
    // 计算修为差值对触发概率的影响
    const cultivationDifference = playerCultivation - battleState.enemy.cultivation;
    if (cultivationDifference < 0) {
        const reduction = Math.floor(-cultivationDifference / 10000) * 0.01;
        triggerProbability = Math.max(0.01, triggerProbability - reduction);
        console.log(`当前物理效果真实触发概率为：${triggerProbability}`);
    }
    
    if (Math.random() > triggerProbability) return; // 没有触发效果

    const cultivationBonus = getCultivationBonusDuration();

    switch (effect) {
        case '破甲':
            const armorBreakValue = Math.floor(battleAttributes.physicalAttack * (Math.random() * (0.24 - 0.12) + 0.12));
            battleState.enemy.physicalDefense -= armorBreakValue; // 破甲
            battleState.enemy.armorBreak = true;
            logBattleEvent(`邪佞的护甲被破坏，物理防御减少了 ${armorBreakValue} 点。`, 'white');
            showEffect('playerEffect', 'https://pic.imgdb.cn/item/66742a77d9c307b7e92c52b4.gif');
            updateEnemyStatusDisplay();
            battleState.enemy.armorBreakTimer = setTimeout(() => {
                battleState.enemy.physicalDefense += armorBreakValue;
                battleState.enemy.armorBreak = false;
                updateEnemyStatusDisplay();
            }, 3000 + cultivationBonus * 1000); // 破甲持续3秒
            break;
        case '眩晕':
            battleState.enemy.stunned = true; // 邪佞眩晕
            logBattleEvent("邪佞被眩晕，无法行动。", 'wheat');
            showEffect('playerEffect', 'https://pic.imgdb.cn/item/66742c80d9c307b7e930b160.gif');
            updateEnemyStatusDisplay();
            battleState.enemy.stunnedTimer = setTimeout(() => {
                battleState.enemy.stunned = false;
                updateEnemyStatusDisplay();
            }, 1000 + cultivationBonus * 1000); // 眩晕持续1秒
            break;
        case '恐吓':
            battleState.enemy.intimidated = true; // 邪佞恐吓状态
            logBattleEvent("邪佞被恐吓，无法暴击。", 'white');
            updateEnemyStatusDisplay();
            battleState.enemy.intimidatedTimer = setTimeout(() => {
                battleState.enemy.intimidated = false;
                updateEnemyStatusDisplay();
            }, 1000 + cultivationBonus * 1000); // 恐吓持续1秒
            break;
        case '穿透':
            if (!battleState.enemy.pierced) {
                handlePiercedEffect(cultivationBonus);
            } else {
                console.log('穿透效果持续中');
            }
            break;
        case '惶恐':
            if (!battleState.enemy.terrified) {
                handleTerrified(cultivationBonus);
            } else {
                console.log('惶恐效果持续中');
            }
            break;
        case '麻痹':
            if (!battleState.enemy.benumbed) {
                battleState.enemy.benumbed = true;
                battleState.enemy.originalMaxHealth = enemyMaxHealth;
                battleState.enemy.benumbStack = 0; // 初始化麻痹叠加计数
            }
            const benumbValue = Math.floor(battleState.enemy.originalMaxHealth * 0.03);
            enemyMaxHealth -= benumbValue;
            battleState.enemy.benumbStack += benumbValue; // 累积麻痹效果
            if (battleState.enemy.health > enemyMaxHealth) {
                battleState.enemy.health = enemyMaxHealth;
            }
            logBattleEvent(`邪佞被麻痹，最大生命值减少了 ${benumbValue} 点。`, 'lightblue');
            showEffect('playerEffect', 'https://pic.imgdb.cn/item/66a5d698d9c307b7e9718cb5.gif');
            updateEnemyStatusDisplay();
            battleState.enemy.benumbedTimer = setTimeout(() => {
                if (battleState.enemy.originalMaxHealth) {
                    battleState.enemy.benumbStack -= benumbValue; // 减少当前叠加效果
                    if (battleState.enemy.benumbStack <= 0) {
                        enemyMaxHealth = battleState.enemy.originalMaxHealth;
                        battleState.enemy.benumbed = false;
                    } else {
                        enemyMaxHealth = battleState.enemy.originalMaxHealth - battleState.enemy.benumbStack;
                    }
                }
                updateEnemyStatusDisplay();
            }, 3000 + cultivationBonus * 1000); // 麻痹持续3秒
            break;
    }
}

function applyMagicAttackEffects(damage) {
    if (!divineWeaponManager.fragmentedMap.active) return;

    const effects = divineWeaponManager.fragmentedMap.effects;
    const effect = effects[Math.floor(Math.random() * effects.length)];
    let triggerProbability = Math.min(1, 0.01 + (divineWeaponManager.fragmentedMap.level - 1) * 0.006);
    
    // 计算修为差值对触发概率的影响
    const cultivationDifference = playerCultivation - battleState.enemy.cultivation;
    if (cultivationDifference < 0) {
        const reduction = Math.floor(-cultivationDifference / 10000) * 0.01;
        triggerProbability = Math.max(0.01, triggerProbability - reduction);
        console.log(`当前法术效果真实触发概率为：${triggerProbability}`);
    }
    
    if (Math.random() > triggerProbability) return; // 没有触发效果

    const cultivationBonus = getCultivationBonusDuration();

    switch (effect) {
        case '沉默':
            battleState.enemy.silenced = true; // 邪佞沉默
            showEffect('playerEffect', 'https://pic.imgdb.cn/item/66a63612d9c307b7e9d72d78.gif');
            updateEnemyStatusDisplay();
            battleState.enemy.silencedTimer = setTimeout(() => {
                battleState.enemy.silenced = false;
                updateEnemyStatusDisplay();
            }, 3000 + cultivationBonus * 1000); // 沉默持续3秒
            break;
        case '迟缓':
            handleSlow(cultivationBonus);
            break;
        case '混乱':
            battleState.enemy.dazed = true; // 邪佞混乱
            showEffect('playerEffect', 'https://pic.imgdb.cn/item/66a63695d9c307b7e9d82c29.gif');
            updateEnemyStatusDisplay();
            battleState.enemy.dazedTimer = setTimeout(() => {
                battleState.enemy.dazed = false;
                updateEnemyStatusDisplay();
            }, 3000 + cultivationBonus * 1000); // 混乱持续3秒
            break;
        case '法力燃烧':
            const manaLoss = Math.floor(damage * 0.8);
            let healthLoss = 0;
        
            if (battleState.enemy.mana < manaLoss) {
                healthLoss = manaLoss - battleState.enemy.mana;
            }
            battleState.enemy.mana = Math.max(0, battleState.enemy.mana - manaLoss);
            battleState.enemy.health = Math.max(0, battleState.enemy.health - healthLoss);
        
            if (healthLoss > 0) {
                logBattleEvent(`敌人的法力已经燃烧殆尽，敌人开始燃烧生命之力！失去了 ${healthLoss} 点生命值。`, '#FF4500');
            } else {
                logBattleEvent(`法力燃烧！邪佞失去了 ${manaLoss} 点法力值。`, '#00BBFF');
            }
            showEffect('playerEffect', 'https://pic.imgdb.cn/item/66a5d698d9c307b7e9718c68.gif');
            break;
        case '法力吸取':
            const manaAbsorb = Math.floor(damage * 0.01);
            let actualManaAbsorb = Math.min(manaAbsorb, battleState.enemy.mana);
        
            battleState.enemy.mana = Math.max(0, battleState.enemy.mana - actualManaAbsorb);
            battleAttributes.mana = Math.min(maxMana, battleAttributes.mana + actualManaAbsorb);
        
            logBattleEvent(`你吸取了 ${actualManaAbsorb} 点法力值。`, '#00BBFF');
            showEffect('playerEffect', 'https://pic.imgdb.cn/item/66c44a29d9c307b7e967d02b.gif');
            break;
        case '灼烧':
            battleState.enemy.burnt = true;
            showEffect('playerEffect', 'https://pic.imgdb.cn/item/66a647c5d9c307b7e9f3c332.gif');
            updateEnemyStatusDisplay();
            battleState.enemy.burntTimer = setTimeout(() => {
                battleState.enemy.burnt = false;
                updateEnemyStatusDisplay();
            }, 3000 + cultivationBonus * 1000); // 灼烧持续3秒
            break;
    }
}

//具体的效果函数（分离后）
function handlePiercedEffect(cultivationBonus) {
    pierceDamageContainer.totalPierceDamage = 0; // 重置累积的穿透伤害
    battleState.enemy.pierced = true;
    logBattleEvent("邪佞被施加穿透效果，每次造成伤害时会附加真实伤害。穿透效果结束后会给予邪佞致命的余波伤害。", '#ADFF2F');
    showEffect('playerEffect', 'https://pic.imgdb.cn/item/66a647c5d9c307b7e9f3c43c.gif');
    updateEnemyStatusDisplay();

    battleState.enemy.piercedTimer = setTimeout(() => {
        if (battleState.enemy.pierced) {
            const aftershockDamage = Math.floor(pierceDamageContainer.totalPierceDamage * (Math.random() * (0.84 - 0.42) + 0.24) * (1 + playerCultivation / 500000));
            battleState.enemy.health = Math.max(0, battleState.enemy.health - aftershockDamage);
            logBattleEvent(`穿心蚀骨之毒爆！敌人承受了 ${aftershockDamage} 点穿透余波伤害。`, '#ADFF2F');
            updateDamageValue(aftershockDamage,false,'extra-damage');
            showBattleOverlay("https://pic.imgdb.cn/item/66a647c5d9c307b7e9f3c420.gif", 1500, 0.8);
            pierceDamageContainer.totalPierceDamage = 0; // 重置累积的穿透伤害
            battleState.enemy.pierced = false; // 清除穿透状态
        }
        updateUI();
        updateEnemyStatusDisplay();
    }, 3000 + cultivationBonus * 1000); // 穿透效果持续3秒
}

function handlePierced() {
    if (!battleState.enemy.pierced) return;

    const extraDamage = Math.floor(battleAttributes.physicalAttack * 5);
    battleState.enemy.health = Math.max(0, battleState.enemy.health - extraDamage);
    logBattleEvent(`敌人受到 ${extraDamage} 点穿透伤害。`, '#ADFF2F');
    updateDamageValue(extraDamage,false,'extra-damage');
    pierceDamageContainer.totalPierceDamage += extraDamage; // 累积穿透伤害
    updateUI();

    if (battleState.enemy.health <= 0) {
        showNextBattlePrompt(true);
        return;
    }
}

function handleStunned() {
    if (battleState.enemy.stunned) {
        logBattleEvent("邪佞眩晕，无法行动。", 'wheat');
        playerTurn = true;
        return true;
    }
    return false;
}

function handleCriticalAndDrunken(damage) {
    let isCritical = checkCriticalHit(playerCritRate);

    if ((ascensionSkill.name === '灵魂穿刺' || secondAscensionSkill.name === '灵魂穿刺') && isCritical && Math.random() < battleState.player.extraCritDamageChance) {
        const extraDamage = Math.floor(battleAttributes.physicalAttack * battleState.player.extraCritDamageMultiplier);
        battleState.enemy.health = Math.max(0, battleState.enemy.health - extraDamage);
        updateDamageValue(extraDamage,false,'extra-damage');
        logBattleEvent(`灵魂穿刺触发，额外造成了 ${extraDamage} 点伤害。`, 'red');
    }

    // 调用处理醉酒状态的函数
    handleDrunken(damage);
} //处理灵魂穿刺和醉酒（醉酒调用敌人醉酒函数）

function handleSlow(cultivationBonus) {
    const slowAmount = Math.floor(battleState.enemy.speed * 0.25);
    battleState.enemy.speed -= slowAmount; // 速度降低
    battleState.enemy.slow = true;
    showEffect('playerEffect', 'https://pic.imgdb.cn/item/66742c80d9c307b7e930b159.gif');
    updateEnemyStatusDisplay();
    battleState.enemy.slowTimer = setTimeout(() => {
        battleState.enemy.speed += slowAmount;
        battleState.enemy.slow = false;
        updateEnemyStatusDisplay();
    }, 3000 + cultivationBonus * 1000); // 迟缓持续3秒
}

function handleTerrified(cultivationBonus) {
    const weakenAmount = Math.floor(battleAttributes.physicalAttack * 1);
    
    // 确保物理攻击值不会降到0以下
    if (battleState.enemy.physicalAttack - weakenAmount < 0) {
        weakenAmount = battleState.enemy.physicalAttack; // 将削弱量调整为当前物理攻击值
    }
    
    battleState.enemy.physicalAttack -= weakenAmount; // 物理攻击降低
    battleState.enemy.terrified = true;

    showEffect('playerEffect', 'https://pic.imgdb.cn/item/66c43d02d9c307b7e954d4f7.gif');
    updateEnemyStatusDisplay();
    updateUI();

    battleState.enemy.terrifiedTimer = setTimeout(() => {
        battleState.enemy.physicalAttack += weakenAmount;
        battleState.enemy.terrified = false;
        updateEnemyStatusDisplay();
        updateUI();
    }, 3000 + cultivationBonus * 1000); // 惶恐持续3秒
}
        
function handleBurnt() {
    if (battleState.enemy.burnt) {
        let burntDamage = 0;
        const speedDifference = battleState.player.speed - battleState.enemy.speed;

        if (speedDifference > 0) { // player speed > enemy speed
            burntDamage = 2000 + speedDifference * 50;
        } else { // enemy speed >= player speed
            burntDamage = 1000 + Math.abs(speedDifference) * 25;
        }

        battleState.enemy.health = Math.max(0, battleState.enemy.health - burntDamage);
        logBattleEvent(`邪佞受到了 ${burntDamage} 点灼烧伤害。`, 'red');
        updateDamageValue(burntDamage,false,'extra-damage');
        updateUI();

        if (battleState.enemy.health <= 0) {
            showNextBattlePrompt(true);
            return;
        }
    }
}

function handleDazed() {
    if (battleState.enemy.dazed) {
        if (Math.random() < 0.5) {
            const selfDamage = battleState.enemy.physicalAttack;
            battleState.enemy.health = Math.max(0, battleState.enemy.health - selfDamage);
            logBattleEvent(`混乱状态下，敌人攻击了自己，造成了 ${selfDamage} 点伤害。`, 'white');
            updateDamageValue(selfDamage, false, 'damage');
            playerTurn = true;
            return true;
        }
    }
    return false;
}

let alreadyUseMushroom = false;
function handleMushroom() {
    if (alreadyUseMushroom || summonEnemy) {
        showInfoBox('现在无法使用，生效失败！',null,null,'red');
        return;
    }
    alreadyUseMushroom = true;
    const originalEnemyState = JSON.parse(JSON.stringify(enemyPet));
    const reducedEnemyState = {
        health: Math.round(enemyPet.health * 0.5),
        mana: Math.round(enemyPet.mana * 0.5),
        physicalAttack: Math.round(enemyPet.physicalAttack * 0.5),
        physicalDefense: Math.round(enemyPet.physicalDefense * 0.5),
        magicAttack: Math.round(enemyPet.magicAttack * 0.5),
        magicDefense: Math.round(enemyPet.magicDefense * 0.5),
        speed: Math.round(enemyPet.speed * 0.5),
        cultivation: Math.round(enemyPet.cultivation * 1)
    };

    enemyPet = reducedEnemyState;
    enemyMaxHealth = enemyPet.health;
    enemyMaxMana = enemyPet.mana;
    battleState.enemy = { ...enemyPet };

    logBattleEvent("使用见手青，敌人的所有能力降至50%直至本轮战斗胜利。", 'silver');
    // 在战斗回合结束时恢复敌人的原始状态
    function restoreOriginalEnemyState() {
        if (battleState.playerWon) {
            enemyPet = originalEnemyState;
            enemyMaxHealth = enemyPet.health;
            enemyMaxMana = enemyPet.mana;
            battleState.enemy = { ...enemyPet };
            updateEnemyAttributes();
        }
    }
    // 监听战斗回合结束事件，恢复敌人的原始状态
    const originalShowNextBattlePrompt = showNextBattlePrompt;
    showNextBattlePrompt = function(playerWon) {
        alreadyUseMushroom = false;
        restoreOriginalEnemyState();
        originalShowNextBattlePrompt(playerWon);
        showNextBattlePrompt = originalShowNextBattlePrompt;
    };
} //特殊战斗效果函数，由见手青触发

function handleSleep() {
    if (battleState.enemy.sleep) {
        return; // 如果已经处于睡眠状态，直接返回
    }

    const enemyHealthAtSleep = battleState.enemy.health; // 记录进入沉睡状态时的敌人生命值
    console.log(`睡眠时刻的敌人生命值为${enemyHealthAtSleep}`);
    battleState.enemy.sleep = true;
    logBattleEvent(`🧚🏻‍♀️对方在精灵的低语里陷入沉睡`, "pink");

    const sleepDuration = 10000; // 沉睡持续时间10秒
    const healInterval = 500; // 每0.5秒回血

    const healTimer = setInterval(() => {
        if (!battleState.enemy.sleep) {
            clearInterval(healTimer);
            return;
        }
        battleState.enemy.health = Math.min(enemyMaxHealth, battleState.enemy.health + Math.round(enemyMaxHealth * 0.005));
        updateUI(); // 更新 UI
    }, healInterval);

    const sleepTimer = setTimeout(() => {
        clearInterval(healTimer);
        battleState.enemy.sleep = false;
        logBattleEvent(`敌人从沉睡中醒来了。`, "pink");
        updateUI();
    }, sleepDuration);

    // 监听敌人的生命值变化，提前解除沉睡状态
    const monitorHealth = setInterval(() => {
        if (battleState.enemy.health < enemyHealthAtSleep) {
            clearInterval(healTimer);
            clearTimeout(sleepTimer);
            clearInterval(monitorHealth); // 停止监测
            battleState.enemy.sleep = false;
            logBattleEvent(`敌人被攻击惊醒。`, "pink");
            updateUI();
        }
    }, 100); // 每0.1秒检测一次
}//特殊战斗效果函数，由精灵触发




function getShieldStatus() {
    if (extraShield !== 0) {
        battleState.player.shielded = true;
    } else {
        battleState.player.shielded = false;
    }
}

// 【玩家辅助】玩家回血、产盾函数
function performHeal() {
    if (!attributesFetched) {
        showInfoBox("请先从属性面板获取属性。");
        return;
    }

    if(!playerTurn) {
        return;
    }
    
    if (battleState.player.taunt) {
        performAttack('physical');
        return;
    }
    
    let manaCostMultiplier = 1;
    if (battleState.player.spellSlow) {
        manaCostMultiplier = 500;
        logBattleEvent("邪佞令你对法术的操控更迟钝了，你耗费了更多的法力值！", 'blue');
    }
    
    
    const skillsArea = document.getElementById('skills-area');
    const skillDivs = Array.from(skillsArea.children);
    const selectedSkills = skillDivs
        .map(skillDiv => skillDiv.innerText.split(' ')[0])
        .map(skillName => currentPet.skills.find(skill => skill.name === skillName && (skill.type === 'PH' || skill.type === 'PHE')))
        .filter(skill => { return skill; });

    let skillMultiplier = 1;
    let skillLevel = 1;
    let selectedSkill;
        
    if (selectedSkills.length > 0) {
        const randomIndex = Math.floor(Math.random() * selectedSkills.length);
        selectedSkill = selectedSkills[randomIndex];
        const result = calculateSkillLevelAndMultiplier(selectedSkill);
        skillLevel = result.skillLevel;
        skillMultiplier = result.skillMultiplier;
        logBattleEvent(`你正在施放恢复技能 ${selectedSkill.name} ${skillLevel}级。`, 'aqua');
    }

    const healAmount = handleHealingBan(skillMultiplier);

    if (battleAttributes.health + healAmount > maxHealth) {
        // 溢出部分转化为护盾
        const overflowAmount = battleAttributes.health + healAmount - maxHealth;
        const shieldAmount = Math.floor(overflowAmount * 0.01);
        extraShield += shieldAmount;
        console.log(`护盾为${extraShield}`);
    }
        
    const manaCost = Math.round(388 * battleRounds * skillLevel * 0.1) * manaCostMultiplier;
    if (battleAttributes.mana < manaCost) {
        logBattleEvent("您的法力值不足，无法治疗！", 'red');
        return;
    }
        
    battleAttributes.health = Math.min(maxHealth, battleAttributes.health + healAmount);
    battleAttributes.mana = Math.max(0, battleAttributes.mana - manaCost);
    
    logBattleEvent(`🔮【玩家治疗】你恢复了 ${healAmount} 点生命值，消耗了 ${manaCost} 点法力值。`, 'aqua');
    showEffect('enemyEffect', 'https://pic.imgdb.cn/item/66a5d698d9c307b7e9718c8f.gif');

    updateDamageValue(-healAmount, true, 'damage');
    handleDivineProtection(selectedSkills, skillLevel);
    
    if (selectedSkill && selectedSkill.type === 'PHE') {
        applySpecialSkillEffects(selectedSkill, healAmount);
    }

    handleManaRecover();
    applyAscensionEffects();
    getShieldStatus();
    updateUI();
    if (battleAttributes.health <= 0) {
        showNextBattlePrompt(false); // 玩家失败，传递失败状态
        return;
    } else if (battleState.enemy.health <= 0) {
        showNextBattlePrompt(true);
        return;
    }
    playerTurn = false; // 轮到邪佞回合
    setTimeout(() => enemyAttack(),350);
}


function handleDivineProtection(selectedSkills, skillLevel) {
    let divineProtectionChance = 0.05;
    let additionalDurationBySkill = 0;
    let additionalDurationByCultivation = 0;
    
    if (selectedSkills.length > 0) {
        divineProtectionChance += skillLevel * 0.01;
        additionalDurationBySkill += skillLevel * 0.1;
    }
    
    if (playerCultivation >= 64000) {
        additionalDurationByCultivation += playerCultivation / 12000 * 0.1;
    }
    
    let divineProtectionDuration = 3 + additionalDurationBySkill + additionalDurationByCultivation;
    console.log(`当前仙气护体持续时间为：${divineProtectionDuration}`);
    
    if (ascensionSkill.name === '天降甘霖' || secondAscensionSkill.name === '天降甘霖') {
        divineProtectionChance = battleState.player.divineProtectionChance || 0.5;
        divineProtectionDuration = battleState.player.divineProtectionDuration || 5;
    }
    
    if (Math.random() < divineProtectionChance) {
        battleState.player.divineProtection = true;
        logBattleEvent("你获得了仙气护体状态，受到伤害时会恢复生命值。", 'aqua');
        updatePlayerStatusDisplay();
        setTimeout(() => {
            battleState.player.divineProtection = false;
            updatePlayerStatusDisplay();
        }, divineProtectionDuration * 1000);
    }
}

let GQreflectPercentage;
        
function handleReflectAndHeal(damage) {
    // 确保 damage 是有效的数字
    if (isNaN(damage) || damage <= 0) {
        console.error("Invalid damage value:", damage);
        return;
    }

    // 处理以牙还牙技能的反弹逻辑
    if (ascensionSkill.name === '以牙还牙' || secondAscensionSkill.name === '以牙还牙') {
        const baseReflectPercentage = (45 + 2 * ascensionSkill.level) / 100;
        const randomAddition = Math.random() * 15;
        const reflectPercentage = baseReflectPercentage + randomAddition / 100;
    
        if (!isNaN(reflectPercentage) && reflectPercentage > 0) {
            let reflectDamage = Math.floor(damage * reflectPercentage);
    
            if (isNaN(reflectDamage)) {
                reflectDamage = 0;
                console.error("Reflect damage is NaN, setting to 0.");
            }
    
            // 计算反弹伤害的最大值
            const maxReflectDamage = Math.round((battleAttributes.physicalAttack + battleAttributes.magicAttack) * 5);
    
            // 确保反弹伤害不超过最大值
            if (reflectDamage > maxReflectDamage) {
                reflectDamage = maxReflectDamage;
            }
    
            battleState.enemy.health = Math.max(0, battleState.enemy.health - reflectDamage);
            logBattleEvent(`以牙还牙触发，反弹了 ${reflectDamage} 点伤害给邪佞。`, 'red');
            console.log(`Current reflectPercentage is ${reflectPercentage}`);
        } else {
            console.error("Invalid reflectPercentage:", reflectPercentage);
        }
    }

    // 处理罡气反弹状态的逻辑
    if (battleState.player.reflecting && GQreflectPercentage !== null) {
        let reflectPercentage = GQreflectPercentage;
        let reflectDamage = Math.max(1000, Math.floor(damage * reflectPercentage));
        console.log(`当前反弹比例为${reflectPercentage}`);
        if (isNaN(reflectDamage)) {
            reflectDamage = 0;
            console.error("Reflect damage is NaN, setting to 0.");
        } 
        battleState.enemy.health = Math.max(0, battleState.enemy.health - reflectDamage);
        logBattleEvent(`反弹状态触发，反弹了 ${reflectDamage} 点真实伤害给邪佞。`);
    }

    // 处理金符效果的反弹逻辑
    const activeEffects = applyWuxingEffects();
    if (activeEffects.goldAmulet && activeEffects.goldAmulet > 0) {
        const goldReflectPercentage = [0, 0.02, 0.05, 0.07, 0.12, 0.20, 0.22, 0.25, 0.28, 0.4][activeEffects.goldAmulet];
        if (!isNaN(goldReflectPercentage) && goldReflectPercentage > 0) {
            let reflectDamage = Math.floor(damage * goldReflectPercentage);
            if (isNaN(reflectDamage)) {
                reflectDamage = 0;
                console.error("Reflect damage is NaN, setting to 0.");
            }
            battleState.enemy.health = Math.max(0, battleState.enemy.health - reflectDamage);
            logBattleEvent(`🟡奥义·金之境界！反弹了 ${reflectDamage} 点伤害。`, 'gold');
        } else {
            console.error("Invalid goldReflectPercentage:", goldReflectPercentage);
        }
    }
    
    // 处理仙气护体的治疗逻辑
    if (battleState.player.divineProtection) {
        let healAmount = Math.floor(3 * battleAttributes.magicAttack * (Math.random() * (0.12 - 0.08) + 0.2));
        if (isNaN(healAmount)) {
            healAmount = 0;
            console.error("Heal amount is NaN, setting to 0.");
        }
        battleAttributes.health = Math.min(maxHealth, battleAttributes.health + healAmount);
        updateDamageValue(-healAmount,true,'extra-damage');
        logBattleEvent(`🔮【玩家治疗】仙气护体触发，恢复了 ${healAmount} 点生命值。`, 'aqua');
        showEffect('enemyEffect', 'https://pic.imgdb.cn/item/66a5d698d9c307b7e9718c7d.gif');
    }
}//处理仙气（包含反弹逻辑）

let resurrectionState = false;
let resurrectionTimesMap = new Map();  // 用 Map 来存储每个技能的复活次数

function checkResurrectionState(times) {
    resurrectionState = times > 0;
}

// 在战斗结束时重置复活状态和次数
function resetResurrectionState() {
    resurrectionTimesMap.clear();
    checkResurrectionState(0);
}

function handleResurrection(damage) {
    if (battleAttributes.health > damage) {
        return;
    }
    
    if (battleAttributes.health <= 0 && (ascensionSkill.name === '向死而生' || secondAscensionSkill.name === '向死而生')) {
        let skill = ascensionSkill.name === '向死而生' ? ascensionSkill : secondAscensionSkill;
        const manaCostPercentage = skill.baseValue + skill.increment(skill.level);
        const manaCost = Math.floor(maxMana * (manaCostPercentage / 100));
        if (battleAttributes.mana >= manaCost) {
            battleAttributes.health = 1;
            battleAttributes.mana -= manaCost;
            logBattleEvent('向死而生触发，生命值恢复至1，消耗大量法力值。', 'red');
            updateUI();
        }
        return;
    }

    const fhSkills = [];
    const skillsArea = document.getElementById("skills-area");
    if (skillsArea) {
        Array.from(skillsArea.children).forEach(skillDiv => {
            const skillName = skillDiv.innerText.split(' ')[0];
            const skill = currentPet.skills.find(skill => skill.name === skillName && skill.type === "FH");
            if (skill) {
                fhSkills.push(skill);
            }
        });
    }

    if (fhSkills.length === 0) return;

    for (const fhSkill of fhSkills) {
        const skillLevel = fhSkill.level || 1;
        const skillMultiplier = fhSkill.multiplier || 1;
        const resurrectionAllowedTimes = Math.ceil(skillMultiplier + skillLevel * 0.01);

        // 使用 Map 来跟踪每个技能的复活次数
        if (!resurrectionTimesMap.has(fhSkill.name)) {
            resurrectionTimesMap.set(fhSkill.name, 0);
        }
        let resurrectionTimes = resurrectionTimesMap.get(fhSkill.name);

        let remainResurrectionTimes = resurrectionAllowedTimes - resurrectionTimes;

        if (resurrectionTimes < resurrectionAllowedTimes && battleAttributes.health <= 0) {
            const healthRecovered = Math.round(maxHealth * (0.1 * skillMultiplier));
            battleAttributes.health += healthRecovered;
            resurrectionTimes++;  // 只增加该技能的复活次数
            resurrectionTimesMap.set(fhSkill.name, resurrectionTimes);  // 更新 Map 中的次数

            updateDamageValue(-healthRecovered, false, 'damage');
            logBattleEvent(`${fhSkill.name} ${skillLevel}级触发，复活并恢复 ${healthRecovered} 点生命值，本局战斗还能再生效${remainResurrectionTimes}次`, 'lime');
            checkResurrectionState(remainResurrectionTimes);
        } else if (resurrectionTimes >= resurrectionAllowedTimes) {
            resurrectionState = false;
            logBattleEvent(`${fhSkill.name} 已经无法再触发复活。`, 'gray');
            showNextBattlePrompt(false);
        }
        
        updateUI();
    }
}
        
function handleRelieveEffects() {
    const jkSkills = [];
    const skillsArea = document.getElementById("skills-area");

    if (skillsArea) {
        Array.from(skillsArea.children).forEach(skillDiv => {
            const skillName = skillDiv.innerText.split(' ')[0];
            const skill = currentPet.skills.find(skill => skill.name === skillName && (skill.type === "JK" || skill.type === "JKE"));
            if (skill) {
                jkSkills.push(skill);
            }
        });
    }

    if (jkSkills.length === 0) return;

    for (const jkSkill of jkSkills) {
        const skillLevel = jkSkill.level || 1;
        const skillMultiplier = jkSkill.multiplier || 0.01;
        const successRate = Math.min(0.1, skillLevel * skillMultiplier); // 成功率，最大值为0.1

        const randomValue = Math.random(); // 生成 [0, 1) 之间的随机小数
        if (randomValue < successRate) {
            clearEnemyEffect();
            logBattleEvent(`${jkSkill.name} ${skillLevel}级触发，成功解除敌人的控制效果！`, 'lime');
            console.log(jkSkill);
            
            if (jkSkill.type === "JKE") {
                applySpecialSkillEffects(jkSkill, value = null);
            }
        }
        updateUI();
    }
}
        
function performDefense() {
    if (!attributesFetched) {
        showInfoBox("请先从属性面板获取属性。");
        return;
    }

    if (!battleState || !battleState.enemy) {
        console.error("战斗状态未初始化");
        return;
    }

    if(!playerTurn) {
        return;
    }
        
    if (battleState.player.taunt) {
        performAttack('physical');
        return;
    }

    const skillsArea = document.getElementById('skills-area');
    const skillDivs = Array.from(skillsArea.children);
    const selectedSkills = skillDivs
        .map(skillDiv => skillDiv.innerText.split(' ')[0])
        .map(skillName => currentPet.skills.find(skill => skill.name === skillName && (skill.type === 'PD' || skill.type === 'PDE')))
        .filter(skill => skill);

    let skillMultiplier = 1;
    let selectedSkillName = '普通防御';
    let selectedSkill;
    
    if (selectedSkills.length > 0) {
        const randomIndex = Math.floor(Math.random() * selectedSkills.length);
        selectedSkill = selectedSkills[randomIndex];
        skillMultiplier = selectedSkill.multiplier;
        selectedSkillName = selectedSkill.name;
    }

    let defenseReduction = (Math.random() * (0.99 - 0.8) + 0.8) * skillMultiplier;

    battleState.player.defending = true;
    battleState.player.defenseReduction = defenseReduction;
    
    if (defenseReduction < 1){
        logBattleEvent(`🛡【玩家防御】你施放了防御技能 ${selectedSkillName}，本回合抵抗了 ${Math.floor(defenseReduction * 100)}% 伤害。`, 'orange');
    } else {
        logBattleEvent(`🛡【玩家防御】你施放了防御技能 ${selectedSkillName}，本回合抵抗了 ${Math.floor(defenseReduction * 100)}% 伤害，溢出值已形成护盾。`, 'orange');
    }
    
    showEffect('enemyEffect', 'https://pic.imgdb.cn/item/66a5d698d9c307b7e9718ca1.gif');

    if (selectedSkill && selectedSkill.type === 'PDE') {
        applySpecialSkillEffects(selectedSkill, value = null);
    }

    applyDefenseBonus(selectedSkillName);
    handleManaRecover();
    getShieldStatus();
    applyAscensionEffects();
    updateUI();
    if (battleAttributes.health <= 0) {
        showNextBattlePrompt(false); // 玩家失败，传递失败状态
        return;
    } else if (battleState.enemy.health <= 0) {
        showNextBattlePrompt(true);
        return;
    }
    playerTurn = false;
}

function handleDamageReduction(damage, isCritical = false) {
    let initialDamage = damage;
    let totalDamageReduction = 0;
    let shieldReduction = 0;
    let defenseReduction = 0;
    let finalDamage = damage;

    // 获取当前生效的五行符效果
    const activeEffects = applyWuxingEffects();

    // 处理智慧守护的减伤逻辑
    finalDamage = handleWiseDefense(finalDamage);

    // 检查是否触发“无我之境”
    if ((ascensionSkill.name === '无我之境' || secondAscensionSkill.name === '无我之境') && Math.random() < battleState.player.invincibilityChance) {
        finalDamage = 0;
        logBattleEvent("遁入无我之境！", 'silver');
        showBattleOverlay("https://pic.imgdb.cn/item/66b86c3ad9c307b7e93202e9.gif", 3000, 0.8);
        return;
    }

    if (isNaN(finalDamage)) {
        finalDamage = 0;
        console.error("Damage is NaN, setting to 0.");
    }

    // 处理护盾的伤害吸收
    if (extraShield > 0) {
        const shieldBefore = extraShield;
        finalDamage -= extraShield;
        if (finalDamage < 0) {
            extraShield = -finalDamage;
            finalDamage = 0;
        } else {
            extraShield = 0;
        }
        shieldReduction = shieldBefore - extraShield;
    }

    // 飞升技能的伤害减免处理
    const damageReductionPercentage = battleState.player.damageReductionPercentage / 100;
    if (damageReductionPercentage > 0) {
        const reduction = Math.floor(finalDamage * damageReductionPercentage);
        finalDamage -= reduction;
        totalDamageReduction += reduction;
    }

    // 防御状态下的伤害减免处理
    if (battleState.player.defending) {
        const defenseReductionPercentage = battleState.player.defenseReduction;
        const reduction = Math.floor(finalDamage * defenseReductionPercentage);

        if (defenseReductionPercentage > 1) {
            extraShield += Math.floor(finalDamage * (defenseReductionPercentage - 1));
        }

        finalDamage -= reduction;
        defenseReduction += reduction;
        battleState.player.defending = false;
    }

    // 处理土符效果的伤害减免
    if (activeEffects.earthAmulet && activeEffects.earthAmulet > 0) {
        const earthReductionPercentage = [0, 0.02, 0.05, 0.07, 0.12, 0.20, 0.22, 0.25, 0.28, 0.4][activeEffects.earthAmulet];
        const earthReduction = Math.floor(finalDamage * earthReductionPercentage);
        finalDamage -= earthReduction;
        totalDamageReduction += earthReduction;
        logBattleEvent(`🟤奥义·土之庇护！你减少了 ${earthReduction}点所受的伤害。`, 'brown');
    }

    // 计算最终伤害并更新玩家血量
    const rightBattleAttributesHealth = battleAttributes.health;
    battleAttributes.health = Math.max(0, battleAttributes.health - finalDamage);
    if (battleAttributes.health > rightBattleAttributesHealth) {
        battleAttributes.health = rightBattleAttributesHealth;
    }

    // 记录最终的伤害减免和伤害值
    const finalDamageReduction = shieldReduction + defenseReduction + totalDamageReduction + (isNaN(wiseDefense) ? 0 : wiseDefense);

    const formattedFinalDamageReduction = isNaN(finalDamageReduction) ? 0 : finalDamageReduction;
    const formattedFinalDamage = isNaN(finalDamage) ? 0 : finalDamage;
    const formattedExtraShield = isNaN(extraShield) ? 0 : extraShield;

    // 打印战斗日志并更新UI
    if (formattedFinalDamage >= 0) {
        if (wiseDefenseManaCost != 0) {
            logBattleEvent(`智慧守护消耗${wiseDefenseManaCost}法力，减少了${formattedFinalDamageReduction}点伤害，你最终受到 ${formattedFinalDamage} 点伤害。`, 'yellow');
        } else {
            logBattleEvent(`格挡减少了${formattedFinalDamageReduction}点伤害，你最终受到 ${formattedFinalDamage} 点伤害。`, 'yellow');
        }
    } else {
        if (wiseDefenseManaCost != 0) {
            logBattleEvent(`智慧守护消耗${wiseDefenseManaCost}法力，减少了${formattedFinalDamageReduction}点伤害，溢出值转化为 ${Math.abs(formattedFinalDamage)} 点护盾。`, '#99FFFF');
        } else {
            logBattleEvent(`格挡为你减少了${formattedFinalDamageReduction}点伤害，溢出值转化为 ${Math.abs(formattedFinalDamage)} 点护盾。`, '#99FFFF');
        }
    }
    wiseDefenseManaCost = 0;
    handleReflectAndHeal(formattedFinalDamage);
    if (isCritical) {
        updateDamageValue(formattedFinalDamage, true, 'damage', true); // 显示敌人伤害
    } else {
        updateDamageValue(formattedFinalDamage, true, 'damage'); // 显示敌人伤害
    }
    

    console.log(`护盾抵挡了 ${shieldReduction} 点伤害，土符抵挡了${totalDamageReduction}，格挡技能抵挡 ${defenseReduction} 点伤害，智慧守护抵挡${isNaN(wiseDefense) ? 0 : wiseDefense}点伤害，目前护盾量为 ${formattedExtraShield}，你最终受到了  ${formattedFinalDamage}  点伤害。`);
    getShieldStatus();
}

function handleWiseDefense(damage) {
    const shSkills = [];
    const skillsArea = document.getElementById("skills-area");
    if (skillsArea) {
        Array.from(skillsArea.children).forEach(skillDiv => {
            const skillName = skillDiv.innerText.split(' ')[0];
            const skill = currentPet.skills.find(skill => skill.name === skillName && skill.type === "SH");
            if (skill) {
                shSkills.push(skill);
            }
        });
    }

    if (shSkills.length === 0) return damage;

    let finalDamage = damage;

    for (const shSkill of shSkills) {
        const { skillLevel, skillMultiplier } = calculateSkillLevelAndMultiplier(shSkill);
        const damageReductionPercentage = Math.min(0.6, 0.4 + skillLevel * 0.01);
        const defenseFactor = 1 + 0.05 * (skillLevel - 1);
        const reservePercentage = Math.max(0, 0.19 - 0.01 * (skillLevel - 1));
        const maxManaUsed = Math.floor(battleAttributes.mana * (1 - reservePercentage));
        const maxDamageToCancel = Math.round(finalDamage * damageReductionPercentage);
        const damageToCancel = Math.min(maxDamageToCancel, maxManaUsed * defenseFactor);
        const manaUsed = Math.min(maxManaUsed, Math.ceil(damageToCancel / defenseFactor));
        battleAttributes.mana -= manaUsed;
        finalDamage -= Math.round(manaUsed * defenseFactor);
        wiseDefense = Math.round(manaUsed * defenseFactor); //此变量用于外部调用该数值并进行显示
        wiseDefenseManaCost = manaUsed; //此变量用于外部调用该数值并进行显示

        console.log(`${shSkill.name} ${skillLevel}级消耗 ${manaUsed} 点法力值。`);
    }

    return finalDamage;
}


function applyDefenseBonus(selectedSkillName) {
    if (!battleState.player.defenseBonusCount) {
        battleState.player.defenseBonusCount = 0;
    }
    if (battleState.player.defenseBonusCount < 5) {
        battleState.player.defenseBonusCount += 1;

        const bonusCritRate = 0.06;
        const bonusCritDamage = 0.09;

        playerCritRate += bonusCritRate;
        playerCritDamage += bonusCritDamage;

        if (!battleState.player.defenseBonus) {
            battleState.player.defenseBonus = {
                critRate: 0,
                critDamage: 0
            };
        }
        battleState.player.defenseBonus.critRate += bonusCritRate;
        battleState.player.defenseBonus.critDamage += bonusCritDamage;
        battleState.player.defensing = true;
        updatePlayerStatusDisplay();
    } else {
        logBattleEvent(`防御增益已达到最大值，无法再增加。`, 'yellow');
    }
}

function applyDefenseBonusEffect() {
    if (battleState.player.defenseBonus) {
        const { critRate, critDamage } = battleState.player.defenseBonus;

        playerCritRate -= critRate;
        playerCritDamage -= critDamage;

        logBattleEvent(`你的蓄力增益效果已应用：${Math.round(critRate * 100)}% 暴击率和 ${Math.round(critDamage * 100)}% 暴击伤害。`, 'yellow');
        battleState.player.defenseBonusCount = 0;
        battleState.player.defenseBonus = null;
        battleState.player.defensing = false;
    }
}
        
function handleManaRecover() {
    const hlSkills = [];
    const skillsArea = document.getElementById("skills-area");
    if (skillsArea) {
        Array.from(skillsArea.children).forEach(skillDiv => {
            const skillName = skillDiv.innerText.split(' ')[0];
            const skill = currentPet.skills.find(skill => skill.name === skillName && skill.type === "HL");
            if (skill) {
                hlSkills.push(skill);
            }
        });
    }

    if (hlSkills.length === 0) return;

    for (const hlSkill of hlSkills) {
        const skillLevel = hlSkill.level || 1;
        const skillMultiplier = hlSkill.multiplier || 1;
        const manaRecoverPercentage = skillMultiplier + skillLevel * 0.01;
        const manaRecovered = Math.round(maxMana * manaRecoverPercentage);
        battleAttributes.mana = Math.min(maxMana, battleAttributes.mana + manaRecovered);
        logBattleEvent(`${hlSkill.name} ${skillLevel}级为你恢复了 ${manaRecovered} 点法力值。`, 'lightblue');
    }
} //被动回复法力值

let enemyActionInterval;  // 存储计时器ID

function decideEnemyCanPerform() {
    if (!battleState || !battleAttributes || !battleState.enemy) {
        console.error("战斗状态未初始化");
        return;
    }

    // 如果计时器已经存在，先清除它，避免重复触发
    if (enemyActionInterval) {
        clearInterval(enemyActionInterval);
    }

    const progressElement = document.getElementById('enemy-speed-bar');
    const barText = document.getElementById('speed-text');
    
    enemyActionInterval = setInterval(() => {
        if (!onBattleState) {
            return;
        }
        
        if (playerTurn) {
            const enemySpeedFactor = Math.max(0, battleState.enemy.speed * 2 / (battleState.enemy.speed + 100000));
            // 获取当前的宽度并去掉百分号
            const currentWidth = parseFloat(progressElement.style.width.replace('%', '')) || 0;
            // 更新进度条宽度
            progressElement.style.width = `${Math.min(100, currentWidth + enemySpeedFactor)}%`;

            // 当进度条满了（宽度 >= 100%）时，敌人发动攻击
            if (parseFloat(progressElement.style.width.replace('%', '')) >= 100) {
                progressElement.style.width = '0%';  // 重置进度条
                playerTurn = false;
                enemyAttack();  // 执行敌人的攻击行为
            }
            updateUI();  // 更新UI
        } else {
            setTimeout(enemyAttack(), 350);
        }
    }, 20);  // 每 20 毫秒执行一次
}

document.getElementById('enemy-speed-container').addEventListener('click', () => {
    showInfoBox('这是敌人的行动条，当轮到玩家回合但玩家未行动时，此行动条积满敌人将会行动。行动条的积累速度与敌人的当前速度有关。关闭战斗界面会停止积累。');
});

function stopEnemyAction() {
    // 清除计时器，停止敌人行动
    if (enemyActionInterval) {
        clearInterval(enemyActionInterval);
        enemyActionInterval = null;  // 重置计时器ID
    }
}
        
// 【怪物战斗】怪物伤害函数（物理/物理效果、法术/法术效果）
function enemyAttack() {
    if (!battleState || !battleAttributes || !battleState.enemy) {
        console.error("战斗状态未初始化");
        return;
    }

    if (!summonEnemy) {
        handleRampaged(); //再判断狂暴状态
    }

    if (playerTurn) {
        return;
    }
    
    handleRelieveEffects(); //先给玩家解控
    
    if (handleDazed()) return;
    if (handleStunned()) return;
    
    if (battleState.enemy.sleep) {
        playerTurn = true;
        return;
    }

    const enemyHealthPercentage = battleState.enemy.health / enemyMaxHealth;
    const enemyManaPercentage = battleState.enemy.mana / enemyMaxMana;
    const healProbability = enemyHealthPercentage < 0.3 ? 0.7 : 0.1;

    if (Math.random() < healProbability) {
        enemyHeal();
        return;
    }

    const defenseProbability = getRandomInt(0, 100);
    const defenseLine = enemyMaxHealth * 0.5;

    if (battleState.enemy.health <= defenseLine && defenseProbability <= 50) {
        enemyDefense();
        return;
    }
        
    if (handleEnemySteal(enemyHealthPercentage, enemyManaPercentage)) {
        updateUI();
        playerTurn = true;
        return;
    }

    let damage = 0;
    let isCritical = checkCriticalHit(enemyCritRate);

    if (battleState.enemy.intimidated) {
        isCritical = false;
    }

    const attackType = Math.random() < 0.5 ? 'physical' : 'magical';
    if (attackType === 'physical') {
        damage = performEnemyPhysicalAttack(isCritical);
    } else if (attackType === 'magical' && !battleState.enemy.silenced) {
        damage = performEnemyMagicalAttack(isCritical);
    } else {
        logBattleEvent("邪佞被沉默，无法进行法术攻击。", 'white');
    }
    handleBurnt();

    // 检查 damage 是否有效
    if (isNaN(damage) || damage <= 0) {
        console.error("Invalid damage value before reduction:", damage);
        damage = 0;
    }
    
    damage = handleDamageReduction(damage, isCritical); //计算伤害减免
    handleResurrection(damage);
    
    // 检查玩家和敌人的血量，更新战斗状态
    if (battleAttributes.health <= 0) {
        showNextBattlePrompt(false);
        return;
    } else if (battleState.enemy.health <= 0) {
        showNextBattlePrompt(true);
        return;
    } else {
        updateUI();
    }
    
    playerTurn = true; //轮到玩家回合
}


function performEnemyPhysicalAttack(isCritical) { 
    // 检查玩家是否闪避
    if (handleDodge('player')) {
        return 0; // 如果玩家闪避成功，物理攻击伤害为0
    }
   
    const defenseFactor = (Math.random() * (1.2 - 0.8) + 0.8);
    
    // 确保enemy-level的内容为数字并正确计算attackMultiplier
    const enemyLevel = parseInt(document.getElementById('enemy-level').innerText, 10) || 0;
    const attackMultiplier = 1 + (enemyLevel / 100);
    
    const x = battleAttributes.physicalDefense * defenseFactor;
    const effectiveDefense = f(x);
    const constantDamageReduction = Math.round(battleAttributes.physicalDefense * 0.1);

    let damage;
    if (effectiveDefense !== 0){
        damage = Math.max(1, Math.floor((battleState.enemy.physicalAttack * 1.2 * attackMultiplier) * (1 - effectiveDefense)));
    } else {
        damage = Math.max(1, Math.floor(battleState.enemy.physicalAttack * 1.2 * attackMultiplier));
    }
    
    damage = calculateDamage(damage, isCritical, enemyCritDamage);
    damage = Math.max(1, damage - constantDamageReduction);
    
    if (isCritical) {
        logBattleEvent(`⚔️【敌人攻击】邪佞施放物理技能·黑暗血刃并发起暴击，造成了 ${damage} 的猛烈伤害！`, 'red');
    } else {
        logBattleEvent(`⚔️【敌人攻击】邪佞施放物理技能·黑暗血刃，造成了 ${damage} 点伤害。`, 'white');
    }
    
    showEffect('enemyEffect', 'https://pic.imgdb.cn/item/66a0d3e8d9c307b7e93a8108.gif');

    // 新增规则判断
    if (battleState.player.slaughter) {
        const cultivationDiff = playerCultivation - enemyPetCultivation;
        let extraDamage = 0;

        if (cultivationDiff < 0) {
            // 玩家修为低于敌人修为
            const absM = Math.abs(cultivationDiff);
            enemyPhysicalAttackCount++;
            extraDamage = absM * enemyPhysicalAttackCount;
            logBattleEvent(`⚔️【敌人攻击】杀戮状态下由于修为差距，敌人本次物理攻击额外造成了 ${extraDamage} 点伤害！`, 'grey');
            updateDamageValue(extraDamage, true,'extra-damage');
        } else if (cultivationDiff > 0) {
            // 玩家修为高于敌人修为
            const mPlus = cultivationDiff;
            battleState.enemy.health -= mPlus;
            logBattleEvent(`⚔️【敌人攻击】杀戮状态下由于修为差距，敌人在施放物理攻击时自身损失了 ${mPlus} 点生命值！`, 'grey');
            updateDamageValue(extraDamage,false,'extra-damage');
        }

        damage += extraDamage;
    }

    if (!battleState.enemy.silenced || damage !== 0) {
        applyEnemyPhysicalEffects(damage); // 仅在未被沉默或有伤害时应用物理效果
    }
    
    return damage;
}

function performEnemyMagicalAttack(isCritical) {
    if (battleState.enemy.mana < 50) {
        enemyAttack('physical');
        return 0;
    }

    const enemyLevel = parseInt(document.getElementById('enemy-level').innerText, 10) || 0;
    const attackMultiplier = 1 + (enemyLevel / 100);
    
    const defenseFactor = (Math.random() * (1.2 - 0.8) + 0.8);
    const x = battleAttributes.magicDefense * defenseFactor;
    const effectiveDefense = f(x);
    const constantDamageReduction = Math.round(battleAttributes.magicDefense * 0.1);

    let damage;
    if (effectiveDefense !== 0){
        damage = Math.max(1, Math.floor(battleState.enemy.magicAttack * attackMultiplier * (1 - effectiveDefense)) - constantDamageReduction);
    } else {
        damage = Math.max(1, Math.floor(battleState.enemy.magicAttack * attackMultiplier) - constantDamageReduction);
    }
    
    damage = calculateDamage(damage, isCritical, enemyCritDamage);
    damage = Math.max(1, damage - constantDamageReduction);

    if (handleMagicDodge('player')) {
        return 0;
    }
    
    const manaCost = Math.floor(Math.random() * (100 - 50 + 1)) + 500;
    battleState.enemy.mana = Math.max(0, battleState.enemy.mana - manaCost);
    if (isCritical) {
        logBattleEvent(`⚔️【敌人攻击】邪佞施放法术技能·嗜血魔咒并发起暴击，造成了 ${damage} 的猛烈伤害！消耗了 ${manaCost} 点法力值。`, 'red');
        showEffect('enemyEffect', 'https://pic.imgdb.cn/item/66a0d3e8d9c307b7e93a8108.gif');
    } else {
        logBattleEvent(`⚔️【敌人攻击】邪佞施放法术技能·嗜血魔咒，造成了 ${damage} 点伤害，消耗了 ${manaCost} 点法力值。`, 'wheat');
    }
    
    showEffect('enemyEffect', 'https://pic.imgdb.cn/item/66717584d9c307b7e98a90e6.gif');

    // 应用邪佞法术效果
    applyEnemyMagicEffects(damage);
    
    return damage;
}

function applyEnemyPhysicalEffects(damage) {
    const effects = ['torn', 'suppressed', 'taunt', 'seal', 'slaughter'];
    
    const cultivationDifference = enemyPetCultivation - playerCultivation;
    const probabilityAdjustment = cultivationDifference / 10000 * 0.01;
    
    const triggeredEffects = [];
    
    effects.forEach(effect => {
        const baseChance = 0.2; // 基础触发概率为20%
        const adjustedChance = Math.max(0.01, baseChance + probabilityAdjustment);
        const effectChance = Math.random();

        //console.log(`Effect: ${effect}, 修为差：${cultivationDifference}, Effect Chance: ${effectChance}, Adjusted Chance: ${adjustedChance}`);

        if (battleState.player[effect]) {
            console.log(`玩家已经处于 ${effect} 状态，无法叠加。`);
            return;
        }

        if (effectChance < adjustedChance) {
            triggeredEffects.push(effect);
        }
    });
    
    if (triggeredEffects.length > 0) {
        const randomEffect = triggeredEffects[Math.floor(Math.random() * triggeredEffects.length)];
        
        switch (randomEffect) {
            case 'torn':
                if (!effectCooldowns.torn) {
                    handleTorn();
                }
                break;
            case 'suppressed':
                if (!effectCooldowns.suppressed) {
                    handleSuppressed();
                }
                break;
            case 'taunt':
                if (!battleState.player.taunt) {
                    handleTaunt();
                }
                break;
            case 'slaughter':
                if (!battleState.player.slaughter) {
                    handleSlaughter();
                }
                break;
            case 'seal':
                if (!battleState.player.seal) {
                    handleSeal();
                }
                break;
        }
    }
}

function applyEnemyMagicEffects(damage) {
    const effects = ['drunken', 'healingBan', 'soulCapture', 'blindfold', 'spellSlow'];
    
    const cultivationDifference = enemyPetCultivation - playerCultivation;
    const probabilityAdjustment = cultivationDifference / 10000 * 0.01;
    
    const triggeredEffects = [];
    
    effects.forEach(effect => {
        const baseChance = 0.2; // 基础触发概率为10%
        const adjustedChance = Math.max(0.01, baseChance + probabilityAdjustment);
        const effectChance = Math.random();

        //console.log(`Effect: ${effect}, 修为差：${cultivationDifference}, Effect Chance: ${effectChance}, Adjusted Chance: ${adjustedChance}`);
        
        if (effectChance < adjustedChance) {
            triggeredEffects.push(effect);
        }
    });
    
    if (triggeredEffects.length > 0) {
        const randomEffect = triggeredEffects[Math.floor(Math.random() * triggeredEffects.length)];
        
        switch (randomEffect) {
            case 'drunken':
                if (!effectCooldowns.drunken) {
                    battleState.player.drunken = true;
                    logBattleEvent("你受到了醉酒效果，每次攻击都会受到额外伤害。", '#FF0088');
                    showEffect('enemyEffect', 'https://pic.imgdb.cn/item/66742cffd9c307b7e931d5ee.gif');
                    effectCooldowns.drunken = true;
                    updatePlayerStatusDisplay();
                    setTimeout(() => {
                        battleState.player.drunken = false;
                        effectCooldowns.drunken = false;
                        updatePlayerStatusDisplay();
                    }, 5000);
                }
                break;
            case 'healingBan':
                if (!effectCooldowns.healingBan) {
                    battleState.player.healingBan = true;
                    logBattleEvent("你受到了禁疗效果，无法恢复生命值。", '#B94FFF');
                    showEffect('enemyEffect', 'https://pic.imgdb.cn/item/66742cffd9c307b7e931d5ee.gif');
                    effectCooldowns.healingBan = true;
                    updatePlayerStatusDisplay();
                    setTimeout(() => {
                        battleState.player.healingBan = false;
                        effectCooldowns.healingBan = false;
                        updatePlayerStatusDisplay();
                    }, 5000);
                }
                break;
            case 'soulCapture':
                if (!effectCooldowns.soulCapture) {
                    handleSoulCapture();
                }
                break;
            case 'spellSlow':
                if (!effectCooldowns.spellSlow) {
                    battleState.player.spellSlow = true;
                    showEffect('enemyEffect', 'https://pic.imgdb.cn/item/66742cffd9c307b7e931d5ee.gif');
                    effectCooldowns.spellSlow = true;
                    updatePlayerStatusDisplay();
                    setTimeout(() => {
                        battleState.player.spellSlow = false;
                        effectCooldowns.spellSlow = false;
                        updatePlayerStatusDisplay();
                    }, 5000);
                }
                break;
            case 'blindfold':
                if (!effectCooldowns.blindfold) {
                    battleState.player.blindfold = true;
                    logBattleEvent("你被附加了失明，施放物理技能时将无法对敌人造成伤害！", 'yellow');
                    showEffect('enemyEffect', 'https://pic.imgdb.cn/item/66742cffd9c307b7e931d5ee.gif');
                    effectCooldowns.blindfold = true;
                    updatePlayerStatusDisplay();
                    setTimeout(() => {
                        battleState.player.blindfold = false;
                        effectCooldowns.blindfold = false;
                        updatePlayerStatusDisplay();
                    }, 5000);
                }
                break;
        }
    }
}

function handleEnemySteal(enemyHealthPercentage, enemyManaPercentage) {
    if (enemyHealthPercentage < 0.05 && Math.random() < 0.5 && drugInventory['延寿露'] && drugInventory['延寿露'].quantity > 0) {
        if (Math.random() < 0.8) {
            const healthRecovered = Math.min(100000000, Math.floor(enemyMaxHealth * 0.2));
            battleState.enemy.health = Math.min(enemyMaxHealth, battleState.enemy.health + healthRecovered);
            drugInventory['延寿露'].quantity -= 1;
            logBattleEvent(`🥷【敌人偷窃】邪佞窥探了你的锦囊，吸收了一个来自你所拥有的延寿露的能量，恢复了${healthRecovered}点生命值。`, '#66CDAA');
            updateDamageValue(-healthRecovered, false, 'damage');
            showEffect('enemyEffect', 'https://pic.imgdb.cn/item/66a250dfd9c307b7e97f96eb.png');
        } else {
            logBattleEvent("🥷【敌人偷窃】邪佞想窃取你的资源，但被你抓包打跑了，你没受到任何损失", '#66CDAA');
            handleSlow(); // 直接应用迟缓效果
        }
        return true;
    } else if (enemyManaPercentage < 0.05 && Math.random() < 0.5 && drugInventory['天山雪莲'] && drugInventory['天山雪莲'].quantity > 0) {
        if (Math.random() < 0.8) {
            const manaRecovered = Math.min(50000000, Math.floor(enemyMaxMana * 0.2));
            battleState.enemy.mana = Math.min(enemyMaxMana, battleState.enemy.mana + manaRecovered);
            drugInventory['天山雪莲'].quantity -= 1;
            logBattleEvent(`🥷【敌人偷窃】邪佞窥探了你的锦囊，吸收了一个来自你所拥有的天山雪莲的能量，恢复了${manaRecovered}点法力值。`, '#66CDAA');
            showEffect('enemyEffect', 'https://pic.imgdb.cn/item/66a250dfd9c307b7e97f96eb.png');
        } else {
            logBattleEvent("🥷【敌人偷窃】邪佞想窃取你的资源，但你识破了，没受到任何损失", '#66CDAA');
            handleSlow(); // 直接应用迟缓效果
        }
        return true;
    }
    return false;
} //处理攻击途中偷窃行为

function handleSlaughter() {
    if (battleState.player.slaughter) {
        console.log("玩家已经处于杀戮状态，无法叠加。");
        return;
    }
    
    battleState.player.slaughter = true;
    effectCooldowns.slaughter = true;
    showEffect('enemyEffect', 'https://pic.imgdb.cn/item/66a33f39d9c307b7e942c36c.gif');
    updatePlayerStatusDisplay();

    const slaughterInterval = setInterval(() => {
        if (!battleState.player.slaughter) {
            clearInterval(slaughterInterval);
            return;
        }

        const cultivationDifference = playerCultivation - enemyPetCultivation;

        if (cultivationDifference > 0 && battleState.enemy.health <= cultivationDifference * 150) {
            battleState.enemy.health = 0;
            logBattleEvent(`⚔️【敌人攻击】道高一尺，魔高一丈，敌人低于你的修为，施法时损失${battleState.enemy.health}点生命值，被当即斩杀！`, '#FFDD55');
            updateDamageValue(battleState.enemy.health,false,'damage');
            updateUI();
            updatePlayerStatusDisplay();

        } else if (cultivationDifference < 0 && battleAttributes.health <= Math.abs(cultivationDifference)) {
            battleAttributes.health = 0;
            logBattleEvent(`⚔️【敌人攻击】道高一尺，魔高一丈，你低于敌人的修为，施法时损失${battleAttributes.health}点生命值，被当即斩杀！`, '#FFDD55');
            updateDamageValue(battleState.enemy.health,true,'damage');
            updateUI();
            updatePlayerStatusDisplay();
        }
    }, 500);

    if (battleAttributes.health <= 0) {
        showNextBattlePrompt(false); // 玩家失败，传递失败状态
        return;
    } else if (battleState.enemy.health <= 0) {
        showNextBattlePrompt(true);
        return;
    }
    
    setTimeout(() => {
        battleState.player.slaughter = false;
        effectCooldowns.slaughter = false;
        enemyPhysicalAttackCount = 0;
        clearInterval(slaughterInterval);
        updatePlayerStatusDisplay();
    }, 10000); // 杀戮效果持续10秒
} //处理杀戮状态

function handleShocked() {
    if (battleState.player.shocked) {
        battleAttributes.physicalDefense = Math.max(0, Math.floor(battleAttributes.physicalDefense * 0.8));
        battleAttributes.magicDefense = Math.max(0, Math.floor(battleAttributes.physicalDefense * 0.8));
    }
}
        
function handleSeal() {
    if (battleState.player.seal) {
        return;
    }

    battleState.player.seal = true;

    // 保存原始技能名称
    battleState.player.originalAscensionSkill = ascensionSkill.name;
    battleState.player.originalSecondAscensionSkill = secondAscensionSkill.name;

    // 设置封印技能名称
    ascensionSkill.name = "被封印的技能";
    secondAscensionSkill.name = "被封印的技能";
    updateAscensionDisplay();
    updateSecondAscensionDisplay();

    logBattleEvent("远古魔神的低吟充满离散心智的声量，令你短暂被封印了飞升技能带来的战斗增益。", 'aqua');

    // 封印效果持续时间
    setTimeout(() => {
        battleState.player.seal = false;

        // 恢复原始技能名称
        ascensionSkill.name = battleState.player.originalAscensionSkill;
        secondAscensionSkill.name = battleState.player.originalSecondAscensionSkill;
        
        logBattleEvent("封印解除，飞升技能可以发挥作用了。", 'aqua');
        updateAscensionDisplay();
        updateSecondAscensionDisplay();
        updateUI();
    }, 10000);
} //处理封印状态

function handleTorn() {
    battleState.player.torn = true;
    showEffect('enemyEffect', 'https://pic.imgdb.cn/item/669c8a9ed9c307b7e94f5766.gif');
    effectCooldowns.torn = true;
    updatePlayerStatusDisplay();
    const tornInterval = setInterval(() => {
        if (!battleState.player.torn) {
            clearInterval(tornInterval);
            return;
        }
        const tornDamage = Math.floor(battleState.enemy.physicalAttack * 0.1);
        battleAttributes.health = Math.max(0, battleAttributes.health - tornDamage);
        updateDamageValue(tornDamage,true,'extra-damage');
        updateUI();
        updatePlayerStatusDisplay();
        
    }, 500);
    
    if (battleAttributes.health <= 0) {
        showNextBattlePrompt(false); // 玩家失败，传递失败状态
        return;
    } else if (battleState.enemy.health <= 0) {
        showNextBattlePrompt(true);
        return;
    }

    setTimeout(() => {
        battleState.player.torn = false;
        effectCooldowns.torn = false;
        clearInterval(tornInterval);
        updatePlayerStatusDisplay();
    }, 10000); // 撕裂效果持续10秒
} //处理撕裂状态

const suppressionState = {
    actionPerformed: false,
    timeoutId: null
}; // 全局对象来管理压制状态及相关变量
function handleSuppressed() {
    if (battleState.player.suppressed) {
        return;
    }

    battleState.player.suppressed = true;
    logBattleEvent("你受到了压制效果，必须在3秒内进行有效操作。", '#FF4500');
    showEffect('enemyEffect', 'https://pic.imgdb.cn/item/669c8a9ed9c307b7e94f5766.gif');
    effectCooldowns.suppressed = true;
    updatePlayerStatusDisplay();

    suppressionState.actionPerformed = false; // 重置 actionPerformed

    const originalPerformPhysicalAttack = performPhysicalAttack;
    const originalPerformMagicalAttack = performMagicalAttack;
    const originalPerformHeal = performHeal;
    const originalPerformPoison = performPoison;
    const originalPerformDefense = performDefense;

    const wrappedAction = (originalFunction) => {
        return function(...args) {
            suppressionState.actionPerformed = true;
            return originalFunction.apply(this, args);
        };
    };

    performPhysicalAttack = wrappedAction(performPhysicalAttack);
    performMagicalAttack = wrappedAction(performMagicalAttack);
    performHeal = wrappedAction(performHeal);
    performPoison = wrappedAction(performPoison);
    performDefense = wrappedAction(performDefense);

    suppressionState.timeoutId = setTimeout(() => {
        cleanSuppressed();
    }, 3000); // 压制效果持续3秒
} //处理压制状态

let tauntTimeout; 
function handleTaunt() {
    if (battleState.player.taunt) {
        logBattleEvent("你已经被嘲讽,不能使用其他技能。", '#FF4500');
        return;
    }

    // 清除现有的嘲讽定时器（如果有）
    clearTimeout(tauntTimeout);

    battleState.player.taunt = true;
    logBattleEvent("邪佞极尽嬉笑怒骂之攻势,你未能压抑心中怒火,嘲讽时间内你只能对其使用物理攻击。", '#FF4500');
    showEffect('enemyEffect', 'https://pic.imgdb.cn/item/669c8a9ed9c307b7e94f5766.gif');
    effectCooldowns.taunt = true;

    // 更新状态显示和UI
    updatePlayerStatusDisplay();
    updateUI();

    // 设置新的嘲讽定时器
    tauntTimeout = setTimeout(() => {
        battleState.player.taunt = false;
        effectCooldowns.taunt = false;
        updatePlayerStatusDisplay();
        updateUI();
    }, 10000); // 嘲讽效果持续10秒
} // 处理嘲讽状态

function handleHealingBan(skillMultiplier) {
    if (battleState.player.healingBan) {
        return 0;
    }

    let baseHealing = Math.floor(3 * battleAttributes.magicAttack * (Math.random() * (0.12 - 0.08) + 0.08) * skillMultiplier);
    let woodEffect;
    const activeEffects = applyWuxingEffects();

    // 应用木符效果增加治疗量
    if (activeEffects.woodAmulet && activeEffects.woodAmulet > 0) {
        const healBoostPercentage = [0, 0.02, 0.05, 0.07, 0.12, 0.20, 0.22, 0.25, 0.28, 0.4][activeEffects.woodAmulet];
        const woodEffect = Math.floor(baseHealing * healBoostPercentage);
        baseHealing = Math.floor(baseHealing * (1 + healBoostPercentage));
        logBattleEvent(`🟢奥义·木之春意！治疗量增加了 ${woodEffect}。`, 'aqua');
    }

    return baseHealing;
} //处理计算回复量和禁疗状态

function handleSoulCapture() {
    if (battleState.player.soulCapture) {
        return;
    }
    
    battleState.player.soulCapture = true;
    battleAttributes.physicalAttack *= 0.5;
    battleAttributes.magicAttack *= 0.5;
    logBattleEvent("你受到了摄魂效果，攻击力大幅下降。", '#B94FFF');
    showEffect('enemyEffect', 'https://pic.imgdb.cn/item/66742cffd9c307b7e931d5ee.gif');
    updatePlayerStatusDisplay();
    
    setTimeout(() => {
        battleState.player.soulCapture = false;
        battleAttributes.physicalAttack = battleState.player.physicalAttack;
        battleAttributes.magicAttack = battleState.player.magicAttack;
        updateUI();
        updatePlayerStatusDisplay();
    }, 5000); // 摄魂效果持续5秒
} //处理摄魂
            
function handleDrunken(damage) {
    if (battleState.player.drunken && damage > 0) {
        const drunkenDamage = Math.floor(damage * 0.05);
        battleAttributes.health = Math.max(0, battleAttributes.health - drunkenDamage);
        logBattleEvent(`⚔️【敌人反弹】醉酒状态下，你招式过猛误伤自身，受到 ${drunkenDamage} 点溅射伤害。`, '#FF0088');
        updateDamageValue(drunkenDamage,true,'extra-damage');
    }
} //处理醉酒




// 【怪物辅助】怪物回血、增益等函数      
function enemyHeal() {
    if (enemyHealCount >= 20) {
        enemyAttack();
        return;
    }

    if (battleState.enemy.sleep) {
        return;
    }
    
    const manaCost = 288 * battleRounds;

    // 检查邪佞的法力值是否足够
    if (battleState.enemy.mana < manaCost) {
        performEnemyPhysicalAttack(false);
        return;
    }

    // 检查邪佞是否被沉默
    if (battleState.enemy.silenced) {
        logBattleEvent("由于邪佞被沉默，无法治疗", '#FFC8B4');
        performEnemyPhysicalAttack(false);
        return;
    }

    const healAmount = Math.floor(3 * battleState.enemy.magicAttack * (Math.random() * (1.2 - 0.8) + 0.8));
    battleState.enemy.health = Math.min(enemyMaxHealth, battleState.enemy.health + healAmount);
    battleState.enemy.mana = Math.max(0, battleState.enemy.mana - manaCost);
    enemyHealCount += 1; // 增加治疗次数

    logBattleEvent(`🔮【敌人治疗】邪佞施放魔王之力，恢复了 ${healAmount} 点生命值，消耗了 ${manaCost} 点法力值。`, 'aqua');
    showEffect('playerEffect', 'https://pic.imgdb.cn/item/66754252d9c307b7e9e67706.gif');
    updateDamageValue(-healAmount,false,'damage');

    // 检查中毒效果
    if (battleState.enemy.poisoned) {
        const poisonDamage = Math.floor(battleAttributes.magicAttack * battleRounds * (Math.random() * (0.06 - 0.03) + 0.03));
        battleState.enemy.health = Math.max(0, battleState.enemy.health - poisonDamage);
        logBattleEvent(`☣【敌人中毒】邪佞中毒，失去了 ${poisonDamage} 点生命值。`, '#C10066');
        updateDamageValue(poisonDamage,false,'extra-damage');
    }

    playerTurn = true; // 轮到玩家回合
    handleBurnt();
    showEffect('enemyEffect');
    updateUI();
}

function enemyDefense() {
    if (battleState.enemy.sleep) {
        return;
    }

    if (battleState.enemy.defensing) {
        enemyAttack();
        return;
    }

    battleState.enemy.defensing = true;
    const enemyPD = battleState.enemy.physicalDefense;
    const enemyMD = battleState.enemy.magicDefense;
    const defenseValue = Math.round((enemyPD + enemyMD) * 0.5);

    battleState.enemy.physicalDefense += defenseValue;
    battleState.enemy.magicDefense += defenseValue

    setTimeout(() => {
        battleState.enemy.defensing = false;
        battleState.enemy.physicalDefense = enemyPD;
        battleState.enemy.magicDefense = enemyMD;
        updateUI();
    },2000);
    
    playerTurn = true; // 轮到玩家回合
    logBattleEvent('🛡【敌人防御】敌人释放了能量场，双防得到了提升！','orange');
    showEffect('playerEffect', 'https://pic.imgdb.cn/item/66d4a22dd9c307b7e9f5faec.gif');
}

let enemyRivival = false;
let enemyRivivalCount = 0;
        
function handleRampaged() {
    console.log(`handleRampaged called. battleRounds: ${battleRounds}, enemy health: ${battleState.enemy.health}, enemyMaxHealth: ${enemyMaxHealth}`);
    if (summonEnemy) {
        return;
    }

    if (enemyRivival) {
        enemyRivival = false;
    }

    if (battleRounds === 150) {
        enemyCritRate = 1;
        enemyCritDamage = 3.5;
        battleState.enemy.rampaged = true;
        changeEnemyImage("mao");
        setBackgroundImage('https://pic.imgdb.cn/item/66bc6806d9c307b7e987b921.webp');
        console.log('Enemy is rampaged.');
    } else if (battleRounds > 150 && battleRounds % 10 === 0) {
        enemyCritRate = 1;
        enemyCritDamage = 3.5;
        battleState.enemy.rampaged = true;
        changeEnemyImage("darkShape");
        setBackgroundImage('https://pic.imgdb.cn/item/66bc6806d9c307b7e987b8ec.webp');
        console.log('Enemy is rampaged.');
    } else if (battleRounds <= 150 && battleRounds % 10 === 0) {
        enemyCritRate = 1;
        enemyCritDamage = 2.5;
        battleState.enemy.rampaged = true;
        changeEnemyImage("rampaged");
        setBackgroundImage('https://pic.imgdb.cn/item/66bc6806d9c307b7e987b921.webp');
        console.log('Enemy is rampaged.');
    } else {

        battleState.enemy.rampaged = false;
        changeEnemyImage(battleRounds > 150 ? "realShape" : "default");
        setBackgroundImage(battleRounds > 150 ? 'https://pic.imgdb.cn/item/66bc6806d9c307b7e987b907.webp' : 'https://pic.imgdb.cn/item/66bc6806d9c307b7e987b92d.webp');
        console.log('Enemy is not rampaged.');
    }

    // 检查并处理敌人复活机制
    if (battleState.enemy.rampaged && battleState.enemy.health < enemyMaxHealth * 0.2 && enemyRivivalCount <= (battleRounds === 150 ? 3 : 1)) {
        enemyRivivalCount += 1;
        logBattleEvent("邪佞的生命力正在复苏，请在2秒内击杀它，否则它将复活！", "red");
        enemyRivival = true;
        console.log(`Revival triggered. revivalCount: ${enemyRivivalCount}`);

        setTimeout(() => {
            // 重新检查敌人状态
            if (enemyRivival && battleState.enemy.health < enemyMaxHealth * 0.2) {
                battleState.enemy.health = enemyMaxHealth;
                logBattleEvent("邪佞复生成功，生命值恢复到100%！", "red");
                updateDamageValue(-enemyMaxHealth, false, 'damage');
                enemyRivival = false;
                updateUI();
                console.log('Enemy revived to full health.');
            }
        }, 2000);
    }
}
 //处理狂暴状态



        
// 【玩家战斗组件】药品系统函数
function useDrug() {
    if (!alreadyUseDrug) {
        showInfoBox("这是你第一次打开药品面板，附送至尊药品礼包一份！");
        alreadyUseDrug = true; // 修正拼写错误
    }
    
    if (battleState.player.taunt) {
        performAttack('physical');
        return;
    }
    
    document.getElementById('drug-modal').style.display = 'block';
    updateDrugGrid();
}

function updateDrugGrid() {
    const drugGrid = document.getElementById('drug-grid');
    drugGrid.innerHTML = '';
    for (let drug in drugInventory) {
        if (drugInventory[drug].quantity > 0) {
            const drugItem = document.createElement('div');
            drugItem.className = 'drug-item';
            drugItem.innerHTML = `
                <img src="${drugInventory[drug].url}" alt="${drug}" width="45" height="45">
                <div>${drug} <span>${drugInventory[drug].quantity}</span>个</div>
            `;
            drugItem.onclick = () => selectDrug(drug);
            drugGrid.appendChild(drugItem);
        }
    }

    // 更新选中药品的视觉效果
    if (selectedDrug) {
        const selectedDrugItem = Array.from(drugGrid.getElementsByClassName('drug-item'))
            .find(item => item.querySelector('div').innerText.startsWith(selectedDrug));
        if (selectedDrugItem) {
            selectedDrugItem.style.border = '2px solid white'; // 视觉提示
            selectedDrugItem.style.borderRadius = '10px'; // 视觉提示
            selectedDrugItem.style.padding = '5px'; // 视觉提示
        }
    }
}

function addDrugToInventory(drugKey, quantity = 1) {
    // 检查 drugInventory 中是否已有该药品
    if (drugInventory[drugKey]) {
        // 如果药品已经存在，增加数量
        drugInventory[drugKey].quantity += quantity;
    } else {
        // 如果药品不存在，创建新的药品并设定数量
        drugInventory[drugKey] = {
            quantity: quantity,
            url: 'https://pic.imgdb.cn/item/66cc940fd9c307b7e9cb77b1.png',
            tier: 0,
            description: '珍贵的神秘药材'
        };
    }
    updateDrugGrid();
    console.log(`${drugKey} 的数量已更新，当前数量: ${drugInventory[drugKey].quantity}`);
}
        
function closeDrugModal() {
    document.getElementById('drug-modal').style.display = 'none';
    selectedDrug = null;
    document.getElementById('drug-description').innerText = '选中药品后可直接使用，低品阶药品可合成更高品阶的药品。采集会花费金子，采集所得的原始药材只能用于合成。战斗精灵成长后，每次战斗胜利会有额外的掉落奖励。';
}

function selectDrug(drugName) {
    const drugDescriptionElement = document.getElementById('drug-description');
    selectedDrug = drugName;

    if (drugDescriptionElement) {
        drugDescriptionElement.innerText = drugInventory[drugName].description;
    }
    
    updateDrugGrid();
}

function useSelectedDrug() {
    if (!selectedDrug) {
        showInfoBox("请选择一种药品！");
        return;
    }

    if (activeBuffs[selectedDrug]) {
        showInfoBox(`${selectedDrug}效果尚在冷却中，无法叠加使用。`);
        return;
    }

    if (checkConflictingBuffs(selectedDrug)) {
        return;
    }

    const drug = drugInventory[selectedDrug];
    if (drug.quantity > 0) {
        drug.quantity -= 1;
        updateDrugGrid();

        switch (selectedDrug) {
            case "长生泉":
                applyDrugBonus0("health", 5000);
                updatePetInfo();
                logBattleEvent(`使用长生泉，你如获新生。`, 'gold');
                break;
            case "三花丸":
                const manaDuration = 3 * 1000; // 3 seconds
                const manaInterval = 1.5 * 1000; // 0.5 second
                const manaRegenAmount = Math.floor(maxMana * 0.01); // 1% of max mana

                let manaElapsedTime = 0;
                const manaRegenInterval = setInterval(() => {
                    if (manaElapsedTime >= manaDuration) {
                        clearInterval(manaRegenInterval);
                    } else {
                        battleAttributes.mana = Math.min(maxMana, battleAttributes.mana + manaRegenAmount);
                        logBattleEvent(`法力值 + ${manaRegenAmount}点。`, 'gold');
                        updateUI();
                        manaElapsedTime += manaInterval;
                    }
                }, manaInterval);
                break;
            case "忘忧水":
                const healthDuration = 3 * 1000; // 3 seconds
                const healthInterval = 1.5 * 1000; // 0.5 second
                const healthRegenAmount = Math.floor(maxHealth * 0.02); // 2% of max health

                let healthElapsedTime = 0;
                const healthRegenInterval = setInterval(() => {
                    if (healthElapsedTime >= healthDuration) {
                        clearInterval(healthRegenInterval);
                    } else {
                        battleAttributes.health = Math.min(maxHealth, battleAttributes.health + healthRegenAmount);
                        updateDamageValue(-healthRegenAmount,true,'damage');
                        updateUI();
                        healthElapsedTime += healthInterval;
                    }
                }, healthInterval);
                break;
            case "魔术棱柱":
                if (currentExp >= 30000) {
                    const skillsArea = document.getElementById("skills-area");
                    const upgradableSkills = Array.from(skillsArea.children).map(skillDiv => {
                        const skillName = skillDiv.innerText.split(' ')[0];
                        const skill = currentPet.skills.find(skill => skill.name === skillName);
                        return skill;
                    }).filter(skill => skill.level < 24 && skill !== null && !skill.byLearned);
                    
                    if (upgradableSkills.length === 0) {
                        showInfoBox("所有技能已达到24级，无法使用魔术棱柱。请尝试使用更高级的道具进行技能升级！");
                        break;
                    }
            
                    currentExp -= 30000; // 消耗30000点经验值
                    
                    // 随机选择一个技能并提升一级
                    let skillToUpgrade = upgradableSkills[Math.floor(Math.random() * upgradableSkills.length)];
                    
                    if (skillToUpgrade.level >= 24) {
                        // 如果随机选择的技能已经24级，则遍历其他技能进行升级
                        skillToUpgrade = upgradableSkills.find(skill => skill.level < 24);
                    }
                    
                    if (skillToUpgrade) {
                        skillToUpgrade.level += 1;
                        showInfoBox(`你消耗了30000点经验值，将${skillToUpgrade.name} 成功升至 ${skillToUpgrade.level} 级，威力增加了！`);
                    }
                    
                    updateExpBar(); // 更新经验条显示
                    updateUI(); // 更新界面显示
                } else {
                    showInfoBox("经验不足，无法使用魔术棱柱。");
                }
                break;
            case "幸运金币":
                if (Math.random() < 0.1 && battleRounds > 10) {
                    const battleRoundsToDecrease = battleRounds - 10;
                    initializeEnemyPet();
                    battleRounds = battleRoundsToDecrease;
                    updateEnemyAttributes();
                    logBattleEvent(`使用幸运金币，你成功回退至10轮之前。`, 'gold');
                } else if (Math.random() < 0.8) {
                    gainExp(50000);
                    logBattleEvent(`使用幸运金币，获得了50000点经验值。`, 'gold');
                } else {
                    battleState.enemy.health = 1;
                    logBattleEvent(`使用幸运金币，怪物血量变为1。`, 'gold');
                }
                updateUI();
                updateExpBar();
                break;
            case "双倍经验药":
                applyTimedBuff(
                    selectedDrug,
                    () => {
                        battleState.player.expMultiplier = 2;
                        logBattleEvent(`使用双倍经验药，60秒内战斗获胜所得经验变成两倍。`, 'gold');
                        return () => {
                            battleState.player.expMultiplier = 1;
                            logBattleEvent(`双倍经验药效果消失。`, 'red');
                        };
                    },
                    60000
                );
                break;
            case "四倍经验药":
                applyTimedBuff(
                    selectedDrug,
                    () => {
                        battleState.player.expMultiplier = 4;
                        logBattleEvent(`使用四倍经验药，60秒内战斗获胜所得经验变成四倍。`, 'gold');
                        return () => {
                            battleState.player.expMultiplier = 1;
                            logBattleEvent(`四倍经验药效果消失。`, 'red');
                        };
                    },
                    60000
                );
                break;
            case "武尊秘露":
            case "神力仙丹":
            case "狂暴印记":
            case "化功散":
            case "沉檀凝香":
            case "焚灵之丸":
                if (!activeBuffs[selectedDrug]) {
                    applyBuff(selectedDrug);
                } else {
                    showInfoBox(`${selectedDrug}效果尚在冷却中，无法叠加使用。`);
                    return;  // 提前返回，防止数量减少
                }
                break;
            case "见手青":
                handleMushroom();
                break;
            case "狂暴之魂":
                playerCritRate = Math.min(1.0, playerCritRate + 0.01); // 最大100%
                logBattleEvent(`使用狂暴之魂，暴击率永久提高1%。`, 'gold');
                break;
            case "慧心糖果":
                playerCritDamage = Math.min(30.0, playerCritDamage + 0.01); // 最大3000%
                logBattleEvent(`使用慧心糖果，暴击伤害永久提高1%。`, 'gold');
                break;
            case "延寿露":
                battleAttributes.health = Math.min(maxHealth, battleAttributes.health + Math.floor(maxHealth * 0.2));
                updateDamageValue(-Math.floor(maxHealth * 0.2),true,'damage');
                logBattleEvent(`使用延寿露，恢复了 ${Math.floor(maxHealth * 0.2)} 点生命值。`, 'gold');
                break;
            case "天山雪莲":
                battleAttributes.mana = Math.min(maxMana, battleAttributes.mana + Math.floor(maxMana * 0.2));
                logBattleEvent(`使用天山雪莲，恢复了 ${Math.floor(maxMana * 0.2)} 点法力值。`, 'gold');
                break;
            case "普通药材":
                battleAttributes.health = Math.min(maxHealth, battleAttributes.health + 1000);
                updateDamageValue(-(battleAttributes.health + 1000),true,'damage');
                battleAttributes.mana = Math.min(maxMana, battleAttributes.mana + 1000);
                break;
            case "上等药材":
                applyDrugBonus0("speed", 20);
                break;
            case "极品药材":
                applyDrugBonus0("health", 500);
                applyDrugBonus0("mana", 500);
                break;
            case "珍贵药材":
                applyDrugBonus0("physicalDefense", 100);
                applyDrugBonus0("magicDefense", 100);
                break;
            case "完美药材":
                applyDrugBonus0("physicalAttack", 100);
                applyDrugBonus0("magicAttack", 100);
                break;
            case "冰莲絮":
                applyDrugBonus0("health", 2000);
                break;
            case "晗灵果":
                applyDrugBonus0("mana", 2000);
                break;
        }
        updateUI();
    } else {
        showInfoBox("药品不足！", 'red');
    }
}

function checkConflictingBuffs(selectedDrug) {
    const conflictingDrugs = ["神力仙丹", "狂暴印记", "焚灵之丸"];
    if (conflictingDrugs.includes(selectedDrug)) {
        for (const drug of conflictingDrugs) {
            if (activeBuffs[drug]) {
                showInfoBox("已有同系效果发挥作用或正在冷却中，无法叠加效果使用");
                return true;
            }
        }
    }
    return false;
}

function applyBuff(drugName) {
    switch (drugName) {
        case "武尊秘露":
            applyTimedBuff(
                drugName,
                () => {
                    const originalPhysicalAttack = battleAttributes.physicalAttack;
                    battleAttributes.physicalAttack = Math.floor(battleAttributes.physicalAttack * 1.5);
                    logBattleEvent(`使用武尊秘露，物理攻击力提升150%，持续20秒。`, 'gold');
                    return () => {
                        battleAttributes.physicalAttack = originalPhysicalAttack;
                        logBattleEvent(`武尊秘露冷却结束。`, 'red');
                    };
                },
                20000
            );
            break;
        case "神力仙丹":
            applyTimedBuff(
                drugName,
                () => {
                    playerCritDamage = Math.min(30.0, playerCritDamage + 0.50); // 最大3000%
                    logBattleEvent(`使用神力仙丹，暴击伤害提高50%，持续20秒。`, 'gold');
                    return () => {
                        playerCritDamage = playerCritDamage - 0.5;
                        logBattleEvent(`神力仙丹冷却结束。`, 'red');
                    };
                },
                20000
            );
            break;
        case "狂暴印记":
            applyTimedBuff(
                drugName,
                () => {
                    playerCritRate = Math.min(10.0, playerCritRate + 0.50); // 最大1000%
                    logBattleEvent(`使用狂暴印记，暴击率提高50%，持续20秒。`, 'gold');
                    return () => {
                        playerCritRate = playerCritRate - 0.5;
                        logBattleEvent(`狂暴印记冷却结束。`, 'red');
                    };
                },
                20000
            );
            break;
        case "化功散":
            applyTimedBuff(
                drugName,
                () => {
                    const originalEnemyCritRate = enemyCritRate;
                    enemyCritRate = 0;
                    logBattleEvent(`使用化功散，邪佞暴击率降低至0%，持续30秒。`, 'gold');
                    return () => {
                        enemyCritRate = originalEnemyCritRate;
                        logBattleEvent(`化功散冷却结束。`, 'red');
                    };
                },
                30000
            );
            break;
        case "沉檀凝香":
            // 恢复10%生命值
            const healthRestored = Math.floor(maxHealth * 0.1);
            battleAttributes.health = Math.min(maxHealth, battleAttributes.health + healthRestored);
            logBattleEvent(`使用沉檀凝香，恢复了 ${healthRestored} 点生命值。`, 'gold');
            // 80% 几率清除玩家的异常状态
            if (Math.random() < 0.8) {
                clearEnemyEffect();
                logBattleEvent('沉檀凝香生效，清除了异常状态。', 'gold');
            } else {
                logBattleEvent('沉檀凝香生效，但未能清除异常状态。', 'red');
            }
        
            break;
        case "焚灵之丸":
            if (battleAttributes.health >= maxHealth * 0.2) {
                applyTimedBuff(
                    drugName,
                    () => {
                        const originalPA = battleAttributes.physicalAttack;
                        const originalMA = battleAttributes.magicAttack;
                        battleAttributes.health -= Math.floor(maxHealth * 0.2);
                        battleAttributes.physicalAttack = Math.floor(battleAttributes.physicalAttack * 1.5);
                        battleAttributes.magicAttack = Math.floor(battleAttributes.magicAttack * 1.5);
                        playerCritRate = Math.min(10.0, playerCritRate + 0.50); // 最大1000%
                        playerCritDamage = Math.min(30.0, playerCritDamage + 0.50); // 最大3000%
                        logBattleEvent(`使用焚灵之丸，消耗20%生命值，提升50%物理攻击力、法术攻击、暴击率和暴击伤害，持续20秒。`, 'gold');
                        return () => {
                            battleAttributes.physicalAttack = originalPA;
                            battleAttributes.magicAttack = originalMA;
                            playerCritRate -= 0.5;
                            playerCritDamage -= 0.5;
                            logBattleEvent(`焚灵之丸冷却结束。`, 'red');
                        };
                    },
                    20000
                );
            } else {
                showInfoBox("焚灵之丸效果无法触发，生命值不足20%。");
            }
            break;
    }
}

function applyTimedBuff(drugName, applyEffect, duration) {
    if (activeBuffs[drugName]) return;

    const removeEffect = applyEffect();
    activeBuffs[drugName] = setTimeout(() => {
        removeEffect();
        delete activeBuffs[drugName];
        updateUI();
    }, duration);
}

function applyDrugBonus0(type, bonus) {
    if (!battleState || !battleState.player) {
        console.error("Battle state or player state is not initialized");
        return;
    }

    // 更新 drugBonus 对象
    if (drugBonus0.hasOwnProperty(type)) {
        drugBonus0[type] += bonus;
    } else {
        console.error("Invalid drug type");
        return;
    }

    // 更新玩家属性
    if (battleState.player.hasOwnProperty(type)) {
        battleState.player[type] += bonus;
    } else {
        console.error("Invalid player attribute type");
    }

    // 更新最大生命值和法力值
    if (type === 'health') {
        maxHealth = battleState.player.health;
    } else if (type === 'mana') {
        maxMana = battleState.player.mana;
    }

    // 检查类型并调用 updatePetInfo() 函数
    if (['physicalAttack', 'physicalDefense', 'magicAttack', 'magicDefense', 'speed'].includes(type)) {
        updatePetInfo();
    }

    const typeMap = {
        health: '生命值',
        mana: '法力值',
        physicalAttack: '物理攻击力',
        physicalDefense: '物理防御力',
        magicAttack: '法术攻击力',
        magicDefense: '法术防御力',
        speed: '速度'
    };

    logBattleEvent(`永久增加了 ${bonus} 点${typeMap[type]}。`, 'gold');
    updateUI();
}

function collectDrug() {
    if (goldAmount < collectCost) {
        showInfoBox("金子不足，无法进行采集！");
        return;
    }

    // 扣除金子并更新显示
    goldAmount -= collectCost;
    updateGoldDisplay(goldAmount);

    // 递增下次采集的花费
    collectCost += 100;

    // 确定采集的药材
    const random = Math.random() * 100;
    let collectedDrug;
    if (random < 50) {
        collectedDrug = '普通药材';
        drugInventory['普通药材'].quantity += 1;
    } else if (random < 80) {
        collectedDrug = '上等药材';
        drugInventory['上等药材'].quantity += 1;
    } else if (random < 95) {
        collectedDrug = '极品药材';
        drugInventory['极品药材'].quantity += 1;
    } else if (random < 98) {
        collectedDrug = '珍贵药材';
        drugInventory['珍贵药材'].quantity += 1;
    } else {
        collectedDrug = '完美药材';
        drugInventory['完美药材'].quantity += 1;
        addItemToJinnang('treasureMap', 1);
        showInfoBox("功夫不负有心人，你意外获得一份藏宝图！")
        
    }

    // 触发奖励事件
    const rewardRandom = Math.random() * 100;
    let multiplier = 1;
    if (rewardRandom < 1) {
        multiplier = 3;
    } else if (rewardRandom < 3) {
        multiplier = 2;
    }

    if (multiplier > 1) {
        drugInventory[collectedDrug].quantity += (multiplier - 1);
        document.getElementById('drug-description').innerText = `你花费${convertPrice(collectCost - 100)}金子打点进山凭证，采集到了${multiplier}个${collectedDrug}！`;
    } else {
        document.getElementById('drug-description').innerText = `你花费${convertPrice(collectCost - 100)}金子打点进山凭证，采集到了1个${collectedDrug}！`;
    }

    updateDrugGrid(); // 更新药品显示
}

function mergeDrug() {
    if (!selectedDrug) {
        showInfoBox("请先选中要合成的药品。");
        return;
    }

    const selectedDrugDetails = drugInventory[selectedDrug];
    const selectedDrugTier = selectedDrugDetails.tier;

    if (selectedDrugTier === 0) {
        const requiredQuantity = 3;
        if (selectedDrugDetails.quantity < requiredQuantity) {
            showInfoBox("你至少需要3个同类药品才能进行合成！");
            return;
        }

        // 减少低级药品数量
        selectedDrugDetails.quantity -= requiredQuantity;

        // 执行tier0药品的特殊合成逻辑
        const probability = Math.random();
        let message = '';

        if (probability < 0.1) {
            message = `你使用3个${selectedDrug}尝试合成，但没有产出任何事物`;
        } else if (probability < 0.2) {
            drugInventory[selectedDrug].quantity += 1;
            message = `你使用3个${selectedDrug}进行炼制，但只得到了1个${selectedDrug}`;
        } else if (probability < 0.5) {
            const tier1Drugs = Object.keys(drugInventory).filter(drug => drugInventory[drug].tier === 1);
            const newDrugs = [];
            for (let i = 0; i < 3; i++) {
                const newDrug = tier1Drugs[Math.floor(Math.random() * tier1Drugs.length)];
                drugInventory[newDrug].quantity += 1;
                newDrugs.push(newDrug);
            }
            message = `你使用3个${selectedDrug}成功炼制出了3个随机紫色品阶药品：${newDrugs.join(', ')}`;
        } else {
            const tier0Drugs = Object.keys(drugInventory).filter(drug => drugInventory[drug].tier === 0);
            const newDrugs = [];
            for (let i = 0; i < 2; i++) {
                const newDrug = tier0Drugs[Math.floor(Math.random() * tier0Drugs.length)];
                drugInventory[newDrug].quantity += 1;
                newDrugs.push(newDrug);
            }
            message = `你使用3个${selectedDrug}成功炼制出了2个随机橙色品阶药品：${newDrugs.join(', ')}`;
        }

        document.getElementById('drug-description').innerText = message;
    } else {
        const requiredQuantity = 5;
        if (selectedDrugDetails.quantity < requiredQuantity) {
            showInfoBox("你至少需要5个同类药品才能进行合成！（橙色品阶需要3个）");
            return;
        }

        // 减少低级药品数量
        selectedDrugDetails.quantity -= requiredQuantity;

        // 随机选择高级药品
        const nextTier = selectedDrugTier - 1;
        const nextTierDrugs = Object.keys(drugInventory).filter(drug => drugInventory[drug].tier === nextTier);
        const newDrug = nextTierDrugs[Math.floor(Math.random() * nextTierDrugs.length)];

        // 增加高级药品数量
        drugInventory[newDrug].quantity += 1;

        document.getElementById('drug-description').innerText = `你使用5个${selectedDrug}成功炼制出了1个${newDrug}`;
    }

    updateDrugGrid();
}


        

// 【玩家战斗组件】精灵系统函数      
document.getElementById('battle-spirit-button').addEventListener('click', () => {
    if (battleState.player.taunt) {
        performAttack('physical');
        return;
    }
    
    if (!awakened) {
        showInfoBox("\n1.宠物在觉醒后可以开启战斗精灵 \n2.经过精心培养的精灵可以大幅增加战斗属性\n3.精灵会提供额外的战场胜利物资\n4.战斗中精灵有概率施加恢复、控制或强化 \n5.精灵等级和增幅越高，增益越明显");
    } else {
        document.getElementById('battle-spirit-modal').style.display = 'block';
        updateSpiritDisplay(); // 打开时更新显示
    }
}); // 打开战斗精灵界面

function checkAwakening() {
    if (awakened) {
        document.getElementById('battle-spirit-button').style.display = 'block';
    } else {
        document.getElementById('battle-spirit-button').style.display = 'block';
    }
} // 显示战斗精灵按钮

function getBaseSpiritAttributes() {
    if (!awakened) {
        return {
            health: 0,
            mana: 0,
            physicalAttack: 0,
            physicalDefense: 0,
            magicAttack: 0,
            magicDefense: 0,
            speed: 0
        };
    } else {
        return {
            health: 11,
            mana: 9,
            physicalAttack: 2,
            physicalDefense: 2.1,
            magicAttack: 1.9,
            magicDefense: 2.05,
            speed: 1
        };
    }
} // 获取精灵提供的基础属性增益

function displayInBottle() {
    const spiritInfo = getCurrentSpiritAttributes();
    const nameMap = new Map([
        ['health', '生命值'],
        ['magicAttack', '法术攻击'],
        ['magicDefense', '法术防御'],
        ['mana', '法力值'],
        ['physicalAttack', '物理攻击'],
        ['physicalDefense', '物理防御'],
        ['speed', '速度']
    ]);

    let spiritInfoMessage = '';

    for (const [key, value] of Object.entries(spiritInfo)) {
        const displayName = nameMap.get(key) || key; // 如果没有匹配到替换的名称，则使用原始英文名
        spiritInfoMessage += `${displayName}: ${value}\n`;
    }

    showInfoBox(`\n1.当前你携带的精灵等级为${spiritLevel}，成长系数为${spiritMultiplier}。\n2.精灵的各项数值为：\n ${spiritInfoMessage}`);
}

        
function updateSpiritDisplay() {
    const spiritAttributes = getCurrentSpiritAttributes();
    document.getElementById('spirit-level').innerText = spiritLevel;
    document.getElementById('spirit-multiplier').innerText = Math.round(spiritMultiplier * 100) + '%';
    document.getElementById('spirit-health').innerText = spiritAttributes.health;
    document.getElementById('spirit-mana').innerText = spiritAttributes.mana;
    document.getElementById('spirit-physical-attack').innerText = spiritAttributes.physicalAttack;
    document.getElementById('spirit-physical-defense').innerText = spiritAttributes.physicalDefense;
    document.getElementById('spirit-magic-attack').innerText = spiritAttributes.magicAttack;
    document.getElementById('spirit-magic-defense').innerText = spiritAttributes.magicDefense;
    document.getElementById('spirit-speed').innerText = spiritAttributes.speed;
} // 更新精灵属性显示

document.getElementById('close-spirit-modal').addEventListener('click', () => {
    document.getElementById('battle-spirit-modal').style.display = 'none';
}); // 关闭战斗精灵界面

document.getElementById('level-up-spirit').addEventListener('click', () => {
    if (spiritLevel >= 100) {
        showMessage('战斗精灵已达到最大等级！', 'error');
        return;
    }

    if (useItem('spiritRefreshStone', 1)) {
        let successChance;
        let failPenalty = 0;
        let minLevelForCurrentRange;

        if (spiritLevel <= 20) {
            successChance = 1.0; // 100% 成功率
            minLevelForCurrentRange = 1;
        } else if (spiritLevel <= 30) {
            successChance = 0.95; // 95% 成功率
            minLevelForCurrentRange = 21;
        } else if (spiritLevel <= 40) {
            successChance = 0.9; // 90% 成功率
            failPenalty = 1;
            minLevelForCurrentRange = 31;
        } else if (spiritLevel <= 50) {
            successChance = 0.85; // 85% 成功率
            failPenalty = 1;
            minLevelForCurrentRange = 41;
        } else if (spiritLevel <= 60) {
            successChance = 0.8; // 80% 成功率
            failPenalty = 1;
            minLevelForCurrentRange = 51;
        } else if (spiritLevel <= 70) {
            successChance = 0.85; // 85% 成功率
            failPenalty = 2;
            minLevelForCurrentRange = 61;
        } else if (spiritLevel <= 80) {
            successChance = 0.8; // 80% 成功率
            failPenalty = 2;
            minLevelForCurrentRange = 71;
        } else if (spiritLevel <= 90) {
            successChance = 0.75; // 75% 成功率
            failPenalty = 2;
            minLevelForCurrentRange = 81;
        } else if (spiritLevel <= 99) {
            successChance = 0.7; // 70% 成功率
            failPenalty = 2;
            minLevelForCurrentRange = 91;
        }

        const randomChance = Math.random();
        if (randomChance < successChance) {
            spiritLevel += 1;
            updateSpiritDisplay(); // 更新显示
            updatePetInfo(); // 刷新战斗属性
        } else {
            if (failPenalty > 0) {
                spiritLevel = Math.max(minLevelForCurrentRange, spiritLevel - failPenalty);
                showMessage(`洗练失败，等级下降了 ${failPenalty} 级，保底 ${minLevelForCurrentRange} 级！`, 'error');
            } else {
                showMessage('洗练失败！', 'error');
            }
            updateSpiritDisplay(); // 更新显示
            updatePetInfo(); // 刷新战斗属性
        }
    } else {
        showMessage('您的精灵精炼石不足！', 'error');
    }
}); // 精灵洗练

document.getElementById('auto-level-up-spirit').addEventListener('click', () => {
    const targetLevel = parseInt(prompt('请输入目标精灵等级：'), 10);

    if (isNaN(targetLevel) || targetLevel <= spiritLevel || targetLevel > maxSpiritLevel) {
        showMessage('无效的目标等级！', 'error');
        return;
    }

    let initialLevel = spiritLevel;
    let stonesUsed = 0;

    while (spiritLevel < targetLevel && useItem('spiritRefreshStone', 1)) {
        stonesUsed++;
        let successChance;
        let failPenalty = 0;
        let minLevelForCurrentRange;

        if (spiritLevel <= 20) {
            successChance = 1.0;
            minLevelForCurrentRange = 1;
        } else if (spiritLevel <= 30) {
            successChance = 0.95;
            minLevelForCurrentRange = 21;
        } else if (spiritLevel <= 40) {
            successChance = 0.9;
            failPenalty = 1;
            minLevelForCurrentRange = 31;
        } else if (spiritLevel <= 50) {
            successChance = 0.85;
            failPenalty = 1;
            minLevelForCurrentRange = 41;
        } else if (spiritLevel <= 60) {
            successChance = 0.8;
            failPenalty = 1;
            minLevelForCurrentRange = 51;
        } else if (spiritLevel <= 70) {
            successChance = 0.85;
            failPenalty = 2;
            minLevelForCurrentRange = 61;
        } else if (spiritLevel <= 80) {
            successChance = 0.8;
            failPenalty = 2;
            minLevelForCurrentRange = 71;
        } else if (spiritLevel <= 90) {
            successChance = 0.75;
            failPenalty = 2;
            minLevelForCurrentRange = 81;
        } else if (spiritLevel <= 99) {
            successChance = 0.7;
            failPenalty = 2;
            minLevelForCurrentRange = 91;
        }

        const randomChance = Math.random();
        if (randomChance < successChance) {
            spiritLevel += 1;
            updateSpiritDisplay();
            updatePetInfo(); // 刷新战斗属性
        } else {
            if (failPenalty > 0) {
                spiritLevel = Math.max(minLevelForCurrentRange, spiritLevel - failPenalty);
            }
            updateSpiritDisplay();
            updatePetInfo(); // 刷新战斗属性
        }
    }

    showMessage(`您耗费了 ${stonesUsed} 颗精灵精炼石，将精灵升至 ${spiritLevel} 级。`, 'info');
}); // 精灵一键升级

function getCurrentSpiritAttributes() {
    const baseAttributes = getBaseSpiritAttributes();
    return {
        health: Math.floor(baseAttributes.health * Math.pow(1.08, spiritLevel) * spiritMultiplier),
        mana: Math.floor(baseAttributes.mana * Math.pow(1.08, spiritLevel) * spiritMultiplier),
        physicalAttack: Math.floor(baseAttributes.physicalAttack * Math.pow(1.07, spiritLevel) * spiritMultiplier),
        physicalDefense: Math.floor(baseAttributes.physicalDefense * Math.pow(1.08, spiritLevel) * spiritMultiplier),
        magicAttack: Math.floor(baseAttributes.magicAttack * Math.pow(1.07, spiritLevel) * spiritMultiplier),
        magicDefense: Math.floor(baseAttributes.magicDefense * Math.pow(1.08, spiritLevel) * spiritMultiplier),
        speed: Math.floor(baseAttributes.speed * Math.pow(1.07, spiritLevel) * spiritMultiplier)
    };
} // 计算精灵当前等级和倍数提供的属性增益

document.getElementById('enhance-spirit').addEventListener('click', () => {
    if (useItem('spiritAwakenStone', 1)) {
        let newMultiplier;
        const randomChance = Math.random();

        if (randomChance < 0.95) {
            // 95%的概率随机更新至0.01~3.00这个区间
            newMultiplier = (Math.random() * (3.00 - 0.01) + 0.01).toFixed(2);
        } else if (randomChance < 0.98) {
            // 3%的概率随机更新至3.01~3.99这个区间
            newMultiplier = (Math.random() * (3.99 - 3.01) + 3.01).toFixed(2);
        } else if (randomChance < 0.99) {
            // 1%的概率随机更新至4.00~4.10这个区间
            newMultiplier = (Math.random() * (4.10 - 4.00) + 4.00).toFixed(2);
        } else {
            // 1%的概率随机更新至4.11~4.15这个区间
            newMultiplier = (Math.random() * (4.15 - 4.11) + 4.11).toFixed(2);
        }

        // 检查新倍数是否高于3.90
        if (parseFloat(newMultiplier) > 3.90) {
            const confirmMessage = "您的精灵增幅已经到了一个比较高的层次，确定继续吗？";
            showInfoBox(confirmMessage, () => {
                spiritMultiplier = parseFloat(newMultiplier);
                updateSpiritDisplay(); // 更新显示
                updatePetInfo(); // 刷新战斗属性
            });
        } else {
            spiritMultiplier = parseFloat(newMultiplier);
            updateSpiritDisplay(); // 更新显示
            updatePetInfo(); // 刷新战斗属性
        }
    } else {
        showInfoBox('您的精灵觉醒石不足！');
    }
}); // 精灵增幅提升
        
function handleSpiritHeal() {
    if (!awakened){
        return;
    }

    if (summonEnemy) {
        return;
    }
    
    const baseProbability = 0.01;
    const finalProbability = baseProbability + spiritMultiplier / 400;
    const triggerProbability = Math.round(finalProbability * 100);

    if (Math.random() * 100 < triggerProbability) {
        const spiritAttributes = getCurrentSpiritAttributes();
        const healValue = Math.round((Math.random() * (1.8 - 0.9) + 0.9) * spiritAttributes.magicAttack * spiritMultiplier * 2.5);
        battleState.player.health = Math.min(battleState.player.health + healValue, maxHealth);

        logBattleEvent(`🧚🏻‍♀️精灵为你祈福，恢复了⭐️${healValue}⭐️生命值`, "pink");
        updateDamageValue(-healValue,true,'extra-damage');
        updateUI();
    }
} //战斗精灵的随机回血

function handleSpiritPower() {
    if (!awakened){
        return;
    }

    if (summonEnemy) {
        return;
    }
    
    const baseProbability = 0.01;
    const finalProbability = baseProbability + spiritMultiplier / 400;
    const triggerProbability = Math.round(finalProbability * 100);

    if (Math.random() * 100 < triggerProbability && !spiritPowerActive) {
        spiritPowerActive = true;
        battleState.player.spiritPowerActive = true;

        const spiritAttributes = getCurrentSpiritAttributes();
        const attributeBoost = {
            health: Math.round(spiritAttributes.health / 2),
            mana: Math.round(spiritAttributes.mana / 1.5),
            physicalAttack: Math.round(spiritAttributes.physicalAttack / 1.5),
            physicalDefense: Math.round(spiritAttributes.physicalDefense / 1.2),
            magicAttack: Math.round(spiritAttributes.magicAttack / 1.5),
            magicDefense: Math.round(spiritAttributes.magicDefense / 1.3),
            speed: Math.round(spiritAttributes.speed / 1.3)
        };

        // Apply the boost
        Object.keys(attributeBoost).forEach(attr => {
            battleAttributes[attr] += attributeBoost[attr];
        });

        logBattleEvent(`🧚🏻‍♀️Bless from your best teammate！战斗精灵带来全属性提升！`, "pink");
        updateUI();

        // Remove the boost after 5 seconds
        setTimeout(() => {
            Object.keys(attributeBoost).forEach(attr => {
                battleAttributes[attr] -= attributeBoost[attr];
            });

            spiritPowerActive = false;
            battleState.player.spiritPowerActive = false;
            updateUI();
        }, 5000);
    }
} //战斗精灵的随机增益

function handleSpiritAttack() {
    if (!awakened){
        return;
    }

    if (summonEnemy) {
        return;
    }
    
    const baseProbability = 0.01;
    const finalProbability = baseProbability + spiritMultiplier / 400;
    const triggerProbability = Math.round(finalProbability * 100);

    if (Math.random() * 100 < triggerProbability) {
        const spiritAttributes = getCurrentSpiritAttributes();
        const attackValue = Math.round((Math.random() * (2.4 - 1.8) + 1.8) * spiritAttributes.magicAttack * spiritMultiplier * playerCritDamage);
        battleState.enemy.health = Math.max(battleState.enemy.health - attackValue, 0);

        logBattleEvent(`🧚🏻‍♀️Attack from your best teammate！敌人受到来自精灵的${attackValue}点助攻伤害！`, "pink");
        
        if (battleState.enemy.health <= 0) {
            showNextBattlePrompt(true);
            return;
        }


        if (Math.random() < 0.4 + finalProbability) { // 40% 的基础概率触发沉睡效果
            handleSleep();
        }

        updateUI();
    }
} //战斗精灵的随机助攻




// 【玩家战斗组件】飞升技能系统函数
document.getElementById('enable-ascension').addEventListener('click', handleAscensionButtonClick); //开启面板

function handleAscensionButtonClick() {
    if (!ascend) {
        showInfoBox('您的宠物没有飞升，无法开启飞升增益！');
        return;
    }

    if (ascensionEnabled) {
        ascensionSkillDescription(); // 直接执行技能大全
    } else {
        // 未开启飞升之术时，执行开启逻辑
        if (useItem('heartStone', 1)) {
            showInfoBox('飞升之术增益已启用！');
            refreshAscensionSkill(); // 随机生成一个飞升之术
            applyAscensionBonus(); // 应用飞升之术增益
            ascensionEnabled = true; // 设置飞升之术已开启
        } else {
            showInfoBox('您的心鉴之石不足！');
        }
    }

    updateAscensionButton(); // 更新按钮状态
}

document.getElementById('close-ascension-modal').addEventListener('click', () => {
    document.getElementById('ascension-skill-modal').style.display = 'none';
}); //关闭面板

function checkAscensionEnabled() {
    if (!ascensionEnabled) {
        showInfoBox('请先开启飞升之术增益！');
        return false;
    }
    return true;
} //调用检查函数

function updateAscensionButton() {
    const ascensionButton = document.getElementById('enable-ascension');
    if (ascensionEnabled) {
        ascensionButton.innerText = '技能说明';
        ascensionButton.style.backgroundColor = 'darkred';
        ascensionButton.removeEventListener('click', handleAscensionButtonClick);
        ascensionButton.addEventListener('click', ascensionSkillDescription);
    } else {
        ascensionButton.innerText = '开启增益';
        ascensionButton.style.backgroundColor = '';
        ascensionButton.removeEventListener('click', ascensionSkillDescription);
        ascensionButton.addEventListener('click', handleAscensionButtonClick);
    }
}

function ascensionSkillDescription() {
    let skillDescriptions = [];
    let skillIndex = 1; // 初始化技能编号

    // 遍历 ascensionSkills 对象
    for (const category in ascensionSkills) {
        if (ascensionSkills.hasOwnProperty(category)) {
            ascensionSkills[category].forEach(skill => {
                skillDescriptions.push(`${skillIndex}. ${skill.name}：${skill.effect(1)}`); // 假设技能等级为1
                skillIndex++; // 编号递增
            });
        }
    }

    const skillDescriptionsText = skillDescriptions.join('\n');
    showInfoBox(skillDescriptionsText);
}

document.getElementById('ascension-skill-button').addEventListener('click', () => {
    if (!petAscended) {
        showInfoBox('您的宠物未飞升，还没有掌握飞升之术！');
    } else if (battleState.player.taunt) {
        performAttack('physical');
        return;
    } else {
        document.getElementById('ascension-skill-modal').style.display = 'block';
        updateAscensionDisplay(); // 打开时更新显示
    }
}); //开启第一个飞升之术

document.getElementById('refresh-ascension').addEventListener('click', () => {
    if (!checkAscensionEnabled()) return;
    if (useItem('heartStone', 1)) {
        refreshAscensionSkill(); // 刷新飞升之术技能
        applyAscensionBonus(); // 应用飞升之术增益
    } else {
        showInfoBox('您的心鉴之石不足！');
    }
}); //触发刷新第一个飞升之术函数

function refreshAscensionSkill() {
    let newSkill;
    do {
        const allSkills = [...ascensionSkills.attribute, ...ascensionSkills.combat, ...ascensionSkills.settlement];
        newSkill = allSkills[Math.floor(Math.random() * allSkills.length)];
    } while (newSkill.name === secondAscensionSkill.name || newSkill.name === "未开启" || newSkill.name === "被封印的技能");
    ascensionSkill = { ...newSkill, level: 1 };
    updateAscensionDisplay();
    applyAscensionBonus();
    applyAscensionEffects();
    updatePetInfo();
} //刷新第一个飞升之术

document.getElementById('level-up-ascension').addEventListener('click', () => {
    if (!checkAscensionEnabled()) return;
    if (useItem('earthlyEnergy', 10)) {
        levelUpAscensionSkill(); // 提升飞升之术技能
    } else {
        showInfoBox('每次提升技能需要消耗10个天地灵气，你的天地灵气数量不足！');
    }
}); //触发升级第一个飞升之术函数

function levelUpAscensionSkill() {
    if (ascensionSkill.level < 20) {
        ascensionSkill.level += 1;
        updateAscensionDisplay();
        applyAscensionBonus(); // 提升技能后重新应用增益
    } else {
        showInfoBox('飞升之术技能已达最大等级！');
    }
} //升级第一个飞升之术

function updateAscensionDisplay() {
    document.getElementById('ascension-icon').src = 'https://pic.imgdb.cn/item/666aa7b6d9c307b7e9495e97.png'; // 设置图标URL
    document.getElementById('ascension-name').innerText = ascensionSkill.name;
    document.getElementById('ascension-level').innerText = '等级: ' + ascensionSkill.level;
    document.getElementById('ascension-effect').innerText = ''; // 重置描述为空
    const skill = ascensionSkills.combat.find(skill => skill.name === ascensionSkill.name) || ascensionSkills.attribute.find(skill => skill.name === ascensionSkill.name) || ascensionSkills.settlement.find(skill => skill.name === ascensionSkill.name);
    if (skill) {
        document.getElementById('ascension-effect').innerText = skill.effect(ascensionSkill.level);
    }
} //更新第一个飞升之术显示

//第二个飞升技能模块
function checkSecondAscensionEnabled() {
    const secondSkillBox = document.getElementById('second-ascension-skill');
    
    if (!reenableAscension || !ascensionEnabled) {
        const errorShowUpSecondAscensionSkill = secondAscensionSkill ? secondAscensionSkill.name : null;
        secondSkillBox.style.display = 'none';
        
        if (errorShowUpSecondAscensionSkill) {
            console.log(`第二个飞升技能${errorShowUpSecondAscensionSkill}尚未开启！`);
        } else {
            console.log(`第二个飞升技能尚未开启，且当前没有技能名称可显示。`);
        }
        
        return false;
    } else {
        secondSkillBox.style.display = 'block';
        return true;
    }
} //调用检查函数
document.getElementById('reenable-ascension').addEventListener('click', () => {
    // 检查第一个飞升技能是否未打开
    if (!ascensionSkill.name && !ascensionEnabled) {
        showInfoBox("你还没有打开第一个飞升技能！");
        return; // 退出函数
    }

    const secondSkillBox = document.getElementById('second-ascension-skill');
    if (secondSkillBox.style.display === 'none') {
        if (confirm("你可以消耗10个飞升之石为宠物开启第二个飞升之术，确认请继续")) {
            if (useItem('ascensionStone', 10)) {
                secondSkillBox.style.display = 'block';
                refreshSecondAscensionSkill();
                reenableAscension = true;
            } else {
                showInfoBox('您的飞升之石不足！');
            }
        }
    } else {
        showInfoBox('您已经开启过第二个飞升之术了！');
    }
    checkSecondAscensionEnabled();

}); //开启第二个飞升之术

document.getElementById('refresh-second-ascension').addEventListener('click', () => {
    if (!checkSecondAscensionEnabled()) return;

    if (useItem('heartStone', 1)) {
        refreshSecondAscensionSkill();
    } else {
        showInfoBox('您的心鉴之石不足！');
    }
}); //触发刷新第二个飞升之术函数

function refreshSecondAscensionSkill() {
    let newSkill;
    do {
        const allSkills = [...ascensionSkills.attribute, ...ascensionSkills.combat, ...ascensionSkills.settlement];
        newSkill = allSkills[Math.floor(Math.random() * allSkills.length)];
    } while (newSkill.name === ascensionSkill.name || newSkill.name === "未开启" || newSkill.name === "被封印的技能");
    secondAscensionSkill = { ...newSkill, level: 1 };
    updateSecondAscensionDisplay();
    applyAscensionBonus();
    applyAscensionEffects();
    updatePetInfo();
} //刷新第二个飞升之术

document.getElementById('level-up-second-ascension').addEventListener('click', () => {
    if (!checkSecondAscensionEnabled()) return;
    if (useItem('earthlyEnergy', 10)) {
        levelUpSecondAscensionSkill();
    } else {
        showInfoBox('每次提升技能需要消耗10个天地灵气，你的天地灵气数量不足！');
    }
}); //触发升级第二个飞升之术函数

function levelUpSecondAscensionSkill() {
    if (secondAscensionSkill.level < 20) {
        secondAscensionSkill.level += 1;
        updateSecondAscensionDisplay();
        applyAscensionBonus();
        applyAscensionEffects(); // 确保提升后的技能生效
    } else {
        showInfoBox('飞升之术技能已达最大等级！');
    }
} //升级第一个飞升之术

function updateSecondAscensionSkill() {
    updateSecondAscensionDisplay();
    applyAscensionBonus();
    applyAscensionEffects();
    updatePetInfo();
}

function updateSecondAscensionDisplay() {
    if (!checkSecondAscensionEnabled()) return;
    const skillBox = document.getElementById('second-ascension-skill');
    document.getElementById('second-ascension-icon').src = 'https://pic.imgdb.cn/item/66726727d9c307b7e9118748.png';
    document.getElementById('second-ascension-name').innerText = secondAscensionSkill.name;
    document.getElementById('second-ascension-level').innerText = '等级: ' + secondAscensionSkill.level;
    const skill = ascensionSkills.combat.find(skill => skill.name === secondAscensionSkill.name) ||
                  ascensionSkills.attribute.find(skill => skill.name === secondAscensionSkill.name) ||
                  ascensionSkills.settlement.find(skill => skill.name === secondAscensionSkill.name);
    if (skill) {
        document.getElementById('second-ascension-effect').innerText = skill.effect(secondAscensionSkill.level);
    }
} //更新第二个飞升之术显示

// 应用所有飞升技能的增益逻辑
function applyAscensionBonus() {
    let initialAttributes = {
        health: 0,
        mana: 0,
        physicalAttack: 0,
        physicalDefense: 0,
        magicAttack: 0,
        magicDefense: 0,
        speed: 0
    };

    // 应用第一个技能增益
    initialAttributes = applySingleAscensionBonus(ascensionSkill, initialAttributes);

    // 应用第二个技能增益
    if (secondAscensionSkill.name && checkSecondAscensionEnabled()) {
        initialAttributes = applySingleAscensionBonus(secondAscensionSkill, initialAttributes);
    }

    ascensionAttributes = initialAttributes;
    updatePetInfo(); // 更新宠物信息，应用新的增益
}

function applySingleAscensionBonus(skill, attributes) {
    switch (skill.name) {
        case '力劈华山':
            attributes.physicalAttack += skill.baseValue + skill.increment(skill.level);
            break;
        case '慈悲心怀':
            attributes.health += skill.baseValue + skill.increment(skill.level);
            attributes.mana += 10000 + skill.increment(skill.level);
            break;
        case '势如破竹':
            attributes.speed += skill.baseValue + skill.increment(skill.level);
            attributes.magicAttack += 3000 + skill.increment(skill.level);
            break;
        case '固若金汤':
            attributes.physicalDefense += skill.baseValue + skill.increment(skill.level);
            attributes.magicDefense += 100000 + skill.increment(skill.level);
            break;
        // 其他技能增益逻辑...
    }
    return attributes;
}

function applyAscensionEffects() {
    resetBattleStateEffects();
    applySingleAscensionEffect(ascensionSkill);
    if (secondAscensionSkill.name && checkSecondAscensionEnabled()) {
        applySingleAscensionEffect(secondAscensionSkill);
    }
}

function applySingleAscensionEffect(skill) {
    switch (skill.name) {
        case '魔龙之力':
            const healPercentage = (skill.baseValue + skill.increment(skill.level)) / 100;
            const healAmount = Math.floor(maxHealth * healPercentage);
            battleAttributes.health = Math.min(maxHealth, battleAttributes.health + healAmount);
            logBattleEvent(`发动魔龙之力恢复了 ${healAmount} 点生命值。`, 'brown');
            updateUI();
            break;
        case '天降甘霖':
            battleState.player.divineProtectionChance = 0.5; // 固定概率50%
            battleState.player.divineProtectionDuration = 5 + skill.increment(skill.level);
            break;
        case '斩龙一式':
            battleState.player.whiteNightThreshold = skill.increment(skill.level) / 100;
            break;
        case '灵魂穿刺':
            battleState.player.extraCritDamageChance = skill.increment(skill.level) / 100;
            battleState.player.extraCritDamageMultiplier = 10; // 固定1000%
            break;
        case '吸血魔刃':
            battleState.player.bloodSuckPercentage = skill.increment(skill.level) / 100;
            break;
        case '无我之境':
            battleState.player.invincibilityChance = skill.increment(skill.level) / 100;
            break;
        case '铜墙铁壁':
            battleState.player.damageReductionPercentage += skill.baseValue + skill.increment(skill.level);
            break;
        case '法术精通':
            battleState.player.spellMasteryChance = skill.baseValue + skill.increment(skill.level);
            break;
        case '财源滚滚':
            battleState.player.goldBonus = skill.increment(skill.level);
            break;
        case '金牌调解':
            battleState.player.noGoldPenalty = true;
            battleState.player.goldCompensation = skill.increment(skill.level);
            break;
        case '焉知非福':
            battleState.player.protectionDuration = skill.increment(skill.level);
            break;
        case '向死而生':
            battleState.player.survivalChance = skill.increment(skill.level);
            break;
        case '举一反三':
            battleState.player.expBonus = skill.increment(skill.level);
            break;
        // 其他技能的战斗增益逻辑...
    }
}

function resetBattleStateEffects() {
    battleState.player.spellMasteryChance = 0;
    battleState.player.divineProtectionChance = 0;
    battleState.player.reflectPercentage = 0;
    battleState.player.bloodSuckPercentage = 0;
    battleState.player.invincibilityChance = 0;
    battleState.player.extraCritDamageChance = 0;
    battleState.player.extraCritDamageMultiplier = 0;
    battleState.player.whiteNightThreshold = 0;
    battleState.player.damageReductionPercentage = 0; // 重置减伤比例变量
    battleState.player.goldBonus = 0;
    battleState.player.noGoldPenalty = false;
    battleState.player.goldCompensation = 0;
    battleState.player.protectionDuration = 0;
    battleState.player.survivalChance = 0;
    battleState.player.expBonus = 0;
} //刷新新技能时，旧技能增益会被移除




// 【战斗组件】自动战斗、回退系统
function enemyInfo() {
    // 创建一个新的div元素作为弹窗的容器
    const popup = document.createElement('div');
    popup.style.position = 'fixed';
    popup.style.top = '50%';
    popup.style.left = '50%';
    popup.style.transform = 'translate(-50%, -50%)';
    popup.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
    popup.style.color = 'white';
    popup.style.padding = '20px';
    popup.style.border = '1px solid white';
    popup.style.borderRadius = '10px';
    popup.style.zIndex = '9999';
    popup.style.width = '80%';
    popup.style.maxWidth = '600px';
    popup.style.boxSizing = 'border-box';
    popup.style.fontSize = '14px';

    // 创建关闭按钮
    const closeButton = document.createElement('button');
    closeButton.innerText = 'X';
    closeButton.style.position = 'absolute';
    closeButton.style.top = '10px';
    closeButton.style.right = '10px';
    closeButton.style.backgroundColor = 'transparent';
    closeButton.style.color = 'white';
    closeButton.style.border = 'none';
    closeButton.style.cursor = 'pointer';
    closeButton.addEventListener('click', () => {
        document.body.removeChild(popup);
    });

    // 创建顶部容器
    const topContainer = document.createElement('div');
    topContainer.style.display = 'flex';
    topContainer.style.alignItems = 'center';
    topContainer.style.marginBottom = '20px';

    // 创建图片元素
    const enemyImage = enemyImages.find(image => image.name === battleState.enemy.name);
    const img = document.createElement('img');
    if (enemyImage) {
        img.src = enemyImage.url;
    } else {
        img.src = 'https://pic.imgdb.cn/item/6678135ed9c307b7e9060dd6.gif';
    }
    img.style.width = '100px';
    img.style.height = '100px';
    img.style.marginRight = '20px';

    // 创建标题和描述容器
    const titleDescContainer = document.createElement('div');

    // 创建标题元素
    const title = document.createElement('h2');
    if (!summonEnemy) {
        title.innerText = '邪佞(精英)';
    } else {
        title.innerText = `${battleState.enemy.name}`;
    }
    title.style.margin = '0';
    title.style.marginBottom = '10px';

    // 创建描述元素
    const description = document.createElement('p');
    if (!summonEnemy) {
        description.innerText = '潜藏于三界裂缝，以迷惑人心智、吸收人的恐惧而不断变强的邪祟。';
    } else {
        description.innerText = '这是一个召唤得来的怪物。';
    }
    
    description.style.margin = '0';

    // 将标题和描述添加到容器中
    titleDescContainer.appendChild(title);
    titleDescContainer.appendChild(description);

    // 将图片和标题描述容器添加到顶部容器中
    topContainer.appendChild(img);
    topContainer.appendChild(titleDescContainer);

    // 创建分割线
    const separator = document.createElement('hr');
    separator.style.borderColor = 'white';
    separator.style.margin = '20px 0';

    // 创建详情容器
    const detailsContainer = document.createElement('div');
    
    // 预先声明 details 变量
    let details;
    
    if (!summonEnemy) {
        details = [
            '邪佞共有两种形态：正常和狂暴',
            '正常形态下，它会交替使用物理和法术技能攻击邪佞。邪佞精通人心操纵之术,若玩家被施加"醉酒"、"摄魂"等效果，战局风险会极大提高。',
            '每10轮邪佞会进入狂暴状态，此时邪佞生命低于20%时将在2秒内加持霸体且触发复生。',
            '邪佞一共有150轮，通关后可以继续挑战无尽Boss“深渊之神”。这是一个强大的怪物，能力多变。'
        ];
    } else {
        details = [
            '挑战召唤的敌人往往会获得更丰富的奖励',
            '目前召唤敌人和邪佞共享一套战斗系统，但它们通常具备特殊的战斗效果。',
            '挑战失败会受到惩罚。',
            '中途退出会视为挑战失败哦。'
        ];
    }
    
    // 现在 details 数组在这里是可访问的
    details.forEach(detail => {
        const p = document.createElement('p');
        p.innerText = detail;
        p.style.margin = '10px 0';
        detailsContainer.appendChild(p);
    });
    
    // 创建按钮容器
    const buttonContainer = document.createElement('div');
    buttonContainer.style.display = 'flex';
    buttonContainer.style.justifyContent = 'space-between';
    buttonContainer.style.width = '100%';
    buttonContainer.style.marginTop = '20px';
    
    // 创建 "跳过十轮" 按钮
    const jumpButton = document.createElement('button');
    jumpButton.innerText = '跳过十轮';
    jumpButton.style.padding = '5px 10px';
    jumpButton.style.backgroundColor = '#003670';
    jumpButton.style.color = 'white';
    jumpButton.style.border = 'none';
    jumpButton.style.borderRadius = '5px';
    jumpButton.style.cursor = 'pointer';
    jumpButton.addEventListener('click', () => {
        jumpByTenRounds();
    });
    
    // 创建 "自动战斗" 按钮
    const autoButton = document.createElement('button');
    autoButton.innerText = '自动战斗';
    autoButton.style.padding = '5px 10px';
    autoButton.style.backgroundColor = '#003670';
    autoButton.style.color = 'white';
    autoButton.style.border = 'none';
    autoButton.style.borderRadius = '5px';
    autoButton.style.cursor = 'pointer';
    autoButton.addEventListener('click', () => {
        autoBattle();
        document.body.removeChild(popup);
    });

    // 创建 "忘却之时" 按钮
    const backToRoundOneButton = document.createElement('button');
    backToRoundOneButton.innerText = '忘却之时';
    backToRoundOneButton.style.padding = '5px 10px';
    backToRoundOneButton.style.backgroundColor = '#003670';
    backToRoundOneButton.style.color = 'white';
    backToRoundOneButton.style.border = 'none';
    backToRoundOneButton.style.borderRadius = '5px';
    backToRoundOneButton.style.cursor = 'pointer';
    backToRoundOneButton.addEventListener('click', () => {
        backToRoundOne();
    });

    // 将按钮添加到按钮容器中
    buttonContainer.appendChild(jumpButton);
    buttonContainer.appendChild(autoButton);
    buttonContainer.appendChild(backToRoundOneButton);
    
    // 将所有元素添加到弹窗容器中
    popup.appendChild(closeButton);
    popup.appendChild(topContainer);
    popup.appendChild(separator);
    popup.appendChild(detailsContainer);
    popup.appendChild(buttonContainer);
    
    // 将弹窗容器添加到页面的body中
    document.body.appendChild(popup);

    // 点击弹窗以外的区域关闭弹窗
    popup.addEventListener('click', (event) => {
        if (event.target === popup) {
            document.body.removeChild(popup);
        }
    });
} //用于展示敌人信息界面和执行托管操作

function autoBattle() {
    if (!battleState || !battleState.enemy) {
        console.error("战斗状态未初始化");
        clearAutoBattle();
        return;
    }
    
    if (autoBattleInterval !== null) {
        clearAutoBattle();
        showInfoBox('已关闭自动战斗！');
        return;
    }

    if (useItem('hailMonsterPill',1)) {
        logBattleEvent("自动战斗已开始。", 'lightgreen');
    
        autoBattleInterval = setInterval(() => {
            if (!battleState || !battleState.enemy) {
                console.error("战斗状态未初始化");
                clearAutoBattle();
                return;
            }

            if (!playerTurn) {
                return;
            }
    
            // 根据玩家生命值和状态进行行动
            if (battleAttributes.health / maxHealth < 0.5 && playerTurn) {
                if (Math.random() < 0.5) {
                    performDefense();
                } else {
                    performHeal();
                }
                return;
            }
    
            const debuffStates = [
                battleState.player.drunken,
                battleState.player.healingBan,
                battleState.player.soulCapture,
                battleState.player.blindfold,
                battleState.player.seal,
                battleState.player.torn,
                battleState.player.taunt,
                battleState.player.spellSlow,
                battleState.player.suppressed,
                battleState.player.slaughter
            ];
            const activeDebuffs = debuffStates.filter(Boolean).length;
    
            if (activeDebuffs >= 2) {
                const selectedDrug = "沉檀凝香";
                const drug = drugInventory[selectedDrug];
                if (drug && drug.quantity > 0) {
                    selectDrug(selectedDrug);
                    useSelectedDrug();
                    return;
                }
            }
    
            if (battleState.player.blindfold) {
                // 玩家处于失明状态且处于玩家回合时，使用法术攻击
                performAttack('magical');
            } else {
                // 玩家不处于失明状态且处于玩家回合时
                if (battleAttributes.magicAttack > 0.8 * battleAttributes.physicalAttack && !battleState.player.taunt) {
                    // 99% 概率使用法术攻击
                    if (Math.random() < 0.99) {
                        performAttack('magical');
                    } else {
                        performAttack('physical');
                    }
                } else {
                    // 否则使用物理攻击
                    performAttack('physical');
                }
            }
        }, 300);
        
    } else {
        showInfoBox('聚灵丹数量不足，无法开启自动战斗！',null,null,'red');
    }
}

function clearAutoBattle() {
    if (autoBattleInterval !== null) {
        clearInterval(autoBattleInterval);
        autoBattleInterval = null;
        logBattleEvent("自动战斗已停止。", 'red');
    }
}

function jumpByTenRounds() {
    if (battleState.player.taunt) {
        performAttack('physical');
        return;
    }

    const maxSkipRounds = 1000;
    const remainingRounds = maxSkipRounds - battleRounds;
    const roundsToAdd = Math.min(10, remainingRounds);
    
    if (battleRounds >= maxSkipRounds) {
        showInfoBox(`当前是第${battleRounds}轮，无法再继续跳过！`);
        return;
    }
    
    if (useItem('hailMonsterAmulet',1)) {
        // 增加轮次
        let initialExp = currentExp;
        battleRounds += roundsToAdd;
        
        // 更新邪佞属性
        for (let i = 0; i < roundsToAdd; i++) {
            updateEnemyAttributes();
            gainExp();
            currentExp = initialExp
            updateExpBar();
            logBattleEvent(`你跳过了${roundsToAdd}轮，当前是${battleRounds}轮`, 'pink');
            updatePetInfo();
            updateUI();
        }   
            
    } else {
        showInfoBox('唤妖符数量不足，无法跳过轮次！',null,null,'red');
        return;
    }
}

function backToRoundOne() {
    showInfoBox("你可以使用100个无限宝石和100个清心酿回到第一轮", () => {
        const infiniteGemItem = jinnangItems.find(item => item.name === 'infiniteGem');
        const ignoranceWaterItem = jinnangItems.find(item => item.name === 'ignoranceWater');

        if (!infiniteGemItem || infiniteGemItem.quantity < 100 || !ignoranceWaterItem || ignoranceWaterItem.quantity < 100) {
            showInfoBox("你的无限宝石或清心酿数量不足，无法回退！");
            return;
        }

        // 使用道具
        useItem('infiniteGem', 100);
        useItem('ignoranceWater', 100);

        // 重置回合
        battleRounds = 1;
        initializeEnemyPet();
        updateEnemyAttributes();
        updateUI();
        showInfoBox("时钟空转，你已进入忘却之时……");
    });
}


 

// 【玩家战斗组件】神器系统函数和减益效果驱散函数
function divinedWeapon() {
    if (!divinedWeaponStatus) {
        showInfoBox("使用神器可以为你的技能附加各种强力效果，极大增强你的战斗能力。\n1.神器的开启和使用需要消耗大量经验值或特定的「钥匙」。 \n2.【升满】按钮会根据你当前经验值或所拥有的道具数量直接升至最大值，请知悉。\n3.不建议未满级（180级）前执行神器升级操作。");
        divinedWeaponStatus = true;
    }
    divineWeaponManager.openDivineWeaponUI();
}

class DivineWeaponManager {
    constructor() {
        this.lostBook = { active: false, level: 1, effects: [] };
        this.fragmentedMap = { active: false, level: 1, effects: [] };
        this.nirvanaGem = { active: false, level: 1, effects: [] };
        this.divineWeaponUI = null;
    }
    
    getWeaponData() {
        return {
            lostBook: this.lostBook,
            fragmentedMap: this.fragmentedMap,
            nirvanaGem: this.nirvanaGem
        };
    }

    setWeaponData(data) {
        if (data.lostBook) this.lostBook = data.lostBook;
        if (data.fragmentedMap) this.fragmentedMap = data.fragmentedMap;
        if (data.nirvanaGem) this.nirvanaGem = data.nirvanaGem;
    }

    openDivineWeaponUI() {
        if (this.divineWeaponUI) {
            this.divineWeaponUI.remove();
        }
        
        if (battleState.player.taunt) {
            performAttack('physical');
            return;
        }

        this.divineWeaponUI = document.createElement('div');
        this.divineWeaponUI.style = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0, 0, 0, 0.8); border-radius: 10px; border: 1px solid #F5F5F5; width: 90%; padding: 10px; color: white; z-index: 9990;';
        
        const lostBookTitle = this.lostBook.active ? `神品·遗失的洛书 (Lv${this.lostBook.level})` : '被封锁的上古神器（物理）';
        const lostBookDescription = this.lostBook.active 
            ? this.lostBook.effects.length > 0 
                ? `使用物理技能时，有${(this.lostBook.level * 0.6 + 1).toFixed(1)}%概率触发以下技能效果：` + this.lostBook.effects.map(this.getEffectChineseName).join(', ') 
                : '<p>开启后可能为物理技能附加如下效果：</p><p>破甲、恐吓、眩晕、穿透、麻痹、惶恐</p>'
            : '<p>炽热明亮的金樽，开启后可为物理技能概率附加效果：</p><p>破甲、恐吓、眩晕、穿透、麻痹、惶恐</p>';
    
        const fragmentedMapTitle = this.fragmentedMap.active ? `神品·残页的河图 (Lv${this.fragmentedMap.level})` : '被封锁的上古神器（法术）';
        const fragmentedMapDescription = this.fragmentedMap.active 
            ? this.fragmentedMap.effects.length > 0 
                ? `使用法术技能时，有${(this.fragmentedMap.level * 0.6 + 1).toFixed(1)}%概率触发以下技能效果：` + this.fragmentedMap.effects.map(this.getEffectChineseName).join(', ') 
                : '<p>开启后可能为法术技能附加如下效果：</p><p>迟缓、沉默、混乱、灼烧、法力燃烧、法力吸取</p>'
            : '<p>闪烁星光的宝盒，开启后可为法术技能概率附加效果：</p><p>迟缓、沉默、混乱、灼烧、法力燃烧、法力吸取</p>';
        
        const nirvanaGemTitle = this.nirvanaGem.active ? `神品·定空的灵石 (Lv${this.nirvanaGem.level})` : '被封锁的上古神器（庇护）';
        const nirvanaGemDescription = this.nirvanaGem.active 
            ? this.nirvanaGem.effects.length > 0 
                ? `每秒有${(this.nirvanaGem.level * 0.3 + 0.5).toFixed(1)}%概率驱散以下减益效果：` + this.nirvanaGem.effects.map(this.getEffectChineseName).join(', ') 
                : '<p>开启后可能解除如下减益效果：</p><p>醉酒、禁疗、摄魂、失明、法术迟钝、撕裂、压制、嘲讽、封印、杀戮</p>'
            : '<p>流光溢彩的锦囊，开启后每秒有一定概率驱散敌人的减益效果，成功概率与等级有关。</p>';

        this.divineWeaponUI.innerHTML = `
            <div style="text-align: right;">
                <button onclick="divineWeaponManager.closeDivineWeaponUI()" style="background: transparent; border: none; color: white; font-size: 20px; cursor: pointer;">×</button>
            </div>
            <div style="margin-bottom: 20px; border: 1px solid #F5F5F5; border-radius: 10px; padding: 10px;">
                <div style="display: flex; align-items: center;">
                    <img src="${this.lostBook.active ? 'https://pic.imgdb.cn/item/669a7ce3d9c307b7e9450f04.png' : 'https://pic.imgdb.cn/item/665aecc0d9c307b7e90a239e.png'}" alt="遗失的洛书" style="width: 45px; height: 45px; border: 1px solid white; border-radius: 5px; margin-right: 10px;">
                    <div>
                        <h3 style="margin: 0;">${lostBookTitle}</h3>
                        <p style="margin: 0;">${lostBookDescription}</p>
                    </div>
                </div>
                <div style="display: flex; justify-content: space-evenly; margin-top: 10px;">
                    <button onclick="divineWeaponManager.activateDivineWeapon('lostBook')" style="background: green; color: white; font-size: 14px; border: 1px solid white; border-radius: 5px;">开启</button>
                    <button onclick="divineWeaponManager.refreshDivineWeapon('lostBook')" style="background: green; color: white; font-size: 14px; border: 1px solid white; border-radius: 5px;">刷新</button>
                    <button onclick="divineWeaponManager.upgradeDivineWeapon('lostBook')" style="background: green; color: white; font-size: 14px; border: 1px solid white; border-radius: 5px;">升级</button>
                    <button onclick="divineWeaponManager.upgradeMaxDivineWeapon('lostBook')" style="background: green; color: white; font-size: 14px; border: 1px solid white; border-radius: 5px;">升满</button>
                    <button onclick="divineWeaponManager.description('lostBook')" style="background: green; color: white; font-size: 14px; border: 1px solid white; border-radius: 5px;">说明</button>
                </div>
            </div>
            <div style="margin-bottom: 20px; border: 1px solid #F5F5F5; border-radius: 10px; padding: 10px;">
                <div style="display: flex; align-items: center;">
                    <img src="${this.fragmentedMap.active ? 'https://pic.imgdb.cn/item/669a7ce2d9c307b7e9450ef4.png' : 'https://pic.imgdb.cn/item/665aecc0d9c307b7e90a239e.png'}" alt="残页的河图" style="width: 45px; height: 45px; border: 1px solid white; border-radius: 5px; margin-right: 10px;">
                    <div>
                        <h3 style="margin: 0;">${fragmentedMapTitle}</h3>
                        <p style="margin: 0;">${fragmentedMapDescription}</p>
                    </div>
                </div>
                <div style="display: flex; justify-content: space-evenly; margin-top: 10px;">
                    <button onclick="divineWeaponManager.activateDivineWeapon('fragmentedMap')" style="background: green; color: white; font-size: 14px; border: 1px solid white; border-radius: 5px;">开启</button>
                    <button onclick="divineWeaponManager.refreshDivineWeapon('fragmentedMap')" style="background: green; color: white; font-size: 14px; border: 1px solid white; border-radius: 5px;">刷新</button>
                    <button onclick="divineWeaponManager.upgradeDivineWeapon('fragmentedMap')" style="background: green; color: white; font-size: 14px; border: 1px solid white; border-radius: 5px;">升级</button>
                    <button onclick="divineWeaponManager.upgradeMaxDivineWeapon('fragmentedMap')" style="background: green; color: white; font-size: 14px; border: 1px solid white; border-radius: 5px;">升满</button>
                    <button onclick="divineWeaponManager.description('fragmentedMap')" style="background: green; color: white; font-size: 14px; border: 1px solid white; border-radius: 5px;">说明</button>
                </div>
            </div>
            <div style="margin-bottom: 10px; border: 1px solid #F5F5F5; border-radius: 10px; padding: 10px;">
                <div style="display: flex; align-items: center;">
                    <img src="${this.nirvanaGem.active ? 'https://pic.imgdb.cn/item/66a48e2cd9c307b7e9649085.png' : 'https://pic.imgdb.cn/item/665aecc0d9c307b7e90a239e.png'}" alt="定空的灵石" style="width: 45px; height: 45px; border: 1px solid white; border-radius: 5px; margin-right: 10px;">
                    <div>
                        <h3 style="margin: 0;">${nirvanaGemTitle}</h3>
                        <p style="margin: 0;">${nirvanaGemDescription}</p>
                    </div>
                </div>
                <div style="display: flex; justify-content: space-evenly; margin-top: 10px;">
                    <button onclick="divineWeaponManager.activateDivineWeapon('nirvanaGem')" style="background: green; color: white; font-size: 14px; border: 1px solid white; border-radius: 5px;">开启</button>
                    <button onclick="divineWeaponManager.refreshDivineWeapon('nirvanaGem')" style="background: green; color: white; font-size: 14px; border: 1px solid white; border-radius: 5px;">刷新</button>
                    <button onclick="divineWeaponManager.upgradeDivineWeapon('nirvanaGem')" style="background: green; color: white; font-size: 14px; border: 1px solid white; border-radius: 5px;">升级</button>
                    <button onclick="divineWeaponManager.upgradeMaxDivineWeapon('nirvanaGem')" style="background: green; color: white; font-size: 14px; border: 1px solid white; border-radius: 5px;">升满</button>
                    <button onclick="divineWeaponManager.description('nirvanaGem')" style="background: green; color: white; font-size: 14px; border: 1px solid white; border-radius: 5px;">说明</button>
                </div>
            </div>
            <div style="text-align: right;">
                <button onclick="divineWeaponManager.closeDivineWeaponUI()" style="background: transparent; border: none; color: white; font-size: 20px; cursor: pointer;"></button>
            </div>
        `;

        document.body.appendChild(this.divineWeaponUI);
    }

    closeDivineWeaponUI() {
        if (this.divineWeaponUI) {
            this.divineWeaponUI.remove();
            this.divineWeaponUI = null;
        }
    }

    activateDivineWeapon(type) {
        if (this[type].active) {
            showInfoBox("你已经开启此神器了，无法重复开启！");
            return;
        }

        const itemName = type === 'lostBook' ? 'lostBook' : type === 'fragmentedMap' ? 'fragmentedMap' : 'nirvanaGem';
        if (useItem(itemName)) {
            this[type].active = true;
            this[type].effects = [this.getRandomEffect(type)];
            showInfoBox(`${type === 'lostBook' ? '遗失的洛书' : type === 'fragmentedMap' ? '残页的河图' : '定空的灵石'}已成功开启！`);
            this.openDivineWeaponUI(); // 刷新界面显示
            return;
        }

        if (currentExp < 200000) {
            showInfoBox("经验不足200000或缺少对应的「钥匙」。神器的「钥匙」可以通过武神仙葫小概率获得。");
            return;
        }

        currentExp -= 200000;
        updateExpBar();

        this[type].active = true;
        this[type].effects = [this.getRandomEffect(type)];
        showInfoBox(`${type === 'lostBook' ? '遗失的洛书' : type === 'fragmentedMap' ? '残页的河图' : '定空的灵石'}已成功开启！`);
        this.openDivineWeaponUI(); // 刷新界面显示
    }
    

    
    description(type) {
        const itemName = type === 'lostBook' ? 'lostBook' : type === 'fragmentedMap' ? 'fragmentedMap' : 'nirvanaGem';
        showInfoBox(weaponDescriptions[itemName]);
        this.openDivineWeaponUI(); // 刷新界面显示
    }
    
    refreshDivineWeapon(type) {
        if (!this[type].active) {
            showInfoBox("开启神器后才能执行刷新！");
            return;
        }
    
        const itemName = type === 'lostBook' ? 'lostBook' : type === 'fragmentedMap' ? 'fragmentedMap' : 'nirvanaGem';
        if (useItem(itemName)) {
            const chance = Math.random();
            if (type === 'nirvanaGem') {
                if (chance < 0.05) {
                    this[type].effects = [
                        this.getRandomEffect(type),
                        this.getRandomEffect(type),
                        this.getRandomEffect(type),
                        this.getRandomEffect(type),
                        this.getRandomEffect(type)
                    ];
                } else if (chance < 0.15) {
                    this[type].effects = [
                        this.getRandomEffect(type),
                        this.getRandomEffect(type),
                        this.getRandomEffect(type),
                        this.getRandomEffect(type)
                    ];
                } else if (chance < 0.30) {
                    this[type].effects = [
                        this.getRandomEffect(type),
                        this.getRandomEffect(type),
                        this.getRandomEffect(type)
                    ];
                } else if (chance < 0.60) {
                    this[type].effects = [
                        this.getRandomEffect(type),
                        this.getRandomEffect(type)
                    ];
                } else {
                    this[type].effects = [this.getRandomEffect(type)];
                }
            } else {
                if (chance < 0.05) {
                    this[type].effects = [this.getRandomEffect(type), this.getRandomEffect(type), this.getRandomEffect(type)];
                } else if (chance < 0.20) {
                    this[type].effects = [this.getRandomEffect(type), this.getRandomEffect(type)];
                } else {
                    this[type].effects = [this.getRandomEffect(type)];
                }
            }
            this.openDivineWeaponUI(); // 刷新界面显示
            return;
        }
    
        if (currentExp < 100000) {
            showInfoBox("经验不足100000或没有对应钥匙，无法刷新效果。（如果你拥有钥匙，将会优先自动使用钥匙刷新）");
            return;
        }
    
        currentExp -= 100000;
        updateExpBar();
    
        const chance = Math.random();
        if (type === 'nirvanaGem') {
            if (chance < 0.05) {
                this[type].effects = [
                    this.getRandomEffect(type),
                    this.getRandomEffect(type),
                    this.getRandomEffect(type),
                    this.getRandomEffect(type),
                    this.getRandomEffect(type)
                ];
            } else if (chance < 0.15) {
                this[type].effects = [
                    this.getRandomEffect(type),
                    this.getRandomEffect(type),
                    this.getRandomEffect(type),
                    this.getRandomEffect(type)
                ];
            } else if (chance < 0.30) {
                this[type].effects = [
                    this.getRandomEffect(type),
                    this.getRandomEffect(type),
                    this.getRandomEffect(type)
                ];
            } else if (chance < 0.60) {
                this[type].effects = [
                    this.getRandomEffect(type),
                    this.getRandomEffect(type)
                ];
            } else {
                this[type].effects = [this.getRandomEffect(type)];
            }
        } else {
            if (chance < 0.05) {
                this[type].effects = [this.getRandomEffect(type), this.getRandomEffect(type), this.getRandomEffect(type)];
            } else if (chance < 0.20) {
                this[type].effects = [this.getRandomEffect(type), this.getRandomEffect(type)];
            } else {
                this[type].effects = [this.getRandomEffect(type)];
            }
        }
        showInfoBox(`${type === 'lostBook' ? '遗失的洛书' : type === 'fragmentedMap' ? '残页的河图' : '定空的灵石'}已通过经验刷新。`);
        this.openDivineWeaponUI(); // 刷新界面显示
    }
    
    upgradeDivineWeapon(type) {
        if (!this[type].active) {
            showInfoBox("开启神器后才能执行升级！");
            return;
        }
    
        if (this[type].level >= 165) {
            showInfoBox("神器等级已达到上限。");
            return;
        }
    
        const itemName = type === 'lostBook' ? 'lostBook' : type === 'fragmentedMap' ? 'fragmentedMap' : 'nirvanaGem';
    
        if (this[type].level >= 100 || useItem(itemName)) {
            if (this[type].level >= 100 && !useItem(itemName)) {
                showInfoBox("神器100级后，只能使用「钥匙」升级，你可以通过开启武神仙葫获取「钥匙」。");
                return;
            }
            
            this[type].level += 1;
            this.openDivineWeaponUI(); // 刷新界面显示
            return;
        }
    
        if (currentExp < 3000) {
            showInfoBox("经验不足3000或缺少对应「钥匙」，无法升级神器。");
            return;
        }
    
        currentExp -= 3000;
        updateExpBar();
        this[type].level += 1;
        this.openDivineWeaponUI(); // 刷新界面显示
    }
    
    upgradeMaxDivineWeapon(type) {
        while (this[type].level < 165) {
            const previousLevel = this[type].level;
            this.upgradeDivineWeapon(type);
            if (this[type].level === previousLevel) {
                break; // If the level didn't change, exit the loop
            }
        }
    }

    getRandomEffect(type) {
        if (type === 'lostBook') {
            const effects = ['破甲', '眩晕', '恐吓', '麻痹', '穿透', '惶恐'];
            return effects[Math.floor(Math.random() * effects.length)];
        } else if (type === 'fragmentedMap') {
            const effects = ['沉默', '迟缓', '混乱', '法力燃烧', '灼烧', '法力吸取'];
            return effects[Math.floor(Math.random() * effects.length)];
        } else if (type === 'nirvanaGem') {
            const effects = ['drunken', 'healingBan', 'soulCapture', 'blindfold', 'spellSlow', 'torn', 'suppressed', 'taunt', 'seal', 'slaughter'];
            return effects[Math.floor(Math.random() * effects.length)];
        }
    }

    getEffectChineseName(effect) {
        const effectMap = {
            '破甲': '破甲',
            '眩晕': '眩晕',
            '恐吓': '恐吓',
            '麻痹': '麻痹',
            '穿透': '穿透',
            '惶恐': '惶恐',
            '沉默': '沉默',
            '迟缓': '迟缓',
            '混乱': '混乱',
            '法力燃烧': '法力燃烧',
            '法力吸取': '法力吸取',
            '灼烧': '灼烧',
            'drunken': '醉酒',
            'healingBan': '禁疗',
            'soulCapture': '摄魂',
            'blindfold': '失明',
            'spellSlow': '法术迟钝',
            'torn': '撕裂',
            'suppressed': '压制',
            'taunt': '嘲讽',
            'seal': '封印',
            'slaughter': '杀戮'
        };
        return effectMap[effect] || effect;
    }

    applyNirvanaGemEffects() {
        if (!this.nirvanaGem.active) return;

        const triggerProbability = Math.min(1, 0.005 + (this.nirvanaGem.level - 1) * 0.003);
        if (Math.random() > triggerProbability) return; // 没有触发效果

        const debuffs = ['drunken', 'healingBan', 'soulCapture', 'blindfold', 'spellSlow', 'torn', 'suppressed', 'taunt', 'seal', 'slaughter'];
        const activeDebuffs = debuffs.filter(debuff => battleState.player[debuff]);
        const applicableDebuffs = this.nirvanaGem.effects.filter(effect => debuffs.includes(effect));

        const debuffsToRemove = activeDebuffs.filter(debuff => applicableDebuffs.includes(debuff));

        if (debuffsToRemove.length > 0) {
            const debuffToRemove = debuffsToRemove[Math.floor(Math.random() * debuffsToRemove.length)];
            battleState.player[debuffToRemove] = false;

            switch (debuffToRemove) {
                case 'drunken':
                    break;
                case 'healingBan':
                    break;
                case 'spellSlow':
                    break;
                case 'soulCapture':
                    battleAttributes.physicalAttack = battleState.player.physicalAttack;
                    battleAttributes.magicAttack = battleState.player.magicAttack;
                    updateUI();
                    updatePlayerStatusDisplay();
                    break;
                case 'torn':
                    clearInterval(battleState.player.tornInterval);
                    effectCooldowns.torn = false;
                    break;
                case 'suppressed':
                    // 清除压制效果，恢复原始函数
                    cleanSuppressed();
                    break;
                case 'taunt':
                    // 清除嘲讽效果，恢复原始函数
                    clearTaunt();
                    break;
                case 'slaughter':
                    // 清除杀戮效果，恢复原始函数
                    cleanSlaughter();
                    break;
                case 'blindFold':
                    break;
                case 'seal':
                    ascensionSkill.name = battleState.player.originalAscensionSkill;
                    secondAscensionSkill.name = battleState.player.originalSecondAscensionSkill;
                    updateAscensionDisplay();
                    updateSecondAscensionDisplay();
                    effectCooldowns.seal = false;
                    updateUI();
                    break;
            }

            logBattleEvent(`定空的灵石解除了你的${this.getEffectChineseName(debuffToRemove)}状态。`, '#D3D3D3');
            showBattleOverlay("https://pic.imgdb.cn/item/66a33f3ad9c307b7e942c38c.gif", 1000, 1, 1000);
            updatePlayerStatusDisplay();
            updateUI();
        }
    }
}

function cleanSlaughter() {
    battleState.player.slaughter = false;
    effectCooldowns.slaughter = false;
    enemyPhysicalAttackCount = 0;
    updatePlayerStatusDisplay();
    console.log("杀戮状态已被解除。");
}

function cleanSuppressed() {
    if (battleState.player.suppressed) {
        clearTimeout(suppressionState.timeoutId); // 清除压制定时器

        // 备份原始的攻击和防御函数
        const originalPerformPhysicalAttack = performPhysicalAttack;
        const originalPerformMagicalAttack = performMagicalAttack;
        const originalPerformHeal = performHeal;
        const originalPerformPoison = performPoison;
        const originalPerformDefense = performDefense;

        // 重置玩家的压制状态和效果冷却时间
        battleState.player.suppressed = false;
        effectCooldowns.suppressed = false;

        if (!suppressionState.actionPerformed || battleState.player.suppressed) {
            battleAttributes.health = 1;
            battleAttributes.mana = 1;
            battleAttributes.physicalAttack = 1;
            battleAttributes.magicAttack = 1;
            logBattleEvent("你的无动于衷极大助长了邪佞的威压，它降下地狱之火焚尽了你的战斗能力。", '#FF4500');
            showBattleOverlay("https://pic.imgdb.cn/item/66a484fcd9c307b7e95c2645.gif", 1500, 0.8);
        }

        // 恢复原始的攻击和防御函数
        performPhysicalAttack = originalPerformPhysicalAttack;
        performMagicalAttack = originalPerformMagicalAttack;
        performHeal = originalPerformHeal;
        performPoison = originalPerformPoison;
        performDefense = originalPerformDefense;

        // 更新玩家状态显示和 UI
        updatePlayerStatusDisplay();
    }
    updateUI();
}

function clearTaunt() {
    battleState.player.taunt = false;
    effectCooldowns.taunt = false;
    clearTimeout(tauntTimeout); // 清除嘲讽定时器

    // 更新状态显示和UI
    updatePlayerStatusDisplay();
    updateUI();
}

function clearEnemyEffect() {
    const effects = ['drunken', 'healingBan', 'soulCapture', 'blindfold', 'spellSlow', 'torn', 'suppressed', 'taunt', 'seal', 'slaughter', 'shocked'];

    effects.forEach(effect => {
        if (battleState.player[effect]) {
            battleState.player[effect] = false;
            effectCooldowns[effect] = false;

            switch (effect) {
                case 'drunken':
                    // 清除醉酒效果，直接设置状态为false即可
                    break;
                case 'healingBan':
                    // 清除禁疗效果，直接设置状态为false即可
                    break;
                case 'soulCapture':
                    // 清除摄魂效果，恢复攻击力
                    battleAttributes.physicalAttack = battleState.player.physicalAttack;
                    battleAttributes.magicAttack = battleState.player.magicAttack;
                    updateUI();
                    updatePlayerStatusDisplay();
                    break;
                case 'torn':
                    // 清除撕裂效果，停止持续伤害
                    clearInterval(battleState.player.tornInterval);
                    break;
                case 'suppressed':
                    // 清除压制效果
                    cleanSuppressed();
                    break;
                case 'taunt':
                    // 清除嘲讽效果，恢复原始函数
                    clearTaunt();
                    break;
                case 'slaughter':
                    // 清除杀戮效果，恢复原始函数
                    cleanSlaughter();
                    break;
                case 'seal':
                    // 清除封印效果，恢复原始技能名称
                    ascensionSkill.name = battleState.player.originalAscensionSkill;
                    secondAscensionSkill.name = battleState.player.originalSecondAscensionSkill;
                    updateAscensionDisplay();
                    updateSecondAscensionDisplay();
                    updateUI();
                    break;
                case 'shocked':
                    // 设置为false
                    break;
            }
        }
    });
    updatePlayerStatusDisplay();
} //清理玩家目前的减益效果

function clearPlayerEffect() {
    const effects = [
        { name: 'armorBreak', timer: battleState.enemy.armorBreakTimer },
        { name: 'pierced', timer: battleState.enemy.piercedTimer },
        { name: 'silenced', timer: battleState.enemy.silencedTimer },
        { name: 'poisoned', timer: battleState.enemy.poisonedTimer },
        { name: 'stunned', timer: battleState.enemy.stunnedTimer },
        { name: 'intimidated', timer: battleState.enemy.intimidatedTimer },
        { name: 'benumbed', timer: battleState.enemy.benumbedTimer },
        { name: 'dazed', timer: battleState.enemy.dazedTimer },
        { name: 'burnt', timer: battleState.enemy.burntTimer },
        { name: 'slow', timer: battleState.enemy.slowTimer },
        { name: 'terrified', timer: battleState.enemy.terrifiedTimer }
    ];

    effects.forEach(effect => {
        battleState.enemy[effect.name] = false;

        if (effect.timer) {
            clearTimeout(effect.timer);
            effect.timer = null;
        }
    });

    updateEnemyStatusDisplay();
} //清理敌人目前的减益效果

const divineWeaponManager = new DivineWeaponManager();

// 五行符测试模块
let wuxingFragments = 0;  // 分解后获得的碎片数量
let wuxingStates = [];  // 存储所有五行符的状态
const MAX_LEVEL = 100;  // 强化等级上限

const wuxingTypeMap = {
    goldAmulet: '金符',
    woodAmulet: '木符',
    waterAmulet: '水符',
    fireAmulet: '火符',
    earthAmulet: '土符'
};

const wuxingColorMap = {
    red: '红色',
    green: '绿色',
    blue: '蓝色',
    orange: '橙色',
    purple: '紫色'
};

const wuxingBonusMap = {
    health: 'HP',
    mana: 'MP',
    physicalAttack: '物攻',
    magicAttack: '法攻',
    physicalDefense: '物防',
    magicDefense: '法防',
    speed: '速度',
    WXplayerCritRate: '%暴击率',
    WXplayerCritDamage: '%暴击伤害'
};

// 初始化五行符管理器
function addAmuletToManager(amuletType, color, level = 1) {
    // 首先检查 wuxingStates 的长度是否超过 500
    if (wuxingStates.length >= 200) {
        showInfoBox('已超过可拥有的五行符上限！', null, null, 'red');
        return;  // 终止函数执行，防止继续添加五行符
    }

    const wuxingName = `${amuletType}(${color})`;
    const uniqueTag = `${wuxingName}-${Date.now()}-${Math.floor(Math.random() * 1000)}`;

    // 随机生成 rank，概率均等
    const rank = Math.ceil(Math.random() * 5);  // 1 - 5 等级

    const newAmulet = {
        tag: uniqueTag,
        name: wuxingName,
        color: color,
        level: level,
        rank: rank,  // 新增 rank 属性
        drugBonus: initializeDrugBonus(color, level, rank),
        additionalValues: generateAdditionalValues(color, rank),
        equipped: false,
        currentPetName: null
    };

    // 将新五行符添加到全局管理器
    wuxingStates.push(newAmulet);
    updateWuxingDisplay();
}

function openWuxingDisplay() {
    document.getElementById('wuxing-display').style.display = 'block';
    updateWuxingDisplay();
    updateWuxingBonusState();
}

function closeWuxingDisplay() {
    document.getElementById('wuxing-display').style.display = 'none';
    updateWuxingBonusState();
}

// 初始化主条目加成
function initializeDrugBonus(color, level, rank, selectedBonus = null) {
    const rankMultiplier = [1, 0.8, 0.6, 0.4, 0.2][rank - 1];  // 根据 rank 调整倍率
    const bonus = {
        physicalAttack: 0,
        magicAttack: 0,
        physicalDefense: 0,
        mana: 0,
        health: 0,
        magicDefense: 0,
        speed: 0
    };

    const increment = {
        red: { physicalAttack: 200, magicAttack: 200 },
        green: { physicalDefense: 1500 },
        blue: { mana: 1000 },
        orange: { health: 1300 },
        purple: { magicDefense: 1500 }
    };

    if (color === 'red' && selectedBonus) {
        for (let i = 1; i <= level; i++) {
            bonus[selectedBonus] += Math.floor(increment.red[selectedBonus] * rankMultiplier);
        }
    } else {
        for (let i = 1; i <= level; i++) {
            Object.keys(bonus).forEach(key => {
                if (increment[color] && increment[color][key]) {
                    bonus[key] += Math.floor(increment[color][key] * rankMultiplier);
                }
            });
        }
    }

    return bonus;
}

        
// 生成副条目
function generateAdditionalValues(color, rank) {
    const rankMultiplier = [1, 0.8, 0.6, 0.4, 0.2][rank - 1];  // 根据rank调整倍率
    const additionalValues = [];
    const attributes = [
        'physicalAttack', 'magicAttack', 'physicalDefense', 'mana', 'health', 'magicDefense'
    ];
    const critAttributes = ['WXplayerCritRate', 'WXplayerCritDamage'];
    const percentageAttributes = attributes.map(attr => `‰${attr}`);
    let percentageCount = 0;
    let critRateExists = false;
    let critDamageExists = false;

    if (color === 'green') {
        attributes.push('speed');
    }

    const allAttributes = attributes.concat(percentageAttributes).concat(critAttributes);
    const numOfValues = Math.floor(Math.random() * 5) + 1;

    for (let i = 0; i < numOfValues; i++) {
        let randomAttribute = allAttributes[Math.floor(Math.random() * allAttributes.length)];

        // 确保每种暴击属性最多生成一条
        if (randomAttribute === 'WXplayerCritRate' && critRateExists) continue;
        if (randomAttribute === 'WXplayerCritDamage' && critDamageExists) continue;

        // 限制千分比属性数量，不生成千分比形式的暴击率和暴击伤害
        if (randomAttribute.startsWith('‰') && percentageCount >= 2) {
            const remainingAttributes = attributes.filter(attr => !additionalValues.some(a => a.attribute === attr));
            if (remainingAttributes.length > 0) {
                randomAttribute = remainingAttributes[Math.floor(Math.random() * remainingAttributes.length)];
            }
        }

        if (randomAttribute === 'WXplayerCritRate') {
            const randomValue = Math.floor((Math.random() * (7 - 5 + 1) + 5) * rankMultiplier);
            additionalValues.push({ attribute: randomAttribute, value: randomValue });
            critRateExists = true;
        } else if (randomAttribute === 'WXplayerCritDamage') {
            const randomValue = Math.floor((Math.random() * (7 - 5 + 1) + 5) * rankMultiplier);
            additionalValues.push({ attribute: randomAttribute, value: randomValue });
            critDamageExists = true;
        } else if (randomAttribute.startsWith('‰')) {
            const randomValue = Math.floor((Math.random() * (7 - 5 + 1) + 5) * rankMultiplier);
            additionalValues.push({ attribute: randomAttribute, value: randomValue });
            percentageCount++;
        } else {
            const randomValue = Math.floor((Math.random() * 301 + 300) * rankMultiplier);
            additionalValues.push({ attribute: randomAttribute, value: randomValue });
        }

        if (critRateExists && critDamageExists) break;
    }

    return additionalValues;
}

 
// 更新显示界面
function updateWuxingDisplay() {
    const wuxingContainer = document.getElementById('wuxing-container');
    const equippedContainer = document.getElementById('equipped-container');
    const fragmentsDisplay = document.getElementById('wuxing-fragments');
    const rankNames = ['一等', '二等', '三等', '四等', '五等'];
    let selectedAmulet = null; // 用于记录当前选中的五行符

    wuxingContainer.innerHTML = '';
    equippedContainer.innerHTML = '';
    fragmentsDisplay.innerText = `五行碎片: ${wuxingFragments}`;

    wuxingStates.forEach(amulet => {
        const amuletElement = document.createElement('div');
        amuletElement.className = `wuxing-item ${amulet.color}-border`;

        const petAmulet = wuxingStates.find(a => a.tag === amulet.tag);
        if (petAmulet && petAmulet.equipped) {
            amuletElement.classList.add('equipped');
        }

        if (amulet.level > 1) {
            amuletElement.style.boxShadow = `0px 0px 5px 2px ${amulet.color}`;
        }

        amuletElement.style.backgroundImage = `url(${getAmuletImageURL(amulet.name)})`;

        const amuletInfo = document.createElement('div');
        amuletInfo.className = 'wuxing-info';
        amuletInfo.innerText = `${wuxingTypeMap[amulet.name.split('(')[0]]} (${rankNames[amulet.rank - 1]})`;

        amuletElement.appendChild(amuletInfo);

        amuletElement.addEventListener('click', () => {
            if (selectedAmulet) {
                // 重置上一个被选中五行符的样式
                selectedAmulet.style.boxShadow = selectedAmulet.originalBoxShadow || '';
                ensureAmuletRank(amulet);
            }

            // 记录当前选中的五行符
            selectedAmulet = amuletElement;
            selectedAmulet.originalBoxShadow = amuletElement.style.boxShadow; // 保存原始的 boxShadow

            // 应用新的选中样式
            selectedAmulet.style.boxShadow = '0px 0px 0px 2px white';

            displayAmuletDetails(amulet);
        });

        wuxingContainer.appendChild(amuletElement);

        // 如果该五行符被当前宠物装备，显示在装备区
        if (petAmulet && petAmulet.equipped && petAmulet.currentPetName === currentPet.name) {
            const equippedElement = amuletElement.cloneNode(true);
            equippedElement.addEventListener('click', () => displayAmuletDetails(amulet));
            equippedContainer.appendChild(equippedElement);
        }
        // 如果被装备但装备者不是当前宠物，则不克隆元素
        else if (petAmulet && petAmulet.equipped && petAmulet.currentPetName !== currentPet.name) {
            // 不进行克隆操作，也不显示在装备区
            // 这里可以添加任何你想要处理的逻辑，比如提示信息或标记
            console.log(`${amulet.name} 被 ${petAmulet.currentPetName} 装备，无法装备在当前宠物上`);
        }
    });
    updateAttributePanel();
    updateAppliedEffectsDisplay();
    console.log(drugBonus);
}

function ensureAmuletRank(amulet) {
    if (!amulet.rank) {
        amulet.rank = 1;  // 默认设为一等
    }
}

function updateAppliedEffectsDisplay() {
    // 获取装备生效的五行符效果
    const activeEffects = applyWuxingEffects();
    
    // 获取applied-effects元素
    const effectsContainer = document.getElementById('applied-effects');
    
    // 清空当前内容
    effectsContainer.innerHTML = '';
    
    // 检查是否存在生效的五行符效果
    if (Object.keys(activeEffects).length === 0) {
        effectsContainer.innerText = '目前没有生效的五行符效果';
        return;
    }
    
    // 创建一个数组来存储显示的效果字符串
    const effectsList = [];
    
    // 根据生效的效果类型和强度生成描述字符串
    Object.keys(activeEffects).forEach(effectType => {
        const effectLevel = activeEffects[effectType];
        const effectName = wuxingTypeMap[effectType];
        const effectDisplayText = `${effectName}: 强度${effectLevel}级`;
        effectsList.push(effectDisplayText);
    });
    
    // 将效果字符串连接为一个字符串，以逗号隔开，并插入到页面元素中
    effectsContainer.innerText = effectsList.join(', ');
}

        
// 显示五行符详细信息
function displayAmuletDetails(amulet) {
    const rankNames = ['一等', '二等', '三等', '四等', '五等'];
    const detailsContainer = document.getElementById('amulet-details');
    detailsContainer.innerHTML = `
        <div id="text-container" style="height: 120px;margin-bottom: 30px;line-height: 28px;">
            <h3 style="margin:0;color: ${amulet.color};">${wuxingTypeMap[amulet.name.split('(')[0]]} (${rankNames[amulet.rank - 1]})<span id="equipped-pet-name"></span></h3>
            <p style="margin:0;">等级: ${amulet.level}</p>
            <p style="margin:0;">主属性: ${Object.entries(amulet.drugBonus)
                .filter(([key, value]) => value > 0)
                .map(([key, value]) => `${wuxingBonusMap[key]}: +${value}`).join(', ')}</p>
            <p style="margin:0;">副属性: ${amulet.additionalValues.map(v => 
                v.attribute.startsWith('‰')
                ? `${v.value}‰ ${wuxingBonusMap[v.attribute.replace('‰', '')]}`
                : `+${v.value} ${wuxingBonusMap[v.attribute]}`).join(', ')}</p>
        </div>
    `;
    
    
    const wuxingButtonContainer = document.createElement('div');
    wuxingButtonContainer.className = 'wuxing-action';
    wuxingButtonContainer.style.display = 'flex';
    wuxingButtonContainer.style.gap = '5px';
    wuxingButtonContainer.style.justifyContent = 'center';

    const enhanceButton = document.createElement('button');
    enhanceButton.innerText = '强化';
    enhanceButton.onclick = () => enhanceAmulet(amulet.tag);

    const decomposeButton = document.createElement('button');
    decomposeButton.innerText = '分解';
    decomposeButton.onclick = () => decomposeAmulet(amulet.tag);

    const equipButton = document.createElement('button');
    equipButton.innerText = '装备';
    equipButton.onclick = () => equipAmulet(amulet.tag);

    const unequipButton = document.createElement('button');
    unequipButton.innerText = '卸下';
    unequipButton.onclick = () => unequipAmulet(amulet.tag);
    
    const wipeOffButton = document.createElement('button');
    wipeOffButton.innerText = '清空';
    wipeOffButton.onclick = () => wipeOffAmulet();

    // 新增整理按钮
    const sortButton = document.createElement('button');
    sortButton.innerText = '整理';
    sortButton.onclick = () => sortAmuletsByRank();

    const petAmulet = wuxingStates.find(a => a.tag === amulet.tag);
    if (petAmulet && petAmulet.equipped) {
        document.getElementById('equipped-pet-name').innerText = `  由${petAmulet.currentPetName}装备`;
        unequipButton.disabled = false;
    } else {
        document.getElementById('equipped-pet-name').innerText = '';
        unequipButton.disabled = true;
    }

    wuxingButtonContainer.appendChild(enhanceButton);
    wuxingButtonContainer.appendChild(decomposeButton);
    wuxingButtonContainer.appendChild(equipButton);
    wuxingButtonContainer.appendChild(unequipButton);
    wuxingButtonContainer.appendChild(wipeOffButton);
    wuxingButtonContainer.appendChild(sortButton); // 添加整理按钮

    detailsContainer.appendChild(wuxingButtonContainer);
}

function sortAmuletsByRank() {
    // 按照rank -> name -> color的顺序进行排序
    wuxingStates.sort((a, b) => {
        // 先按rank排序（从高到低）
        if (a.rank !== b.rank) {
            return a.rank - b.rank;
        }
        
        // 再按name排序（按字母顺序）
        const nameA = a.name.split('(')[0];
        const nameB = b.name.split('(')[0];
        if (nameA < nameB) return -1;
        if (nameA > nameB) return 1;
        
        // 最后按color排序（按字母顺序）
        if (a.color < b.color) return -1;
        if (a.color > b.color) return 1;

        return 0; // 所有比较都相等
    });

    // 更新UI显示，确保排序结果及时显示
    updateWuxingDisplay();

    showInfoBox('背包已按五行符等级、类型和颜色整理完毕。', null, null, 'green');
}


// 应用五行符增益
function resetWuxingCritBonuses() {
    wuxingStates.forEach(petAmuletState => {
        if (petAmuletState.equipped && petAmuletState.currentPetName === currentPet.name) {
            const amulet = wuxingStates.find(amulet => amulet.tag === petAmuletState.tag);
            if (amulet) {
                amulet.additionalValues.forEach(additional => {
                    if (additional.attribute === 'WXplayerCritRate') {
                        playerCritRate -= additional.value / 100;
                    } else if (additional.attribute === 'WXplayerCritDamage') {
                        playerCritDamage -= additional.value / 100;
                    }
                });
            }
        }
    });
}

function applyAdditionalValueBonus(additional, secondaryAttributes, apply = true) {
    const key = additional.attribute;
    const value = additional.value;

    if (key.startsWith('‰')) {
        const baseAttribute = key.replace('‰', '');
        const multiplier = value / 1000;  // Convert ‰ to percentage
        const additionalValue = Math.floor(secondaryAttributes[baseAttribute] * multiplier);

        if (apply) {
            drugBonus[baseAttribute] += additionalValue;
        } else {
            drugBonus[baseAttribute] -= additionalValue;
            if (drugBonus[baseAttribute] < 0) {
                drugBonus[baseAttribute] = 0;
            }
        }
    } else if (key === 'WXplayerCritRate') {
        playerCritRate += apply ? value / 100 : -value / 100;
        if (playerCritRate < 0) playerCritRate = 0;
    } else if (key === 'WXplayerCritDamage') {
        playerCritDamage += apply ? value / 100 : -value / 100;
        if (playerCritDamage < 0) playerCritDamage = 0;
    } else {
        if (apply) {
            drugBonus[key] += value;
        } else {
            drugBonus[key] -= value;
            if (drugBonus[key] < 0) {
                drugBonus[key] = 0;
            }
        }
    }
}

function applyAmuletBonus(amulet, apply = true) {
    const currentAttributes = calculateCurrentAttributes();
    const secondaryAttributes = calculateSecondaryAttributes(currentAttributes, currentWisdom);

    // 处理 drugBonus
    Object.keys(amulet.drugBonus).forEach(key => {
        if (apply) {
            drugBonus[key] += amulet.drugBonus[key];
        } else {
            drugBonus[key] -= amulet.drugBonus[key];
            if (drugBonus[key] < 0) {
                drugBonus[key] = 0;
            }
        }
    });

    // 处理 additionalValues
    amulet.additionalValues.forEach(additional => {
        applyAdditionalValueBonus(additional, secondaryAttributes, apply);
    });

    updateUI();
    updateAttributePanel();
}

function updateWuxingBonusState() {
    // 清空 drugBonus
    Object.keys(drugBonus).forEach(key => {
        drugBonus[key] = 0;
    });

    // 仅移除当前五行符提供的暴击率和暴击伤害增益
    resetWuxingCritBonuses();

    // 重新应用当前宠物已装备的五行符的增益
    wuxingStates.forEach(petAmuletState => {
        if (petAmuletState.equipped && petAmuletState.currentPetName === currentPet.name) {
            const amulet = wuxingStates.find(amulet => amulet.tag === petAmuletState.tag);
            if (amulet) {
                applyAmuletBonus(amulet, true);
            }
        }
    });

    updateUI();  // 更新界面以反映最新的增益值
}


        
// 分解五行符
function decomposeAmulet(tag) {
    const amuletIndex = wuxingStates.findIndex(amulet => amulet.tag === tag);

    if (amuletIndex === -1) {
        showInfoBox("找不到指定的五行符，请确保五行符未装备", null, null, 'red');
        return;
    }

    const amulet = wuxingStates[amuletIndex];

    if (amulet.equipped) {
        showInfoBox(`该五行符已经被 ${amulet.currentPetName} 装备，无法分解。`, null, null, 'red');
        return;
    }

    const confirmDecomposition = () => {
        const rankMultiplier = [475, 95, 20, 5, 1][amulet.rank - 1];  // 根据 rank 计算分解碎片基数
        const fragmentsGained = amulet.level * rankMultiplier;  // 根据等级计算总分解碎片数量

        wuxingFragments += fragmentsGained;
        wuxingStates.splice(amuletIndex, 1);

        showInfoBox(`分解成功！你获得了 ${fragmentsGained} 个五行碎片。`, null, null, 'green');
        updateWuxingDisplay();
    };

    const cancelDecomposition = () => {
        showInfoBox("分解操作已取消。", null, null, 'black');
    };

    showInfoBox("你确定要分解此五行符吗？该操作不可恢复。", confirmDecomposition, cancelDecomposition, 'red');
}

function wipeOffAmulet() {
    const amuletsToWipe = wuxingStates.filter(amulet => !amulet.equipped && amulet.currentPetName === null && amulet.level === 1);

    if (amuletsToWipe.length === 0) {
        showInfoBox("没有找到符合条件的五行符。", null, null, 'red');
        return;
    }

    const confirmWipeOff = () => {
        let totalFragmentsGained = 0;
        let totalAmuletsWiped = 0;

        amuletsToWipe.forEach(amulet => {
            const amuletIndex = wuxingStates.indexOf(amulet);
            if (amuletIndex !== -1) {
                const rankMultiplier = [475, 95, 20, 5, 1][amulet.rank - 1];  // 根据 rank 计算分解碎片基数
                const fragmentsGained = amulet.level * rankMultiplier;  // 根据等级计算总分解碎片数量

                totalFragmentsGained += fragmentsGained;
                totalAmuletsWiped += 1;

                wuxingStates.splice(amuletIndex, 1); // 从列表中移除五行符
            }
        });

        wuxingFragments += totalFragmentsGained;
        showInfoBox(`成功分解了 ${totalAmuletsWiped} 张五行符，获得了 ${totalFragmentsGained} 个五行碎片。`, null, null, 'green');
        updateWuxingDisplay();
    };

    const cancelWipeOff = () => {
        showInfoBox("清除操作已取消。", null, null, 'black');
    };

    showInfoBox("你确定要清除所有未装备且等级为1的五行符吗？该操作不可恢复。", confirmWipeOff, cancelWipeOff, 'red');
}

function equipAmulet(tag) {
    const amulet = wuxingStates.find(amulet => amulet.tag === tag);

    if (!amulet) {
        showInfoBox("找不到指定的五行符。", null, null, 'red');
        return;
    }

    if (amulet.equipped) {
        if (amulet.currentPetName !== currentPet.name) {
            showInfoBox(`该五行符已经被 ${amulet.currentPetName} 装备。`, null, null, 'red');
        } else {
            showInfoBox(`该五行符已经装备在当前宠物上。`, null, null, 'green');
        }
        return;
    }

    const equippedSameType = wuxingStates.some(a => a.color === amulet.color && a.equipped && a.currentPetName === currentPet.name);

    if (equippedSameType) {
        showInfoBox(`已经装备了一张 ${wuxingColorMap[amulet.color]} 的五行符。`, null, null, 'red');
        return;
    }

    amulet.equipped = true;
    amulet.currentPetName = currentPet.name;
    document.getElementById('equipped-pet-name').innerText = ` 由${amulet.currentPetName}装备`;

    applyAmuletBonus(amulet, true);
    updateWuxingDisplay();
}

function unequipAmulet(tag) {
    const amulet = wuxingStates.find(amulet => amulet.tag === tag);

    if (!amulet) {
        showInfoBox("找不到指定的五行符。", null, null, 'red');
        return;
    }

    if (!amulet.equipped) {
        showInfoBox("该五行符未被装备。", null, null, 'red');
        return;
    }

    //if (amulet.currentPetName !== currentPet.name) {
        //showInfoBox(`该五行符已经被 ${amulet.currentPetName} 装备，需要至装备宠物处卸下。`, null, null, 'red');
        //return;
    //}
    document.getElementById('equipped-pet-name').innerText = '';
    applyAmuletBonus(amulet, false);
    amulet.equipped = false;
    amulet.currentPetName = null;

    updateWuxingDisplay();
}

// 强化五行符
function getRankCost(rank) {
    switch (rank) {
        case 1:
            return { exp: 20000, fragments: 625 };
        case 2:
            return { exp: 18000, fragments: 125 };
        case 3:
            return { exp: 15000, fragments: 25 };
        case 4:
            return { exp: 12000, fragments: 5 };
        case 5:
            return { exp: 10000, fragments: 1 };
        default:
            return { exp: 20000, fragments: 625 };  // 默认一等成本
    }
}

function enhanceAmulet(tag) {
    const amulet = wuxingStates.find(amulet => amulet.tag === tag);

    if (!amulet) {
        showInfoBox("找不到指定的五行符。", null, null, 'red');
        return;
    }

    if (amulet.equipped && amulet.currentPetName !== currentPet.name) {
        showInfoBox(`该五行符已经被 ${amulet.currentPetName} 装备，需要至该宠物界面强化。`, null, null, 'red');
        return;
    }

    if (amulet.level >= MAX_LEVEL) {
        showInfoBox("已达强化等级上限，无法继续强化。", null, null, 'red');
        return;
    }

    // 确保五行符有rank属性
    ensureAmuletRank(amulet);

    // 获取对应rank的强化成本
    const { exp, fragments } = getRankCost(amulet.rank);

    if (wuxingFragments >= fragments && currentExp >= exp) {
        wuxingFragments -= fragments;
        currentExp -= exp;
        amulet.level += 1;

        // 按照rank进行相应的提升
        const rankMultiplier = [1, 0.8, 0.6, 0.4, 0.2][amulet.rank - 1];
        
        if (amulet.color === 'red') {
            if (!amulet.selectedBonus) {
                amulet.selectedBonus = Math.random() < 0.5 ? 'physicalAttack' : 'magicAttack';
            }
            amulet.drugBonus[amulet.selectedBonus] += Math.floor(300 * rankMultiplier);
        } else {
            const newDrugBonus = initializeDrugBonus(amulet.color, amulet.level, amulet.rank, amulet.selectedBonus);
            Object.keys(amulet.drugBonus).forEach(key => {
                amulet.drugBonus[key] = newDrugBonus[key];
            });
        }

        if (amulet.level % 5 === 0) {
            handleAdditionalValuesEnhancement(amulet);
        }

        showInfoBox(`消耗${exp}经验和${fragments}个五行碎片，成功强化至 ${amulet.level} 级。`, null, null, 'green');
        updateWuxingDisplay();
        displayAmuletDetails(amulet);
    } else {
        showInfoBox("强化所需资源不足。", null, null, 'red');
    }
}


// 处理额外值强化
function handleAdditionalValuesEnhancement(amulet) {
    const enhancementMultiplier = 1.1 + Math.random() * 0.2;

    // 获取已存在的属性集合，防止生成相同的属性条目
    const existingAttributes = new Set(
        amulet.additionalValues.map(value => value.attribute.replace('‰', ''))
    );

    if (amulet.additionalValues.length < 5) {
        const addNewValue = Math.random() < 0.3;

        if (addNewValue) {
            let newAdditionalValue;
            let attempts = 0;

            do {
                newAdditionalValue = generateAdditionalValues(amulet.color,amulet.rank).pop();
                attempts++;
            } while (existingAttributes.has(newAdditionalValue.attribute.replace('‰', '')) && attempts < 10);

            if (!existingAttributes.has(newAdditionalValue.attribute.replace('‰', ''))) {
                amulet.additionalValues.push(newAdditionalValue);
            } else {
                enhanceExistingAttribute(amulet, enhancementMultiplier);
            }
        } else {
            enhanceExistingAttribute(amulet, enhancementMultiplier);
        }
    } else {
        enhanceExistingAttribute(amulet, enhancementMultiplier);
    }
}

function enhanceExistingAttribute(amulet, enhancementMultiplier) {
    const randomIndex = Math.floor(Math.random() * amulet.additionalValues.length);
    const attribute = amulet.additionalValues[randomIndex].attribute;

    if (attribute === 'WXplayerCritRate' || attribute === 'WXplayerCritDamage') {
        // 增加暴击率或暴击伤害，增加值为5到7（整数百分比）
        const enhancementValue = Math.floor(Math.random() * (7 - 5 + 1)) + 5;
        amulet.additionalValues[randomIndex].value += enhancementValue;
    } else if (attribute.startsWith('‰')) {
        // 增加千分比属性，增加值为5‰到7‰
        const enhancementValue = Math.floor(Math.random() * (7 - 5 + 1)) + 5;
        amulet.additionalValues[randomIndex].value += enhancementValue;
    } else {
        // 增加具体数值属性，按当前值的1.1到1.3倍增加
        const enhancementValue = Math.floor(amulet.additionalValues[randomIndex].value * enhancementMultiplier);
        amulet.additionalValues[randomIndex].value += enhancementValue;
    }
}


function applyWuxingEffects() {
    const effects = {
        goldAmulet: 0,
        woodAmulet: 0,
        waterAmulet: 0,
        fireAmulet: 0,
        earthAmulet: 0,
    };

    // 计算每种五行符的效果指数
    wuxingStates.forEach(state => {
        if (state.equipped && state.currentPetName === currentPet.name) {
            const amuletType = state.tag.split('(')[0];
            if (effects.hasOwnProperty(amuletType)) {
                // 根据 rank 获取基础效果值
                let baseEffectValue = [5, 4, 3, 2, 1][state.rank - 1];

                // 根据等级计算额外的强度价值
                let levelBonus = 0;
                if (state.level > 20 && state.level <= 40) {
                    levelBonus = 1;
                } else if (state.level > 40 && state.level <= 60) {
                    levelBonus = 2;
                } else if (state.level > 60 && state.level <= 80) {
                    levelBonus = 3;
                } else if (state.level > 80 && state.level <= 100) {
                    levelBonus = 4;
                }

                // 总效果指数 = 基础效果值 + 等级增益
                effects[amuletType] += baseEffectValue + levelBonus;
            }
        }
    });

    // 根据效果指数确定效果强度
    const activeEffects = {};
    Object.keys(effects).forEach(type => {
        const effectValue = effects[type];
        if (effectValue >= 45) {
            activeEffects[type] = 9;  // 9档效果
        } else if (effectValue >= 40) {
            activeEffects[type] = 8;  // 8档效果
        } else if (effectValue >= 35) {
            activeEffects[type] = 7;  // 7档效果
        } else if (effectValue >= 30) {
            activeEffects[type] = 6;  // 6档效果
        } else if (effectValue >= 25) {
            activeEffects[type] = 5;  // 5档效果
        } else if (effectValue >= 20) {
            activeEffects[type] = 4;  // 4档效果
        } else if (effectValue >= 15) {
            activeEffects[type] = 3;  // 3档效果
        } else if (effectValue >= 10) {
            activeEffects[type] = 2;  // 2档效果
        } else if (effectValue >= 5) {
            activeEffects[type] = 1;  // 1档效果
        }
    });

    return activeEffects;  // 返回包含所有生效效果的对象
}



function getAmuletImageURL(name) {
    const imageMap = {
        // 金符
        'goldAmulet(red)': 'https://pic.imgdb.cn/item/66c5ada9d9c307b7e929df01.png',
        'goldAmulet(purple)': 'https://pic.imgdb.cn/item/66c5ada9d9c307b7e929dee6.png',
        'goldAmulet(orange)': 'https://pic.imgdb.cn/item/66c5ada9d9c307b7e929de8a.png',
        'goldAmulet(blue)': 'https://pic.imgdb.cn/item/66c5ada9d9c307b7e929decc.png',
        'goldAmulet(green)': 'https://pic.imgdb.cn/item/66c5ada9d9c307b7e929df18.png',

        // 木符
        'woodAmulet(red)': 'https://pic.imgdb.cn/item/66c5ada9d9c307b7e929df01.png',
        'woodAmulet(purple)': 'https://pic.imgdb.cn/item/66c5ada9d9c307b7e929dee6.png',
        'woodAmulet(orange)': 'https://pic.imgdb.cn/item/66c5ada9d9c307b7e929de8a.png',
        'woodAmulet(blue)': 'https://pic.imgdb.cn/item/66c5ada9d9c307b7e929decc.png',
        'woodAmulet(green)': 'https://pic.imgdb.cn/item/66c5ada9d9c307b7e929df18.png',

        // 水符
        'waterAmulet(red)': 'https://pic.imgdb.cn/item/66c5ada9d9c307b7e929df01.png',
        'waterAmulet(purple)': 'https://pic.imgdb.cn/item/66c5ada9d9c307b7e929dee6.png',
        'waterAmulet(orange)': 'https://pic.imgdb.cn/item/66c5ada9d9c307b7e929de8a.png',
        'waterAmulet(blue)': 'https://pic.imgdb.cn/item/66c5ada9d9c307b7e929decc.png',
        'waterAmulet(green)': 'https://pic.imgdb.cn/item/66c5ada9d9c307b7e929df18.png',

        // 火符
        'fireAmulet(red)': 'https://pic.imgdb.cn/item/66c5ada9d9c307b7e929df01.png',
        'fireAmulet(purple)': 'https://pic.imgdb.cn/item/66c5ada9d9c307b7e929dee6.png',
        'fireAmulet(orange)': 'https://pic.imgdb.cn/item/66c5ada9d9c307b7e929de8a.png',
        'fireAmulet(blue)': 'https://pic.imgdb.cn/item/66c5ada9d9c307b7e929decc.png',
        'fireAmulet(green)': 'https://pic.imgdb.cn/item/66c5ada9d9c307b7e929df18.png',

        // 土符
        'earthAmulet(red)': 'https://pic.imgdb.cn/item/66c5ada9d9c307b7e929df01.png',
        'earthAmulet(purple)': 'https://pic.imgdb.cn/item/66c5ada9d9c307b7e929dee6.png',
        'earthAmulet(orange)': 'https://pic.imgdb.cn/item/66c5ada9d9c307b7e929de8a.png',
        'earthAmulet(blue)': 'https://pic.imgdb.cn/item/66c5ada9d9c307b7e929decc.png',
        'earthAmulet(green)': 'https://pic.imgdb.cn/item/66c5ada9d9c307b7e929df18.png',
    };
    return imageMap[name];
}

function addWuxingFragments(amount) {
    const fragmentsElement = document.getElementById("wuxing-fragments");
    wuxingFragments += amount;
    fragmentsElement.innerText = wuxingFragments;
    showInfoBox(`你获得了${amount}张五行符碎片，当前分解碎片数量为${wuxingFragments}。`,null,null,'black');
}        

// lottery.js
document.getElementById('lotteryRuleButton').addEventListener('click', () => {
    const ruleContent = document.getElementById('ruleContent');
    ruleContent.innerHTML = `
        <h2>彩券规则</h2>
        <p>金子不够花，想要以小博大？</p>
        <ul>
            <li>玩家需选择6个数字，其中前5个数字为红球，第6个数字为蓝球。</li>
            <li>每注200文金子，最低投注1注。</li>
            <li>上次选号区会以红色显示当次中奖的数字。</li>
            <li>倒计时10秒实时开奖，离开彩券界面会暂停计时。</li>
            <li>当玩家选择的数字和开奖数字匹配时，即可获得相应奖金。</li>
            <li>详细中奖规则：</li>
            <ul>
                <li>5个红球全中且排列顺序一致：5锭金子</li>
                <li>5个红球全中：1锭500两金子</li>
                <li>4个红球且排列顺序一致：1锭金子</li>
                <li>4个红球全中：500两金子</li>
                <li>3个红球全中且排列顺序一致：100两金子</li>
                <li>3个红球全中：5两金子</li>
                <li>2个红球全中且排列顺序一致：10两金子</li>
                <li>2个红球全中：500文金子</li>
                <li>只中1个红球：100文金子</li>
            </ul>
            <li>蓝球规则：</li>
            <ul>
                <li>如果蓝球一致且红球中奖，当前奖金翻10倍。</li>
                <li>如果蓝球一致但红球未中奖，奖金为固定1两金子。</li>
            </ul>
            <li>本系统只用于游戏货币道具的随机获取，赌博是违法犯罪的行为，请勿铤而走险！</li>
        </ul>
    `;
    document.getElementById('lotteryRuleModal').style.display = 'block';
});

let lotteryPrizePool = "无上限奖池";
let lotteryBetCount = 0;
let lotteryBetAmount = 0;
let lotterySelectedNumbers = [];
let lastSelectedNumbers = [];
let canBet = true;
let pendingPrize = 0;
let hasPlacedBet = false;

function toggleLotteryDrawer() {
    const drawer = document.getElementById('lotteryDrawer');
    drawer.classList.toggle('open');
}

document.querySelector('.modal .close').addEventListener('click', () => {
    document.getElementById('lotteryRuleModal').style.display = 'none';
});

window.addEventListener('click', (event) => {
    if (event.target == document.getElementById('lotteryRuleModal')) {
        document.getElementById('lotteryRuleModal').style.display = 'none';
    }
});

function performLotteryDraw() {
    const { numbers: winningNumbers, blueBall: winningBlueBall } = generateLotteryWinningNumbers();
    document.getElementById('lotteryDrawResults').innerHTML = `开奖区: ${winningNumbers.join(', ')} <span style="color: blue;">${winningBlueBall}</span>`;
    
    if (hasPlacedBet) {
        const prize = calculateLotteryPrize(winningNumbers, winningBlueBall);
        if (prize > 0) {
            const originalPrice = prize;
            
    
            const luckyAmulet = jinnangItems.find(i => i.name === 'luckyAmulet');
            let bonusAmount = 0;
            if (luckyAmulet && luckyAmulet.quantity >= 2) {
                const bonusMultiplier = (luckyAmulet.quantity - 1) * 0.02;
                bonusAmount = Math.floor(prize * bonusMultiplier);
            }
            pendingPrize += (originalPrice + bonusAmount);
    
            showInfoBox(`恭喜你彩票中得${convertPrice(originalPrice)}金子，请速速领取！${bonusAmount > 0 ? `由于你拥有${luckyAmulet.quantity}张财运亨通，本次中奖奖金加码${convertPrice(bonusAmount)}金！` : ''}`);
        } else {
            showInfoBox('很遗憾，本轮投注并未中奖（小提示，战胜岩龙可得到洪荒至尊仙葫，开启仙葫后有概率获得增开中奖概率和奖金的道具“财运亨通”！道具越多，增益越大哦~）');
        }
    }
    
    highlightMatchingNumbers(winningNumbers, winningBlueBall);
    clearSelections();
    canBet = true;
    hasPlacedBet = false;
}

function generateLotteryWinningNumbers() {
    let numbers = [];
    
    const luckyAmulet = jinnangItems.find(i => i.name === 'luckyAmulet');
    const hasLuckyAmulet = luckyAmulet && luckyAmulet.quantity > 0;

    const availableSelectedNumbers = lotterySelectedNumbers.slice(0, 5);
    const luckyRate = Math.min(1, luckyAmulet.quantity * 0.015);
    console.log(luckyRate);

    if (hasLuckyAmulet && availableSelectedNumbers.length > 0 && Math.random() < luckyRate) {
        const randomIndex = Math.floor(Math.random() * availableSelectedNumbers.length);
        const selectedNumber = availableSelectedNumbers[randomIndex];
        numbers.push(selectedNumber);
    }

    while (numbers.length < 5) {
        const num = String(Math.floor(Math.random() * 36) + 1).padStart(2, '0');
        if (!numbers.includes(num)) {
            numbers.push(num);
        }
    }

    const blueBall = String(Math.floor(Math.random() * 36) + 1).padStart(2, '0');

    return { numbers, blueBall };
}

function calculateLotteryPrize(winningNumbers, winningBlueBall) {
    const prizeTable = {
        '5:exact': 5000000,
        '5:any': 500000,
        '4:exact': 1000000,
        '4:any': 150000,
        '3:exact': 100000,
        '3:any': 5000,
        '2:exact': 10000,
        '2:any': 500,
        '1:any': 100
    };

    const matchDetails = getMatchDetails(winningNumbers, lotterySelectedNumbers.slice(0, 5));
    const key = `${matchDetails.count}:${matchDetails.type}`;
    let prize = prizeTable[key] ? prizeTable[key] * lotteryBetCount : 0;

    const playerBlueBall = lotterySelectedNumbers[5];
    if (playerBlueBall === winningBlueBall) {
        if (prize > 0) {
            prize *= 10;
        } else {
            prize += 1000;
        }

        const resultAmountElement = document.getElementById('lotteryResultAmount');
        resultAmountElement.classList.add('highlight');
        setTimeout(() => {
            resultAmountElement.classList.remove('highlight');
        }, 1000);
    }

    document.getElementById('lotteryResultAmount').innerHTML = prize > 0 ? `奖金区: <span style="color: gold; font-weight: bold; text-shadow: 0 0 5px #6f391c;">${convertPrice(prize)}</span>` : '奖金区: 0';
    return prize;
}

function getMatchDetails(winningNumbers, selectedNumbers) {
    const matchedNumbers = selectedNumbers.filter(num => winningNumbers.includes(num));
    const matchCount = matchedNumbers.length;
    let matchType = 'any';

    if (matchCount === 5 && arraysEqual(selectedNumbers, winningNumbers)) {
        matchType = 'exact';
    } else if (matchCount === 4 && arraysEqual(matchedNumbers, winningNumbers.slice(0, 4))) {
        matchType = 'exact';
    } else if (matchCount === 3 && arraysEqual(matchedNumbers, winningNumbers.slice(0, 3))) {
        matchType = 'exact';
    } else if (matchCount === 2 && arraysEqual(matchedNumbers, winningNumbers.slice(0, 2))) {
        matchType = 'exact';
    }

    return { count: matchCount, type: matchType };
}

function arraysEqual(arr1, arr2) {
    if (arr1.length !== arr2.length) return false;
    for (let i = 0; i < arr1.length; i++) {
        if (arr1[i] !== arr2[i]) return false;
    }
    return true;
}

function highlightMatchingNumbers(winningNumbers, winningBlueBall) {
    const lastSelectedElement = document.getElementById('lastSelectedNumbers');
    lastSelectedElement.innerHTML = '上次选号: ';
    lastSelectedNumbers.forEach((num, index) => {
        const span = document.createElement('span');
        span.textContent = num;
        if (index === 5) {
            span.style.color = 'blue'; // 固定蓝色字体
        }
        if (winningNumbers.includes(num) || (index === 5 && num === winningBlueBall)) {
            span.style.fontWeight = 'bold';
            span.style.color = (index === 5) ? 'blue' : 'red';
            if (index === 5 && num === winningBlueBall) {
                // 添加放大和闪烁效果
                span.classList.add('highlight');
                setTimeout(() => {
                    span.classList.remove('highlight');
                }, 1000);
            }
        }
        lastSelectedElement.appendChild(span);
        lastSelectedElement.appendChild(document.createTextNode(' '));
    });
}

document.getElementById('lotteryIncreaseBet').addEventListener('click', () => {
    if (!canBet) {
        showInfoBox('请等待本次开奖！');
        return;
    }
    lotteryBetCount += 500;
    lotteryBetAmount += 100000;
    updateLotteryDisplay();
});

document.getElementById('lotteryIncreaseThousandBet').addEventListener('click', () => {
    if (!canBet) {
        showInfoBox('请等待本次开奖！');
        return;
    }
    lotteryBetCount += 1000; // 使用正确的语法增加100注
    lotteryBetAmount += 200000; // 对应增加2000
    updateLotteryDisplay();
});

document.getElementById('lotteryDecreaseBet').addEventListener('click', () => {
    if (!canBet) {
        showInfoBox('请等待本次开奖！');
        return;
    }
    if (lotteryBetCount > 1) {
        lotteryBetCount--;
        lotteryBetAmount -= 200;
        updateLotteryDisplay();
    }
});

document.getElementById('lotteryBetButton').addEventListener('click', () => {
    if (!canBet) {
        showInfoBox('请等待当前开奖结束');
        return;
    }

    if (lotterySelectedNumbers.length !== 6) {
        showInfoBox('请选择6个数字');
        return;
    }

    if (lotteryBetCount === 0) {
        showInfoBox('请加注后点击投注按钮进行投注！');
        return;
    }

    // 检查是否有 casinoCoverLetter 道具或足够的金钱
    const casinoCoverLetterItem = jinnangItems.find(i => i.name === 'casinoCoverLetter');
    const hasCasinoCoverLetter = casinoCoverLetterItem && casinoCoverLetterItem.quantity > 0;

    if (hasCasinoCoverLetter && lotteryBetCount <= 500) {
        // 使用 casinoCoverLetter 道具，减少数量
        useItem('casinoCoverLetter', 1);
        startLotterySimulation();
    } else if (goldAmount >= lotteryBetAmount) {
        // 如果没有道具，但有足够的金钱，扣除金钱
        goldAmount -= lotteryBetAmount;
        updateGoldDisplay(goldAmount);
        startLotterySimulation();
    } else {
        // 道具和金钱都不足时，提示余额不足
        showInfoBox('余额不足');
    }

    // 模拟彩票出号的函数
    function startLotterySimulation() {
        lastSelectedNumbers = [...lotterySelectedNumbers];
        canBet = false;
        document.getElementById('lastSelectedNumbers').innerHTML = `已选: ${lastSelectedNumbers.slice(0, 5).join(', ')} <span style="color: blue;">${lastSelectedNumbers[5]}</span>`;
        updateLotteryDisplay();
        hasPlacedBet = true;

        // 每0.2秒生成一组6个随机数，显示给玩家
        const generateRandomNumbers = () => {
            const randomNumSeries = Array.from({ length: 6 }, () => Math.floor(Math.random() * 36 + 1));  // 生成6个1到36之间的随机数
            document.getElementById('lotteryDrawResults').innerHTML = `开奖中: ${randomNumSeries.join(', ')}`;
        };

        const generatingNumber = setInterval(generateRandomNumbers, 100);  // 每0.1秒生成一次随机数
        const simulationDuration = Math.floor(Math.random() * 3000 + 2000);
        console.log(simulationDuration);

        // 随机时间后停止模拟生成，并执行实际开奖
        setTimeout(() => {
            clearInterval(generatingNumber);  // 停止生成随机数
            performLotteryDraw();  // 立即执行实际开奖
        }, simulationDuration);  // 2秒后开奖
    }
});

document.getElementById('lotteryClaimPrize').addEventListener('click', () => {
    if (pendingPrize === 0) {
        showInfoBox('请多多投注，目前没有奖金可以领取！');
    } else {
        const shouxufei = 1 - (Math.floor(Math.random() * 201 + 200) * 0.001);
        goldAmount += Math.round(pendingPrize * shouxufei);
        showInfoBox(`你领取了${convertPrice(Math.round(pendingPrize * shouxufei))}奖金！其中手续费为${convertPrice(Math.round(pendingPrize * (1 - shouxufei)))}`);
        updateGoldDisplay(goldAmount);
        pendingPrize = 0;
        document.getElementById('lotteryResultAmount').innerHTML = '奖金区: 0';
        updateLotteryDisplay();
    }
});

function updateLotteryDisplay() {
    document.getElementById('lotteryPrizePool').textContent = `奖金池: ${lotteryPrizePool}`;
    document.getElementById('lotteryBetCount').textContent = `投注数: ${lotteryBetCount}`;
    document.getElementById('lotteryBetAmount').textContent = `投注金: ${convertPrice(lotteryBetAmount)}`;
    document.getElementById('lotteryResultAmount').innerHTML = pendingPrize > 0 ? `奖金区: <span style="color: gold; font-weight: bold;">${convertPrice(pendingPrize)}</span>` : '奖金区: 0';
}

function clearSelections() {
    lotterySelectedNumbers = [];
    lotteryBetCount = 0;
    lotteryBetAmount = 0;
    document.getElementById('lotterySelectedNumbers').textContent = '已选: ';
    updateLotteryDisplay();
}
        
document.addEventListener('DOMContentLoaded', () => {
    const numberButtons = document.getElementById('lotteryNumberButtons');
    for (let i = 1; i <= 36; i++) {
        const button = document.createElement('button');
        button.textContent = String(i).padStart(2, '0');
        button.addEventListener('click', () => {
            if (lotterySelectedNumbers.length < 5 && !lotterySelectedNumbers.includes(button.textContent)) {
                lotterySelectedNumbers.push(button.textContent);
                document.getElementById('lotterySelectedNumbers').textContent = `已选: ${lotterySelectedNumbers.join(', ')}`;
            } else if (lotterySelectedNumbers.length === 5 && !lotterySelectedNumbers.includes(button.textContent)) {
                lotterySelectedNumbers.push(button.textContent);
                document.getElementById('lotterySelectedNumbers').innerHTML = `已选: ${lotterySelectedNumbers.slice(0, 5).join(', ')} <span style="color: blue;">${button.textContent}</span>`;
            }
        });
        numberButtons.appendChild(button);
    }

    const autoSelectButton = document.createElement('button');
    autoSelectButton.textContent = '系统选号';
    autoSelectButton.addEventListener('click', () => {
        if (!canBet) {
            showInfoBox('本轮您已经选号，请等待开奖！');
            return;
        }
        lotterySelectedNumbers = [];
        while (lotterySelectedNumbers.length < 5) {
            const num = String(Math.floor(Math.random() * 36) + 1).padStart(2, '0');
            if (!lotterySelectedNumbers.includes(num)) {
                lotterySelectedNumbers.push(num);
            }
        }
        const blueBall = String(Math.floor(Math.random() * 36) + 1).padStart(2, '0');
        lotterySelectedNumbers.push(blueBall);
        document.getElementById('lotterySelectedNumbers').innerHTML = `已选: ${lotterySelectedNumbers.slice(0, 5).join(', ')} <span style="color: blue;">${blueBall}</span>`;
        hasPlacedBet = false;
    });

    const lotteryFooter = document.querySelector('.lottery-footer');
    if (lotteryFooter) {
        lotteryFooter.appendChild(autoSelectButton);
    } else {
        console.error('.lottery-footer element not found');
    }
});

function updateDescriptionBox(message) {
    const descriptionBox = document.getElementById("description-box");
    descriptionBox.innerText = message;
}

let highGradePill = 50;
let transmutationPill = 20;
let rebornPill = 20;
let bingpoRebornPill = 10;
let qualityPill = 20;
let currentWisdom = 0;
let skillScore = 0;
let petWisdom = 0; 
        
const descriptions = [
    "在第五次金子培养后，你可以进行单次随机培养，每次花费4两888文金子",
    "当你每达到一个里程碑，你的称号都会有所提升，直到最终成为“魔兽之王”！",
    "宠物的各项技能效果在本模拟器中进行了简化，尤其是被动技能将只按一定比例增加各项属性值，增量随技能等级提高而提高。",
    "宠物的资质可以用“资质重生丹”洗练到更高的程度",
    "二级属性会随着悟性的提高得到百分比的增长",
    "合理的分配金子培养机会可以让你的宠物评分得到最大化！",
    "5爆400？极品宠物需要更多的耐心和更专业的培养方式，当然，对金子的消耗也会更大",
    "宠物的S技能和SS技能属于稀缺技能，很难通过洗练得来，商店直接购买或许是更好的方式",
    "宠物的成长上限会因为是否觉醒和是否飞升出现较大差异",
    "为了避免双击页面放大，页面内对双击速度作出了限制",
    "品质越高、成长率越高的宠物，资质所折算的属性就会越高，总体能力就会更强",
    "宠物变异时，资质会得到明显的提升，甚至超出原有的资质上限！",
    "目前共有三种还童丹，每种还童丹的功能各不同，详情可见“玩法”说明",
    "稀有道具只能通过宝箱开启获得。开启宝箱时，有概率同时出现1~3个奖品",
    "如果你需要删除某个技能，可以点击该技能进行操作"
];        

function updateDescriptionBox() {
    const descriptionBox = document.getElementById("description-box");
    const randomIndex = Math.floor(Math.random() * descriptions.length);
    descriptionBox.innerText = descriptions[randomIndex];
}

let evolutionLevel = 0;

function evolvePet() {
    // 定义不同进化阶段所需的道具。
    const evolutionItems = {
        0: 'shakingSoul',
        7: 'glowingSoul',
        13: 'activeSoul',
        19: 'jumpingSoul',
        25: 'radiantSoul'
    };

    let requiredItem; // 存储当前进化所需的道具。
    let successRate;  // 存储当前进化的成功率。
    let increaseValue = 0; // 存储进化成功时资质提升的数值。

    // 根据当前的进化等级设置所需的道具、成功率和资质提升数值。
    if (evolutionLevel < 7) {
        requiredItem = evolutionItems[0];
        successRate = 0.8;
        increaseValue = 200;
    } else if (evolutionLevel < 13) {
        requiredItem = evolutionItems[7];
        successRate = 0.7;
        increaseValue = 300;
    } else if (evolutionLevel < 19) {
        requiredItem = evolutionItems[13];
        successRate = 0.6;
        increaseValue = 400;
    } else if (evolutionLevel < 25) {
        requiredItem = evolutionItems[19];
        successRate = 0.5;
        increaseValue = 240;
    } else if (evolutionLevel < 30) {
        requiredItem = evolutionItems[25];
        successRate = 0.8;
        increaseValue = 160;
    } else {
        // 如果进化等级达到上限，提示用户并退出函数。
        showInfoBox("您的宠物已达进化等级上限！");
        return;
    }

    // 检查用户是否有足够的所需道具，如果没有，提示用户并退出函数。
    const item = jinnangItems.find(i => i.name === requiredItem);
    if (item.quantity < 1) {
        showInfoBox(`您的${item.displayName}不足！`);
        return;
    }

    // 随机生成一个数，如果小于成功率，则进化成功。
    if (Math.random() < successRate) {
        // 如果进化等级小于31，提升随机资质。
        if (evolutionLevel < 31) {
            increaseRandomQuality(increaseValue);
        }

        remainingPoints += 5; // 增加5个剩余点数
        // 减少用户的所需道具数量。
        item.quantity--;
        // 增加进化等级。
        evolutionLevel++;
        // 更新用户的道具数量显示。
        updateJinnangItems();
        // 更新进化等级的显示。
        document.getElementById("evolution-level").innerText = evolutionLevel;
        // 更新资质卡片和技能分数的显示。
        updateQualityCard();
        updateRemainingPointsDisplay();
        updateSkillScore();
        updateTitle();
    } else {
        // 如果进化失败，减少用户的所需道具数量，并提示用户进化失败。
        item.quantity--;
        showInfoBox("进化失败！");
        updateJinnangItems();
    }
}

function increaseRandomQuality(increaseValue) {
    // 获取当前宠物的资质
    const qualities = currentPet.qualities;
    // 定义需要提升的资质属性
    const attributes = ['endurance', 'intelligence', 'strength', 'agility', 'faith'];
    // 标记是否增加了资质值
    let addedValue = false;

    // 遍历每个资质属性
    for (let i = 0; i < attributes.length; i++) {
        const attribute = attributes[i];
        // 获取该属性的最大值
        const maxValue = qualities[attribute].max;

        // 如果当前资质值小于最大值
        if (qualities[attribute].current < maxValue) {
            // 增加当前资质值，但不超过最大值
            qualities[attribute].current = Math.min(qualities[attribute].current + increaseValue, maxValue);
            // 标记为已增加资质值
            addedValue = true;
            break;
        }
    }

    // 如果没有任何资质值被增加，说明所有资质都已达最大值
    if (!addedValue) {
        //console.log("所有资质已达最大值，进化不会带来任何资质值的提升");
    }

    // 更新资质卡片
    updateQualityCard();
}

let qualityPillCount = 0;
let consumedPillCount = 0;

// 更新资质显示以包含pillBonus，并更新qualityPillCount相关的UI
function updateQualityDisplayWithPillBonus() {
    const pillElements = [
        document.getElementById("quality-pill-1"),
        document.getElementById("quality-pill-2"),
        document.getElementById("quality-pill-3"),
        document.getElementById("quality-pill-4"),
        document.getElementById("quality-pill-5")
    ];

    const pillNumElements = [
        document.getElementById("quality-pill-num-1"),
        document.getElementById("quality-pill-num-2"),
        document.getElementById("quality-pill-num-3"),
        document.getElementById("quality-pill-num-4"),
        document.getElementById("quality-pill-num-5")
    ];

    const attributes = ['endurance', 'intelligence', 'strength', 'agility', 'faith'];

    const activePillSrc = "https://pic.imgdb.cn/item/66c9d327d9c307b7e9682c26.png";
    const inactivePillSrc = "https://pic.imgdb.cn/item/66caa91ad9c307b7e97841c0.png";

    if (qualityPillCount > 0) {
        // 显示 pillBonus 提示
        attributes.forEach(attribute => {
            const pillBonusElement = document.getElementById(`${attribute}-pill-bonus`);
            pillBonusElement.textContent = ` +1240`;
            pillBonusElement.style.color = "green";
            pillBonusElement.style.fontWeight = "bold";
        });

        // 更新 qualityPill 图标状态和数字显示，并绑定点击事件
        pillElements.forEach((pill, index) => {
            pill.style.opacity = "1";
            pill.style.cursor = "pointer";
            pill.src = activePillSrc;

            // 确保不会重复绑定点击事件
            pill.onclick = () => {
                showInfoBox(
                    "是否取下已经装备的仙丹？",
                    () => {
                        const pillBeforeTake = qualityPillCount;
                        qualityPillCount = Math.max(qualityPillCount - qualityPillCount, 0);
                        addItemToJinnang('qualityEnhancePill', pillBeforeTake);
                        updateQualityDisplayWithPillBonus();
                    },
                    null,
                    'red'
                );
            };
        });

        // 更新显示数量
        pillNumElements.forEach((pillNum) => {
            pillNum.style.position = "absolute";
            pillNum.style.top = "10px";
            pillNum.style.left = "95%";
            pillNum.style.transform = "translateX(-50%)";
            pillNum.style.color = "white";
            pillNum.style.fontSize = "16px";
            pillNum.style.fontWeight = "bold";
            pillNum.textContent = qualityPillCount;
        });
    } else {
        // 清除 pillBonus 提示
        attributes.forEach(attribute => {
            const pillBonusElement = document.getElementById(`${attribute}-pill-bonus`);
            pillBonusElement.textContent = "";
        });

        // 更新 qualityPill 图标状态，移除点击事件和数字显示
        pillElements.forEach(pill => {
            pill.style.opacity = "1";
            pill.style.cursor = "default";
            pill.src = inactivePillSrc;
            pill.onclick = null;
        });

        pillNumElements.forEach((pillNum) => {
            pillNum.textContent = "";
        });
    }

    updateQualityCard(); // 更新资质卡片显示
}



        
function useSupremeWisdomPill() {
    if (!currentPet || !currentPet.qualities) { // 添加检查
        console.warn("当前宠物未被正确初始化。");
        return;
    }
    
    const item = jinnangItems.find(i => i.name === 'supremeWisdomPill');
    if (!item || item.quantity <= 0) {
        showInfoBox("您没有举世无双悟性丹，无法将宠物瞬间提升到20悟性！");
        return;
    }
    
    if (currentWisdom >= 20) {
        showInfoBox("宠物的悟性已经达到20，无法再次提升！");
        return;
    }

    if (currentWisdom < 19) {
        showInfoBox("举世无双悟性丹是专用于19悟到20悟的关键突破道具，不适用于低于此悟性阶段的宠物");
        return;
    }

    // 消耗道具并更新宠物悟性
    item.quantity--;
    currentWisdom = 20; // 更新宠物的悟性
    updateJinnangItems();
    updateAttributePanel();
    document.getElementById("current-wisdom").innerText = currentWisdom;
    showInfoBox("您使用了举世无双悟性丹，宠物的悟性已提升至20！");
}

function increasePetLevel(levels) {
    if (petLevel >= petMaxLevel) {
        showInfoBox("宠物等级已达上限，无法继续升级！");
        return;
    }

    const oldLevel = petLevel;
    petLevel += levels;
    if (petLevel > petMaxLevel) petLevel = petMaxLevel; // 确保等级不超过上限

    const actualLevelsIncreased = petLevel - oldLevel;
    remainingPoints += actualLevelsIncreased * 2; // 每提升1级增加2个可分配点数

    // 每次等级提升时，消耗 qualityPillCount
    for (let i = 0; i < actualLevelsIncreased; i++) {
        if (qualityPillCount > 0) {
            qualityPillCount -= 1;
            consumedPillCount += 1; // 累加已消耗的 Pill Count
        }
    }
    
    updateQualityDisplayWithPillBonus(); // 更新界面显示

    updatePetLevel();
    updateAttributePanel();
    updateRemainingPointsDisplay();
    updateTitle();
}

let absorbCount = 0; // 跟踪连续使用次数

function directlyAbsorbExperience(amount) {
    gainExp(amount);
    showInfoBox(`你获得了${amount}点经验，当前为${petLevel}级，当前经验为${currentExp}/${maxExp}`, null, null, 'green');
}
        
async function absorbExperience() {
    absorbCount++;

    const advancedItem = jinnangItems.find(i => i.name === 'advancedExperienceBook');
    const normalItem = jinnangItems.find(i => i.name === 'normalExperienceBook');
    const totalValue = advancedItem.quantity + normalItem.quantity;

    if (absorbCount >= 5) {
        showInfoBox(`您已连续多次使用经验书，是否需要自动使用现有经验书？（当前经验书数量过多，全部使用大约需要${Math.round(totalValue / 100)}秒钟）`, async () => {
            // 玩家选择确认，进入自动使用异步循环
            await batchUseExperienceBooks(advancedItem, normalItem);
            showInfoBox(`自动吸收完成，当前为${petLevel}级，经验为${currentExp} / ${maxExp}`);
            absorbCount = 0; // 重置计数器
        }, () => {
            // 玩家选择取消，继续单次使用逻辑
            performSingleAbsorption(advancedItem, normalItem);
            absorbCount = 0; // 重置计数器
        });
    } else {
        performSingleAbsorption(advancedItem, normalItem);
    }
}

// 批量异步使用经验书
async function batchUseExperienceBooks(advancedItem, normalItem) {
    while ((advancedItem && advancedItem.quantity > 0) || (normalItem && normalItem.quantity > 0)) {
        if (petLevel >= petMaxLevel || petLevel === 180) {
            showInfoBox(`宠物等级已达上限，当前为${petLevel}级，经验为${currentExp} / ${maxExp}`);
            break;
        }

        if (advancedItem && advancedItem.quantity > 0) {
            useExperienceBook(advancedItem, 30000); // 使用高级经验书
        } else if (normalItem && normalItem.quantity > 0) {
            useExperienceBook(normalItem, 10000); // 使用普通经验书
        }

        // 每次使用完一批书后，异步等待一段时间
        await new Promise(resolve => setTimeout(resolve, 0)); // 暂停 100 毫秒，防止阻塞
    }
}

// 单次吸收逻辑
function performSingleAbsorption(advancedItem, normalItem) {
    if (petLevel >= petMaxLevel || petLevel === 180) {
        showInfoBox(`宠物等级已达上限，当前为${petLevel}级，经验为${currentExp} / ${maxExp}`);
        return;
    }

    if (advancedItem && advancedItem.quantity > 0) {
        useExperienceBook(advancedItem, 30000); // 使用高级经验书
    } else if (normalItem && normalItem.quantity > 0) {
        useExperienceBook(normalItem, 10000); // 使用普通经验书
    } else {
        showInfoBox("没有经验书可供使用！");
    }
}


function useExperienceBook(item, expAmount) {
    if (petLevel >= petMaxLevel) {
        showInfoBox("宠物等级已达上限，无法继续升级！");
        return;
    }

    item.quantity--;
    updateJinnangItems();
    
    // 调用 gainExp 函数处理经验值增长、升级逻辑
    gainExp(expAmount);
}

        
function updateAscensionStatus() {
    const ascensionStatusElement = document.getElementById('ascension-status');
    if (petAscended) {
        ascensionStatusElement.innerText = '已飞升';
        ascensionStatusElement.style.color = 'red';
    } else {
        ascensionStatusElement.innerText = '未飞升';
        ascensionStatusElement.style.color = ''; // 恢复默认颜色
    }
}

function ascend() {
    // Retrieve the current pet level and wisdom from the attribute panel
    let petLevel = parseInt(document.getElementById('pet-level').innerText);
    let petWisdom = parseInt(document.getElementById('current-wisdom').innerText);

    // Check if the pet has already ascended
    if (petAscended) {
        showInfoBox("您的宠物已经飞升！使用道具失败！");
        return;
    }

    // Check if the pet meets the level and wisdom requirements and if there is an ascension stone in the inventory
    const item = jinnangItems.find(i => i.name === 'ascensionStone');
    if (petLevel < 160 || petWisdom < 24 || !item || item.quantity <= 0) {
        showInfoBox("您的飞升石不够，且宠物飞升必须满足160级和24悟两个条件！(20级悟性之后，需要使用商店所售道具“特级悟性丹”才能继续提升悟性。)");
        return;
    }

    // Deduct one ascension stone from the inventory
    item.quantity--;
    updateJinnangItems();

    // Update pet's max level and ascension status
    petMaxLevel = 181;
    petAscended = true;
    updateAscensionStatus();

    showInfoBox("恭喜大侠的爱宠飞升成功！等级上限开放至180级，同时开放飞升之术功能！");
    
}

let selectedTreasure = null;
let experienceTreasureOpenCount = 0; // 定义经验宝箱打开次数的全局变量

function toggleTreasureDrawer() {
    const drawer = document.getElementById('treasure-drawer');
    const info = document.getElementById('treasure-info');
    drawer.classList.toggle('open');
    info.classList.toggle('open');
}

function selectTreasure(type) {
    selectedTreasure = type;
    updateTreasureDescription(type);
}

function updateTreasureDescription(type) {
    let description;
    if (type === '经验宝箱') {
        const cost = getTreasureCost('经验宝箱');
        description = `充满智慧的宝箱，单次开启将花费${convertPrice(cost)}金子。有概率获得宠物升级的经验书和飞升之石。`;
    } else {
        switch (type) {
            case '奇馈宝箱':
                description = "充满奇异道具的宝箱，单次开启花费1两金子，您可能获得各种用于培养宠物的道具，还可能获得宠物转职、宠物日常生活的关键道具！";
                break;
            case '灵魂宝箱':
                description = "神秘莫测的宝箱，单次开启花费2两金子，您可能获得宠物进化所需的各种灵魂！";
                break;
            case '武神仙葫':
                description = "上古武神的战利品，单次开启花费6两800文金子，您可能获得庆典蛋糕、精灵升级的相关道具、心鉴之石、施毒之术等提升战斗能力的法宝！";
                break;
            case '五行仙葫':
                description = "至尊五行仙葫，每次开启16两800文金，您可能获得珍贵的五行符和分解符材料！";
                break;
            case '至尊仙葫':
                description = "价值连城的宝箱，单次开启花费18两800文金子，您可能获得召唤灵符，修为灵丹、举世无双悟性丹，飞升之石，仙人醍醐等超稀有道具！";
                break;
        }
    }
    document.getElementById('treasure-description').innerText = description;
}

let rewards = []; // 确保 rewards 在全局作用域内

function collectTreasure() {
    if (rewards.length === 0) {
        return;
    }

    const rewardActions = {
        '普通经验书': 'normalExperienceBook',
        '高级经验书': 'advancedExperienceBook',
        '水晶红富士': () => generateItemToJinnang('redApple', '水晶红富士', 'https://pic.imgdb.cn/item/66ced7d4d9c307b7e9650a3b.png', price = 100, quantity = 1, description = '美味的苹果'),
        '浓情费罗列': () => generateItemToJinnang('chocolate', '浓情费罗列', 'https://pic.imgdb.cn/item/66d2d3ead9c307b7e9180338.png', price = 100, quantity = 1, description = '一口下去，丝滑的巧克力和爆浆甜心在你的口腔中交织，回味无穷'),
        '迷人的花束': () => generateItemToJinnang('fancyFlower', '迷人的花束', 'https://pic.imgdb.cn/item/66cfe544d9c307b7e978e72b.png', price = 100, quantity = 1, description = '迷人的花束，赠给爱人以芬芳'),
        '达摩不倒翁': () => generateItemToJinnang('damoTumbler', '达摩不倒翁', 'https://pic.imgdb.cn/item/66cfee41d9c307b7e983f6f7.png', price = 100, quantity = 1, description = '达摩不倒翁，按压越用力，弹起来越容易撞到头'),
        '飞升之石': 'ascensionStone',
        '举世无双悟性丹': 'supremeWisdomPill',
        '无限宝石': 'infiniteGem',
        '清心酿': 'ignoranceWater',
        '闪耀之灵': 'radiantSoul',
        '颤抖之灵': 'shakingSoul',
        '发光之灵': 'glowingSoul',
        '召唤灵符': 'summonCharmPaper',
        '活跃之灵': 'activeSoul',
        '跳动之灵': 'jumpingSoul',
        '醒悟丹': 'awakenPill',
        '离魂石': 'seperateStone',
        '凝魄石': 'coagulateStone',
        '精灵精炼石': 'spiritRefreshStone',
        '精灵觉醒石': 'spiritAwakenStone',
        '施毒之术': 'poisonSkillBook',
        '毒粉': 'poisonPowder',
        '毒粉礼包（3）': () => addItemToJinnang('poisonPowder', 3),
        '遗失的洛书·密钥': 'lostBook',
        '残页的河图·灵匙': 'fragmentedMap',
        '定空的灵石·图章': 'nirvanaGem',
        '心鉴之石': 'heartStone',
        '天地灵气': 'earthlyEnergy',
        '天地灵气礼包（10）': () => addItemToJinnang('earthlyEnergy', 10),
        '特级悟性丹': 'tejiWisdomPill',
        '特级悟性丹礼包（10）': () => addItemToJinnang('tejiWisdomPill', 10),
        '修为灵丹*3（蓝）': () => addItemToJinnang('cultivationPill200', 3),
        '修为灵丹*3（橙）': () => addItemToJinnang('cultivationPill500', 3),
        '小金袋（88两）':'tinyBag',
        '金玉满堂福袋': 'redEnvelope',
        '富贵宝石袋': 'wealthyGemBag',
        '修为灵丹（蓝）': 'cultivationPill200',
        '修为灵丹（橙）': 'cultivationPill500',
        '庆典蛋糕': 'celebrationCake',
        '琼浆玉露': 'spiritWine',
        '仙人醍醐': 'ultraSkillBoomer',
        '高级经验书*6': () => addItemToJinnang('advancedExperienceBook', 6),
        '资质仙丹礼包': 'qualityEnhancePillPKG',
        '灵异秘卷': 'mutationScroll',
        '装满的药材箱': 'drugBox',
        '华贵的药材箱': 'fancyDrugBox',
        '锻造工具': 'forgeTool',
        '橙色武装原料': 'orangeArmComponents',
        '蓝色武装原料': 'blueArmComponents',
        '宠物资质仙丹': 'qualityEnhancePill',
        '高级神兽丹': 'advancedSkillPill',
        '经商积分卡': 'merchantPointsCard',
        '重生露': () => generateItemToJinnang('resetTrainingCount', '重生露', 'https://pic.imgdb.cn/item/66ddb0cdd9c307b7e961ad69.png', price = 3600, quantity = 1, description = '传说由世外高人炼制的秘药，使用后可以将培养次数重置为0，要注意培养到达最大值后将无法带来任何收益！'),
        '魔魂封印卡': 'bossSealCard',
        '一等分解符': 'firstFragments',
        '二等分解符': 'secondFragments',
        '三等分解符': 'thirdFragments',
        '四等分解符': 'fourthFragments',
        '五等分解符': 'fifthFragments',
        '金符（红）': () => addAmuletToManager('goldAmulet', 'red', 1),
        '金符（紫）': () => addAmuletToManager('goldAmulet', 'purple', 1),
        '金符（橙）': () => addAmuletToManager('goldAmulet', 'orange', 1),
        '金符（蓝）': () => addAmuletToManager('goldAmulet', 'blue', 1),
        '金符（绿）': () => addAmuletToManager('goldAmulet', 'green', 1),
        '木符（红）': () => addAmuletToManager('woodAmulet', 'red', 1),
        '木符（紫）': () => addAmuletToManager('woodAmulet', 'purple', 1),
        '木符（橙）': () => addAmuletToManager('woodAmulet', 'orange', 1),
        '木符（蓝）': () => addAmuletToManager('woodAmulet', 'blue', 1),
        '木符（绿）': () => addAmuletToManager('woodAmulet', 'green', 1),
        '水符（红）': () => addAmuletToManager('waterAmulet', 'red', 1),
        '水符（紫）': () => addAmuletToManager('waterAmulet', 'purple', 1),
        '水符（橙）': () => addAmuletToManager('waterAmulet', 'orange', 1),
        '水符（蓝）': () => addAmuletToManager('waterAmulet', 'blue', 1),
        '水符（绿）': () => addAmuletToManager('waterAmulet', 'green', 1),
        '火符（红）': () => addAmuletToManager('fireAmulet', 'red', 1),
        '火符（紫）': () => addAmuletToManager('fireAmulet', 'purple', 1),
        '火符（橙）': () => addAmuletToManager('fireAmulet', 'orange', 1),
        '火符（蓝）': () => addAmuletToManager('fireAmulet', 'blue', 1),
        '火符（绿）': () => addAmuletToManager('fireAmulet', 'green', 1),
        '土符（红）': () => addAmuletToManager('earthAmulet', 'red', 1),
        '土符（紫）': () => addAmuletToManager('earthAmulet', 'purple', 1),
        '土符（橙）': () => addAmuletToManager('earthAmulet', 'orange', 1),
        '土符（蓝）': () => addAmuletToManager('earthAmulet', 'blue', 1),
        '土符（绿）': () => addAmuletToManager('earthAmulet', 'green', 1)
    };

    for (const reward of rewards) {
        const action = rewardActions[reward.name];
        if (typeof action === 'function') {
            action(); // 处理有特殊逻辑的奖励，如礼包
        } else if (action) {
            addItemToJinnang(action); // 处理一般奖励
        } else {
            addItemToTopBar(reward); // 默认处理其他情况
        }
    }

    // 清空奖品
    rewards = [];
    document.getElementById('treasure-reward').innerHTML = "";

    // 更新经验宝箱描述
    if (selectedTreasure === '经验宝箱') {
        updateTreasureDescription('经验宝箱');
    }
}

// 修改 openTreasure 函数，使其兼容开启十次的逻辑
function openTreasure(times = 1) {
    if (!selectedTreasure) {
        showInfoBox("请先选择一个宝箱！");
        return;
    }

    if (times === 10) {
        const treasureMapItem = jinnangItems.find(i => i.name === 'treasureMap');
        if (treasureMapItem && treasureMapItem.quantity > 0) {
            // 使用一个藏宝图
            useItem('treasureMap', 1);
            showEffect('generalEffect', 'https://pic.imgdb.cn/item/66a34156d9c307b7e94568b1.gif');
        } else {
            const cost = getTreasureCost(selectedTreasure) * times;
            if (goldAmount < cost) {
                showInfoBox("金子不足！");
                return;
            }

            goldAmount -= cost;
            updateGoldDisplay(goldAmount);
        }
    } else {
        const cost = getTreasureCost(selectedTreasure) * times;
        if (goldAmount < cost) {
            showInfoBox("金子不足！");
            return;
        }

        goldAmount -= cost;
        updateGoldDisplay(goldAmount);
    }

    // 自动收集上次未取出的奖品
    collectTreasure();

    if (selectedTreasure === '经验宝箱') {
        experienceTreasureOpenCount += times; // 增加经验宝箱开启次数
    }

    let totalRewards = [];
    for (let t = 0; t < times; t++) {
        // 根据概率随机生成 1~3 个奖品
        let rewardCount;
        const random = Math.random() * 100;
        if (random < 95) {
            rewardCount = 1;
        } else if (random < 99) {
            rewardCount = 2;
        } else {
            rewardCount = 3;
        }

        let rewards = [];
        for (let i = 0; i < rewardCount; i++) {
            rewards.push(getRandomReward(selectedTreasure));
        }

        totalRewards = totalRewards.concat(rewards);
    }

    rewards = totalRewards; // 更新全局 rewards

    // 更新页面显示多个奖品
    let rewardHTML = '';
    for (const reward of totalRewards) {
        rewardHTML += `<div><img src="${reward.url}" alt="${reward.name}"><div>${reward.name}</div></div>`;
    }
    setTimeout( () => {
        document.getElementById('treasure-reward').innerHTML = rewardHTML;
        showEffect('generalEffect', 'https://pic.imgdb.cn/item/66a34156d9c307b7e94568b1.gif');
    },100);
}

function openTenthTreasure() {
    openTreasure(10);
}

function getTreasureCost(type) {
    if (type === '经验宝箱') {
        if (experienceTreasureOpenCount < 20) {
            return 100;
        } else if (experienceTreasureOpenCount < 40) {
            return 200 + (experienceTreasureOpenCount * 5);
        } else if (experienceTreasureOpenCount < 60) {
            return 400 + (experienceTreasureOpenCount * 10);
        } else if (experienceTreasureOpenCount < 80) {
            return 800 + (experienceTreasureOpenCount * 15);
        } else {
            return 2400;
        }
    }

    switch (type) {
        case '奇馈宝箱':
            return 1000;
        case '灵魂宝箱':
            return 2000;
        case '武神仙葫':
            return 6800;
        case '五行仙葫':
            return 16800;
        case '至尊仙葫':
            return 18800;
    }
}

function getRandomReward(type) {
    const rewards = {
        '经验宝箱': [
            { name: '普通经验书', url: 'https://pic.imgdb.cn/item/6656e734d9c307b7e9088e9b.png', chance: 90 },
            { name: '高级经验书', url: 'https://pic.imgdb.cn/item/6656e734d9c307b7e9088e7b.png', chance: 9.95 },
            { name: '飞升之石', url: 'https://pic.imgdb.cn/item/6656e734d9c307b7e9088e6d.png', chance: 0.05 }
        ],
        '奇馈宝箱': [
            { name: '神兽还童丹', url: 'https://pic.imgdb.cn/item/6654a944d9c307b7e9ca6423.png', chance: 10 },
            { name: '高级悟性丹', url: 'https://pic.imgdb.cn/item/66541c01d9c307b7e9208aea.png', chance: 20 },
            { name: '水晶红富士', url: 'https://pic.imgdb.cn/item/66ced7d4d9c307b7e9650a3b.png', chance: 4 },
            { name: '浓情费罗列', url: 'https://pic.imgdb.cn/item/66d2d3ead9c307b7e9180338.png', chance: 3 },
            { name: '迷人的花束', url: 'https://pic.imgdb.cn/item/66cfe544d9c307b7e978e72b.png', chance: 3 },
            { name: '达摩不倒翁', url: 'https://pic.imgdb.cn/item/66cfee41d9c307b7e983f6f7.png', chance: 3 },
            { name: '冰魄还童丹', url: 'https://pic.imgdb.cn/item/665ef0855e6d1bfa055800f4.png', chance: 10 },
            { name: '还童金丹', url: 'https://pic.imgdb.cn/item/6655a92ad9c307b7e9c04265.png', chance: 10 },
            { name: '资质重生丹', url: 'https://pic.imgdb.cn/item/6654a944d9c307b7e9ca63f5.png', chance: 10 },
            { name: '万化灵丹', url: 'https://pic.imgdb.cn/item/66541c01d9c307b7e9208add.png', chance: 20 },
            { name: '无限宝石', url: 'https://pic.imgdb.cn/item/668841dcd9c307b7e9d78092.png', chance: 1.2 },
            { name: '清心酿', url: 'https://pic.imgdb.cn/item/66884213d9c307b7e9d7bad3.png', chance: 1.2 },
            { name: '特级悟性丹', url: 'https://pic.imgdb.cn/item/665de3fd5e6d1bfa05564912.png', chance: 3 },
            { name: '宠物资质仙丹', url: 'https://pic.imgdb.cn/item/66c9d327d9c307b7e9682c26.png', chance: 0.5 },
            { name: '特级悟性丹礼包（10）', url: 'https://pic.imgdb.cn/item/665de3fd5e6d1bfa05564912.png', chance: 0.9 },
            { name: '灵异秘卷', url: 'https://pic.imgdb.cn/item/669754f0d9c307b7e9bfec4f.png', chance: 0.1 },
            { name: '装满的药材箱', url: 'https://pic.imgdb.cn/item/66c60e7cd9c307b7e9ad57e3.png', chance: 0.1 }
        ],
        '灵魂宝箱': [
            { name: '颤抖之灵', url: 'https://pic.imgdb.cn/item/6656e821d9c307b7e90988b2.png', chance: 30 },
            { name: '发光之灵', url: 'https://pic.imgdb.cn/item/6656e81dd9c307b7e909844a.png', chance: 30 },
            { name: '活跃之灵', url: 'https://pic.imgdb.cn/item/6656e81dd9c307b7e90984b7.png', chance: 20 },
            { name: '跳动之灵', url: 'https://pic.imgdb.cn/item/6656e81dd9c307b7e909843e.png', chance: 10 },
            { name: '闪耀之灵', url: 'https://pic.imgdb.cn/item/6656e81dd9c307b7e9098478.png', chance: 10 }
        ],
        '武神仙葫': [
            { name: '心鉴之石', url: 'https://pic.imgdb.cn/item/666ab20bd9c307b7e9630192.png', chance: 10 },
            { name: '精灵精炼石', url: 'https://pic.imgdb.cn/item/6669666cd9c307b7e991c04a.png', chance: 15 },
            { name: '精灵觉醒石', url: 'https://pic.imgdb.cn/item/6669666cd9c307b7e991bf78.png', chance: 15 },
            { name: '施毒之术', url: 'https://pic.imgdb.cn/item/666c23ccd9c307b7e9eb864b.png', chance: 0.5 },
            { name: '毒粉', url: 'https://pic.imgdb.cn/item/666c2428d9c307b7e9ec3327.png', chance: 5.5 },
            { name: '魔魂封印卡', url: 'https://pic.imgdb.cn/item/66cdc955d9c307b7e92c1f56.png', chance: 5 },
            { name: '毒粉礼包（3）', url: 'https://pic.imgdb.cn/item/666c2428d9c307b7e9ec3327.png', chance: 1 },
            { name: '遗失的洛书·密钥', url: 'https://pic.imgdb.cn/item/669a7ce3d9c307b7e9450f04.png', chance: 1 },
            { name: '定空的灵石·图章', url: 'https://pic.imgdb.cn/item/66a48e2cd9c307b7e9649085.png', chance: 1 },
            { name: '残页的河图·灵匙', url: 'https://pic.imgdb.cn/item/669a7ce2d9c307b7e9450ef4.png', chance: 1 },
            { name: '天地灵气', url: 'https://pic.imgdb.cn/item/666ab20bd9c307b7e96301f6.png', chance: 44 },
            { name: '天地灵气礼包（10）', url: 'https://pic.imgdb.cn/item/666ab20bd9c307b7e96301f6.png', chance: 1 }
        ],
        '五行仙葫': [
            { name: '一等分解符', url: 'https://pic.imgdb.cn/item/66cdc7ead9c307b7e92af497.png', chance: 1 },
            { name: '二等分解符', url: 'https://pic.imgdb.cn/item/66cdc7ead9c307b7e92af488.png', chance: 15 },
            { name: '三等分解符', url: 'https://pic.imgdb.cn/item/66cdc7e9d9c307b7e92af447.png', chance: 32 },
            { name: '四等分解符', url: 'https://pic.imgdb.cn/item/66cdc7e9d9c307b7e92af438.png', chance: 12 },
            { name: '五等分解符', url: 'https://pic.imgdb.cn/item/66cdc7e9d9c307b7e92af3de.png', chance: 15 },
            { name: '金符（红）', url: 'https://pic.imgdb.cn/item/66c5ada9d9c307b7e929df01.png', chance: 1 },
            { name: '金符（紫）', url: 'https://pic.imgdb.cn/item/66c5ada9d9c307b7e929dee6.png', chance: 1 },
            { name: '金符（橙）', url: 'https://pic.imgdb.cn/item/66c5ada9d9c307b7e929de8a.png', chance: 1 },
            { name: '金符（蓝）', url: 'https://pic.imgdb.cn/item/66c5ada9d9c307b7e929decc.png', chance: 1 },
            { name: '金符（绿）', url: 'https://pic.imgdb.cn/item/66c5ada9d9c307b7e929df18.png', chance: 1 },
            { name: '木符（红）', url: 'https://pic.imgdb.cn/item/66c5ada9d9c307b7e929df01.png', chance: 1 },
            { name: '木符（紫）', url: 'https://pic.imgdb.cn/item/66c5ada9d9c307b7e929dee6.png', chance: 1 },
            { name: '木符（橙）', url: 'https://pic.imgdb.cn/item/66c5ada9d9c307b7e929de8a.png', chance: 1 },
            { name: '木符（蓝）', url: 'https://pic.imgdb.cn/item/66c5ada9d9c307b7e929decc.png', chance: 1 },
            { name: '木符（绿）', url: 'https://pic.imgdb.cn/item/66c5ada9d9c307b7e929df18.png', chance: 1 },
            { name: '水符（红）', url: 'https://pic.imgdb.cn/item/66c5ada9d9c307b7e929df01.png', chance: 1 },
            { name: '水符（紫）', url: 'https://pic.imgdb.cn/item/66c5ada9d9c307b7e929dee6.png', chance: 1 },
            { name: '水符（橙）', url: 'https://pic.imgdb.cn/item/66c5ada9d9c307b7e929de8a.png', chance: 1 },
            { name: '水符（蓝）', url: 'https://pic.imgdb.cn/item/66c5ada9d9c307b7e929decc.png', chance: 1 },
            { name: '水符（绿）', url: 'https://pic.imgdb.cn/item/66c5ada9d9c307b7e929df18.png', chance: 1 },
            { name: '火符（红）', url: 'https://pic.imgdb.cn/item/66c5ada9d9c307b7e929df01.png', chance: 1 },
            { name: '火符（紫）', url: 'https://pic.imgdb.cn/item/66c5ada9d9c307b7e929dee6.png', chance: 1 },
            { name: '火符（橙）', url: 'https://pic.imgdb.cn/item/66c5ada9d9c307b7e929de8a.png', chance: 1 },
            { name: '火符（蓝）', url: 'https://pic.imgdb.cn/item/66c5ada9d9c307b7e929decc.png', chance: 1 },
            { name: '火符（绿）', url: 'https://pic.imgdb.cn/item/66c5ada9d9c307b7e929df18.png', chance: 1 },
            { name: '土符（红）', url: 'https://pic.imgdb.cn/item/66c5ada9d9c307b7e929df01.png', chance: 1 },
            { name: '土符（紫）', url: 'https://pic.imgdb.cn/item/66c5ada9d9c307b7e929dee6.png', chance: 1 },
            { name: '土符（橙）', url: 'https://pic.imgdb.cn/item/66c5ada9d9c307b7e929de8a.png', chance: 1 },
            { name: '土符（蓝）', url: 'https://pic.imgdb.cn/item/66c5ada9d9c307b7e929decc.png', chance: 1 },
            { name: '土符（绿）', url: 'https://pic.imgdb.cn/item/66c5ada9d9c307b7e929df18.png', chance: 1 }
        ],
        '至尊仙葫': [
            { name: '飞升之石', url: 'https://pic.imgdb.cn/item/6656e734d9c307b7e9088e6d.png', chance: 6 },
            { name: '灵异金丹', url: 'https://pic.imgdb.cn/item/66556068d9c307b7e9681672.png', chance: 9.5 },
            { name: '橙色武装原料', url: 'https://pic.imgdb.cn/item/66d8732dd9c307b7e96449c0.png', chance: 0.1 },
            { name: '蓝色武装原料', url: 'https://pic.imgdb.cn/item/66d8732dd9c307b7e964497d.png', chance: 0.3 },
            { name: '举世无双悟性丹', url: 'https://pic.imgdb.cn/item/665ef0845e6d1bfa055800c7.png', chance: 12 },
            { name: '召唤灵符', url: 'https://pic.imgdb.cn/item/66d9f78ed9c307b7e94c80c4.png', chance: 10 },
            { name: '重生露', url: 'https://pic.imgdb.cn/item/66ddb0cdd9c307b7e961ad69.png', chance: 1},
            { name: '醒悟丹', url: 'https://pic.imgdb.cn/item/665ef5a15e6d1bfa05609a45.png', chance: 8 },
            { name: '离魂石', url: 'https://pic.imgdb.cn/item/665ef5a15e6d1bfa056099a3.png', chance: 20 },
            { name: '凝魄石', url: 'https://pic.imgdb.cn/item/665ef5a15e6d1bfa05609a0f.png', chance: 9 },           
            { name: '仙人醍醐', url: 'https://pic.imgdb.cn/item/6662eda05e6d1bfa0530b827.png', chance: 5.5 },
            { name: '修为灵丹（蓝）', url: 'https://pic.imgdb.cn/item/66c369f2d9c307b7e9650429.png', chance: 5 },
            { name: '锻造工具', url: 'https://pic.imgdb.cn/item/66d8732dd9c307b7e9644942.png', chance: 1 },
            { name: '经商积分卡', url: 'https://pic.imgdb.cn/item/66e6a031d9c307b7e97c84c7.png', chance: 0.1 },
            { name: '修为灵丹（橙）', url: 'https://pic.imgdb.cn/item/66c369f2d9c307b7e965043b.png', chance: 2 },
            { name: '修为灵丹*3（蓝）', url: 'https://pic.imgdb.cn/item/66c369f2d9c307b7e9650429.png', chance: 0.2 },
            { name: '修为灵丹*3（橙）', url: 'https://pic.imgdb.cn/item/66c369f2d9c307b7e965043b.png', chance: 0.1 },
            { name: '金玉满堂福袋', url: 'https://pic.imgdb.cn/item/66c369f1d9c307b7e96503f4.png', chance: 0.5 },
            { name: '富贵宝石袋', url: 'https://pic.imgdb.cn/item/66d9f0a8d9c307b7e9415285.png', chance: 3 },
            { name: '高级经验书*6', url: 'https://pic.imgdb.cn/item/6656e734d9c307b7e9088e7b.png', chance: 6 },
            { name: '华贵的药材箱', url: 'https://pic.imgdb.cn/item/6656e598d9c307b7e906ca29.png', chance: 0.1 },
            { name: '资质仙丹礼包', url: 'https://pic.imgdb.cn/item/66cc940fd9c307b7e9cb77b1.png', chance: 0.5 },
            { name: '小金袋（88两）', url: 'https://pic.imgdb.cn/item/66c369f2d9c307b7e9650410.png', chance: 0.1 }
        ]
    };
    return selectReward(rewards[type]);
}

function selectReward(rewardList) {
    const random = Math.random() * 100;
    let cumulativeChance = 0;
    for (const reward of rewardList) {
        cumulativeChance += reward.chance;
        if (random <= cumulativeChance) {
            return reward;
        }
    }
}
            
// 新增全局变量
let jinnangCapacity = 2000;
let jinnangItems = [
    { name: 'hailMonsterPill', displayName: '聚灵丹', url: 'https://pic.imgdb.cn/item/66c238b6d9c307b7e9e76c9a.png', price: 50, quantity: 5, description: '可在战斗界面开启自动战斗功能，每次开启消耗一个' },
    { name: 'hailMonsterAmulet', displayName: '唤妖符', url: 'https://pic.imgdb.cn/item/66c238b6d9c307b7e9e76c26.png', price: 50, quantity: 5, description: '可战斗界面跳过10轮，轮次越高，敌人越强大，谨慎使用' },
    { name: 'blessGift', displayName: '新手福袋', url: 'https://pic.imgdb.cn/item/6656a1b6d9c307b7e9baa881.png', price: 1, quantity: 0, description: '新手时期的嘉奖，要合理分配哦' },
    { name: 'universalHeart', displayName: '宇宙之心', url: 'https://pic.imgdb.cn/item/66e19cbed9c307b7e93c7e01.png', price: 20000, quantity: 0, description: '相传这种物质外形可千变万化，宠物靠近后能感受到其中的灵蕴，是修炼更高级技能的绝佳媒介' },
    { name: 'lifeGem', displayName: '宠物寿命晶石', url: 'https://pic.imgdb.cn/item/66e726d8d9c307b7e9405457.png', price: 1000, quantity: 0, description: '储存5000点宠物寿命精华，使用后可为当前宠物恢复5000点寿命值' },
    { name: 'backToOne', displayName: '穿越时空套餐', url: 'https://pic.imgdb.cn/item/6656a1b6d9c307b7e9baa881.png', price: 100, quantity: 0, description: '打开立即获得100组无限宝石和清心酿，回到第一轮战斗' },
    { name: 'normalExperienceBook', displayName: '普通经验书', url: 'https://pic.imgdb.cn/item/6656e734d9c307b7e9088e9b.png', price: 50, quantity: 0, description: '无名者的经验，使用后获得10000经验值' },
    { name: 'tejiWisdomPill', displayName: '特级悟性丹', url: 'https://pic.imgdb.cn/item/665de3fd5e6d1bfa05564912.png', price: 50, quantity: 0, description: '特制的悟性丹，用于21~25悟性的提升' },
    { name: 'advancedExperienceBook', displayName: '高级经验书', url: 'https://pic.imgdb.cn/item/6656e734d9c307b7e9088e7b.png', price: 150, quantity: 0, description: '伟人的经验，使用后获得30000经验值' },
    { name: 'awakenPill', displayName: '醒悟丹', url: 'https://pic.imgdb.cn/item/665ef5a15e6d1bfa05609a45.png', price: 500, quantity: 0, description: '宠物觉醒时必不可少的玄妙丹药' },
    { name: 'coagulateStone', displayName: '凝魄石', url: 'https://pic.imgdb.cn/item/665ef5a15e6d1bfa05609a0f.png', price: 300, quantity: 0, description: '开启宠物幻化的必要道具' },
    { name: 'seperateStone', displayName: '离魂石', url: 'https://pic.imgdb.cn/item/665ef5a15e6d1bfa056099a3.png', price: 200, quantity: 0, description: '用于提升宠物的幻化等级，以带来更稳定的成长率' },
    { name: 'ascensionStone', displayName: '飞升之石', url: 'https://pic.imgdb.cn/item/6656e734d9c307b7e9088e6d.png', price: 600, quantity: 0, description: '使你的宠物醍醐灌顶般超越自我' },
    { name: 'supremeWisdomPill', displayName: '举世无双悟性丹', url: 'https://pic.imgdb.cn/item/665ef0845e6d1bfa055800c7.png', price: 200, quantity: 0, description: '举世无双，灵石点智，宠物悟性到19的关键阶段时可以一举提升至20' },
    { name: 'summonCharmPaper', displayName: '召唤灵符', url: 'https://pic.imgdb.cn/item/66d9f78ed9c307b7e94c80c4.png', price: 300, quantity: 0, description: '神奇的符咒，可以召唤出你喜欢的宠物（可直接使用）' },
    { name: 'spiritRefreshStone', displayName: '精灵精炼石', url: 'https://pic.imgdb.cn/item/6669666cd9c307b7e991c04a.png', price: 50, quantity: 0, description: '提升精灵等级，但也可能会失败' },
    { name: 'spiritAwakenStone', displayName: '精灵觉醒石', url: 'https://pic.imgdb.cn/item/6669666cd9c307b7e991bf78.png', price: 80, quantity: 0, description: '刷新精灵的增幅百分比' },
    { name: 'heartStone', displayName: '心鉴之石', url: 'https://pic.imgdb.cn/item/666ab20bd9c307b7e9630192.png', price: 150, quantity: 0, description: '开启、刷新宠物飞升之术的必要道具' },
    { name: 'poisonSkillBook', displayName: '施毒之术', url: 'https://pic.imgdb.cn/item/666c23ccd9c307b7e9eb864b.png', price: 1500, quantity: 0, description: '失传已久的施毒秘法，掌握后可释放烈性毒药，多余的施毒之术可兑换毒粉' },
    { name: 'poisonPowder', displayName: '毒粉', url: 'https://pic.imgdb.cn/item/666c2428d9c307b7e9ec3327.png', price: 50, quantity: 0, description: '配合毒粉，可使施毒成功率大大提升' },
    { name: 'earthlyEnergy', displayName: '天地灵气', url: 'https://pic.imgdb.cn/item/666ab20bd9c307b7e96301f6.png', price: 30, quantity: 0, description: '荟萃日月之精华，提升飞升之术等级的必需之物' },
    { name: 'magicPetAmulet', displayName: '灵兽符文', url: 'https://pic.imgdb.cn/item/669754f1d9c307b7e9bfec8f.png', price: 80000, quantity: 0, description: '充满灵力的符文，据传其中封印了上古神兽的灵魂，可以直接开启一个图鉴位' },
    { name: 'infiniteGem', displayName: '无限宝石', url: 'https://pic.imgdb.cn/item/668841dcd9c307b7e9d78092.png', price: 2000, quantity: 0, description: '宇宙间最玄妙的宝石，宠物使用后可受到更高阶的指引' },
    { name: 'ignoranceWater', displayName: '清心酿', url: 'https://pic.imgdb.cn/item/66884213d9c307b7e9d7bad3.png', price: 300, quantity: 0, description: '大音希声，大象无形。真正的修炼不在那点滴提升，而在那瞬悟瞬空' },
    { name: 'blueArmComponents', displayName: '蓝色武装原料', url: 'https://pic.imgdb.cn/item/66d8732dd9c307b7e964497d.png', price: 200, quantity: 0, description: '相对劣质的武装材料，不能直接打造，集齐25个可以合成一个橙色武装原料' },
    { name: 'orangeArmComponents', displayName: '橙色武装原料', url: 'https://pic.imgdb.cn/item/66d8732dd9c307b7e96449c0.png', price: 1000, quantity: 0, description: '上好的武装材料，收集25个后用锻造工具可以打造用于解锁任意宠物武装的原始武装，你也可以点击使用分解为25个蓝色武装原料' },
    { name: 'forgeTool', displayName: '锻造工具', url: 'https://pic.imgdb.cn/item/66d8732dd9c307b7e9644942.png', price: 1000, quantity: 0, description: '当你的橙色武装原料足够25个时，你可以使用这把工具打造一个原始宠物武装' },
    { name: 'radiantSoul', displayName: '闪耀之灵', url: 'https://pic.imgdb.cn/item/6656e81dd9c307b7e9098478.png', price: 500, quantity: 0, description: '用于宠物25~30进化' },
    { name: 'shakingSoul', displayName: '颤抖之灵', url: 'https://pic.imgdb.cn/item/6656e821d9c307b7e90988b2.png', price: 50, quantity: 0, description: '用于宠物1~6进化' },
    { name: 'glowingSoul', displayName: '发光之灵', url: 'https://pic.imgdb.cn/item/6656e81dd9c307b7e909844a.png', price: 150, quantity: 0, description: '用于宠物7~12进化' },
    { name: 'activeSoul', displayName: '活跃之灵', url: 'https://pic.imgdb.cn/item/6656e81dd9c307b7e90984b7.png', price: 200, quantity: 0, description: '用于宠物13~18进化' },
    { name: 'jumpingSoul', displayName: '跳动之灵', url: 'https://pic.imgdb.cn/item/6656e81dd9c307b7e909843e.png', price: 300, quantity: 0, description: '用于宠物19~24进化' },
    { name: 'ultraSkillBoomer', displayName: '仙人醍醐', url: 'https://pic.imgdb.cn/item/6662eda05e6d1bfa0530b827.png', price: 50000, quantity: 0, description: '万化灵丹的终极形态，可令宠物刷新出10~12个技能' },
    { name: 'mutationScroll', displayName: '灵异秘卷', url: 'https://pic.imgdb.cn/item/669754f0d9c307b7e9bfec4f.png', price: 50000, quantity: 0, description: '上古卷轴，记录着上古神兽的培养之道，使用后可培养出拥有资质更强大的宠物' },
    { name: 'lostBook', displayName: '遗失的洛书·密钥', url: 'https://pic.imgdb.cn/item/669a7ce3d9c307b7e9450f04.png', price: 30000, quantity: 0, description: '解锁神器「遗失的洛书」的关键道具' },
    { name: 'fragmentedMap', displayName: '残页的河图·灵匙', url: 'https://pic.imgdb.cn/item/669a7ce2d9c307b7e9450ef4.png', price: 30000, quantity: 0, description: '解锁神器「残页的河图」的关键「钥匙」' },
    { name: 'nirvanaGem', displayName: '定空的灵石·图章', url: 'https://pic.imgdb.cn/item/66a48e2cd9c307b7e9649085.png', price: 30000, quantity: 0, description: '解锁神器「定空的灵石」的关键「钥匙」' },
    { name: 'treasureMap', displayName: '藏宝图', url: 'https://pic.imgdb.cn/item/669ce78ad9c307b7e9aa9369.png', price: 100, quantity: 0, description: '指引财富的藏宝图，凭此道具可进行一次免费十连任意宝箱' },
    { name: 'casinoCoverLetter', displayName: '赌场介绍信', url: 'https://pic.imgdb.cn/item/669ce78ad9c307b7e9aa9342.png', price: 100, quantity: 0, description: '千金散尽还复来，凭此介绍信可免费投注一次500倍以内的彩券' },
    { name: 'liguolin', displayName: '李国麟的爱', url: 'https://pic.imgdb.cn/item/66be21a1d9c307b7e9cc9c98.jpg', price: 0, quantity: 0, description: '如梦幻泡影，如红莲火焰，如从未拥有，如从未失去（可直接使用）' },
    { name: 'redEnvelope', displayName: '金玉满堂福袋', url: 'https://pic.imgdb.cn/item/66c369f1d9c307b7e96503f4.png', price: 0, quantity: 0, description: '直接使用，珠光宝气的袋子，开启后随机获得666文~188两金子' },
    { name: 'tinyBag', displayName: '小金袋（88两）', url: 'https://pic.imgdb.cn/item/66c369f2d9c307b7e9650410.png', price: 88, quantity: 0, description: '直接使用，装满金币的袋子，能卖个不错的价钱' },
    { name: 'cultivationPill200', displayName: '修为灵丹（蓝）', url: 'https://pic.imgdb.cn/item/66c369f2d9c307b7e9650429.png', price: 1000, quantity: 0, description: '直接使用，当前宠物使用后可以提升200点修炼修为' },
    { name: 'cultivationPill500', displayName: '修为灵丹（橙）', url: 'https://pic.imgdb.cn/item/66c369f2d9c307b7e965043b.png', price: 3000, quantity: 0, description: '直接使用，高级修为灵丹，当前宠物使用后可提升500点修炼修为' },
    { name: 'eightyDiscountCard', displayName: '八折礼遇卡', url: 'https://pic.imgdb.cn/item/66c369f2d9c307b7e9650452.png', price: 0, quantity: 0, description: '拥有此道具时，商店购买商品可以享受8折优惠，请勿出售哦' },
    { name: 'luckyAmulet', displayName: '财运亨通', url: 'https://pic.imgdb.cn/item/66cc940dd9c307b7e9cb758d.png', price: 0, quantity: 0, description: '拥有此道具时，你会在赌场大发神威' },
    { name: 'celebrationCake', displayName: '庆典蛋糕', url: 'https://pic.imgdb.cn/item/66c369f2d9c307b7e965046c.png', price: 20, quantity: 0, description: '直接使用，安佳动物奶油/不含香精色素/低卡零糖蛋糕，使用后永久增加随机属性5点' },
    { name: 'advancedSkillPill', displayName: '高级神兽丹', url: 'https://pic.imgdb.cn/item/665c41e6d9c307b7e9590b5a.png', price: 6000, quantity: 0, description: '直接使用，当宠物技能不足上限时，可用于查缺补漏宠物技能，十分珍贵' },
    { name: 'drugBox', displayName: '装满的药材箱', url: 'https://pic.imgdb.cn/item/66c60e7cd9c307b7e9ad57e3.png', price: 3000, quantity: 0, description: '直接使用，装饰精美的箱子，靠近会有一股药材的气息扑面而来。使用可获得随机10~20株药材' },
    { name: 'fancyDrugBox', displayName: '华贵的药材箱', url: 'https://pic.imgdb.cn/item/6656e598d9c307b7e906ca29.png', price: 6000, quantity: 0, description: '直接使用，华丽贵气的箱子，似乎藏着上好的补品。使用可获得随机20~40株药材' },
    { name: 'fragmentsPackage', displayName: '分解符礼包', url: 'https://pic.imgdb.cn/item/66c60e7cd9c307b7e9ad57d3.png', price: 200, quantity: 0, description: '直接使用，打开可获得100个五行符分解碎片' },
    { name: 'firstFragments', displayName: '一等分解符', url: 'https://pic.imgdb.cn/item/66cdc7ead9c307b7e92af497.png', price: 1000, quantity: 0, description: '直接使用，获得625枚五行符分解碎片。分解碎片可用于强化五行符获得更强力的属性加成' },
    { name: 'secondFragments', displayName: '二等分解符', url: 'https://pic.imgdb.cn/item/66cdc7ead9c307b7e92af488.png', price: 600, quantity: 0, description: '直接使用，获得125枚五行符分解碎片。分解碎片可用于强化五行符获得更强力的属性加成' },
    { name: 'thirdFragments', displayName: '三等分解符', url: 'https://pic.imgdb.cn/item/66cdc7e9d9c307b7e92af447.png', price: 300, quantity: 0, description: '直接使用，获得25枚五行符分解碎片。分解碎片可用于强化五行符获得更强力的属性加成' },
    { name: 'fourthFragments', displayName: '四等分解符', url: 'https://pic.imgdb.cn/item/66cdc7e9d9c307b7e92af438.png', price: 200, quantity: 0, description: '直接使用，获得5枚五行符分解碎片。分解碎片可用于强化五行符获得更强力的属性加成' },
    { name: 'fifthFragments', displayName: '五等分解符', url: 'https://pic.imgdb.cn/item/66cdc7e9d9c307b7e92af3de.png', price: 100, quantity: 0, description: '直接使用，获得1枚五行符分解碎片。分解碎片可用于强化五行符获得更强力的属性加成' },
    { name: 'goldAmuletPackage', displayName: '金符组合锦囊', url: 'https://pic.imgdb.cn/item/66cc940fd9c307b7e9cb77b1.png', price: 1, quantity: 0, description: '直接使用，打开后获得一整套金符。金符可以使你在反弹来自敌人的伤害，装备数量越多，反弹比例越高' },
    { name: 'spiritWine', displayName: '琼浆玉露', url: 'https://pic.imgdb.cn/item/66cc9401d9c307b7e9cb6a4b.png', price: 100, quantity: 0, description: '直接使用，精灵最爱喝的口味。可以直接提升2级精灵等级哦（友情提示，建议精灵到达100级后使用，此道具可突破精灵成长上限至120级）' },
    { name: 'towerGrass', displayName: '融会贯通', url: 'https://pic.imgdb.cn/item/66c9d328d9c307b7e9682dbc.png', price: 50, quantity: 0, description: '在宠物专精面板点击升级可以自动使用，宠物的专精等级到达100级后，可以直接提升1级专精等级' },
    { name: 'angelWings', displayName: '天使之翼', url: 'https://pic.imgdb.cn/item/66cc9406d9c307b7e9cb6f5c.png', price: 500, quantity: 0, description: '在打工界面使用。可以给正在打工的宠物玩耍，永久提升TA的打工速度，同一宠物最多使用10次哦' },
    { name: 'bossSealCard', displayName: '魔魂封印卡', url: 'https://pic.imgdb.cn/item/66cdc955d9c307b7e92c1f56.png', price: 0, quantity: 0, description: '使用后可召唤出各类强大的封印魔魂，挑战成功可能获得各类奖励' },
    { name: 'battleWithTree', displayName: '树桩魔魂封印', url: 'https://pic.imgdb.cn/item/66cc9408d9c307b7e9cb7162.png', price: 0, quantity: 0, description: '使用可召唤出树桩测试战力' },
    { name: 'practiceEnemyPlus', displayName: '高级树桩封印卡', url: 'https://pic.imgdb.cn/item/66cc9408d9c307b7e9cb7162.png', price: 0, quantity: 0, description: '使用可召唤出高级树桩测试战力，会复活，打到爽' },
    { name: 'battleWithAncientEvil', displayName: '战神魔魂封印', url: 'https://pic.imgdb.cn/item/66cc940ad9c307b7e9cb72e8.png', price: 20, quantity: 0, description: '使用可召唤出强大的太古魔魂，战胜后可获得不菲的奖励' },
    { name: 'battleWithExpEnemy', displayName: '永夜大帝封印', url: 'https://pic.imgdb.cn/item/66cc940ad9c307b7e9cb72e8.png', price: 20, quantity: 0, description: '使用可召唤出强大的永夜大帝，战胜后可获得不菲的经验值' },
    { name: 'stoneDragon', displayName: '岩龙封印', url: 'https://pic.imgdb.cn/item/66cc940ad9c307b7e9cb72e8.png', price: 20, quantity: 0, description: '使用可召唤出强大的岩龙，战胜后可获得一个洪荒至尊仙葫' },
    { name: 'qiongQi', displayName: '穷奇封印', url: 'https://pic.imgdb.cn/item/66cc940ad9c307b7e9cb72e8.png', price: 20, quantity: 0, description: '使用可召唤出强大的穷奇，战胜后可获得一个富贵宝石袋' },
    { name: 'noWorkBoss', displayName: '無班之魂封印', url: 'https://pic.imgdb.cn/item/66cc940ad9c307b7e9cb72e8.png', price: 20, quantity: 0, description: '使用可召唤出不想上班的無班之魂，战胜后可获得培养更强壮的牛马的秘诀' },
    { name: 'universalCrystal', displayName: '宇宙之晶', url: 'https://pic.imgdb.cn/item/66cc940cd9c307b7e9cb752e.png', price: 1000, quantity: 0, description: '凝聚宇宙间万物生长之力的晶石，集齐一定数量后有概率提升1级宠物的技能等级（技能等级在24级~27级时才能使用）' },
    { name: 'universalKernel', displayName: '宇宙精华', url: 'https://pic.imgdb.cn/item/66cc940cd9c307b7e9cb74d1.png', price: 2000, quantity: 0, description: '凝聚宇宙间万物生长之力的晶石，集齐一定数量后有概率提升1级宠物的技能等级（技能等级在28级~29级时才能使用）' },
    { name: 'qualityEnhancePill', displayName: '宠物资质仙丹', url: 'https://pic.imgdb.cn/item/66c9d327d9c307b7e9682c26.png', price: 50, quantity: 0, description: '直接使用，额外为当前宠物增加全套1240点资质（一步到位！），宠物升级时可以获得更多的属性加成' },
    { name: 'qualityEnhancePillPKG', displayName: '资质仙丹礼包', url: 'https://pic.imgdb.cn/item/66cc940fd9c307b7e9cb77b1.png', price: 50, quantity: 0, description: '直接使用，获得全套宠物资质仙丹*5' },
    { name: 'resetJinnang', displayName: '背包重置卡', url: 'https://pic.imgdb.cn/item/66c369f2d9c307b7e9650452.png', price: 0, quantity: 1, description: '背包出错时使用（如出现undefined等），重置所有道具，使用后需要刷新页面' },
    { name: 'enlargeCapacityCard', displayName: '背包扩容卡', url: 'https://pic.imgdb.cn/item/66c369f2d9c307b7e9650452.png', price: 1000, quantity: 1, description: '使用后开启1000背包容量' },
    { name: 'baiYinPKG', displayName: '白银VIP包裹', url: 'https://pic.imgdb.cn/item/66d5e69ed9c307b7e966f716.png', price: 100, quantity: 0, description: '使用后可得到30张试炼之地召唤卡' },
    { name: 'baiYinCard', displayName: '试炼之地召唤卡', url: 'https://pic.imgdb.cn/item/66d5e7b7d9c307b7e9685315.png', price: 0, quantity: 0, description: '使用后可以召唤白银之地的怪物，每次战斗胜利会获得不菲的经验值' },
    { name: 'attentionValue', displayName: '集中值（4点）', url: 'https://pic.imgdb.cn/item/66d1c3a5d9c307b7e9ddf3fa.png', price: 200, quantity: 0, description: '直接使用，给当前宠物增加4点集中值' },
    { name: 'learningValueBook', displayName: '灵兽悟道书', url: 'https://pic.imgdb.cn/item/66d1c3a4d9c307b7e9ddf33e.png', price: 3000, quantity: 0, description: '直接使用，给当前宠物提供20000点学习度，学习度可用于提升技能加成' },
    { name: 'resetAdvancementPill', displayName: '灵兽清心丹', url: 'https://pic.imgdb.cn/item/66d1c416d9c307b7e9de526a.png', price: 500, quantity: 0, description: '在领悟面板进行重置使用，加成重置后，会返还所有的技能点' },
    { name: 'qiongmeiCard', displayName: 'そら召唤卡', url: 'https://pic.imgdb.cn/item/66d698c2d9c307b7e91c47f3.png', price: 5000, quantity: 0, description: '可以召唤隐藏角色：春日野穹（注：无论你有多少张召唤卡，都只能拥有一个同类宠物）' },
    { name: 'wealthyGemBag', displayName: '富贵宝石袋', url: 'https://pic.imgdb.cn/item/66d9f0a8d9c307b7e9415285.png', price: 1000, quantity: 0, description: '珠光宝气的锦囊，富贵人家常见的款式，打开获得随机宝石' },
    { name: 'inlayAmulet', displayName: '宝石镶嵌符', url: 'https://pic.imgdb.cn/item/66d9e814d9c307b7e93afc79.png', price: 2450, quantity: 0, description: '镶嵌宝石时使用可以保证100%成功' },
    { name: 'removeAmulet', displayName: '宝石摘除符', url: 'https://pic.imgdb.cn/item/66dc001bd9c307b7e9b8bb5c.png', price: 300, quantity: 0, description: '用于摘除任意等级的宝石' },
    { name: 'punchHoleTool', displayName: '任意打孔器', url: 'https://pic.imgdb.cn/item/66d9e814d9c307b7e93afc61.png', price: 500, quantity: 0, description: '可以直接给装备开启一个可供镶嵌的孔位' },
    { name: 'starGem', displayName: '升级宝石（极品）', url: 'https://pic.imgdb.cn/item/66d9e814d9c307b7e93afc86.png', price: 10, quantity: 0, description: '用于给武装升星，武装星级在0~7级时，有概率提升1级，失败则退1级' },
    { name: 'starGemPKG', displayName: '升级宝石礼包（极品）', url: 'https://pic.imgdb.cn/item/66dab9c1d9c307b7e921b767.png', price: 180, quantity: 0, description: '打开后可以获得200升级宝石（极品）' },
    { name: 'starGemPlus', displayName: '升级宝石（神品）', url: 'https://pic.imgdb.cn/item/66dc0442d9c307b7e9bc6534.png', price: 20, quantity: 0, description: '用于给武装升星，武装星级在7~13级时，有概率提升1级，失败则退2级' },
    { name: 'starGemPlusPKG', displayName: '升级宝石礼包（神品）', url: 'https://pic.imgdb.cn/item/66dab9eed9c307b7e92290c5.png', price: 300, quantity: 0, description: '打开后可以获得200升级宝石（神品）' },
    { name: 'refreshGemSlot', displayName: '宝石洗孔符', url: 'https://pic.imgdb.cn/item/666d688ed9c307b7e903cdfd.png', price: 100, quantity: 0, description: '武装界面刷新孔位的颜色，有可能回到与上次同样的颜色哦' },
    { name: 'mergeAmulet', displayName: '低级宝石合成符', url: 'https://pic.imgdb.cn/item/66db2caed9c307b7e9c66c55.png', price: 1000, quantity: 0, description: '上古时代流传的符文，用于合成1~3级宝石' },
    { name: 'mergeAmuletPlus', displayName: '高级宝石合成符', url: 'https://pic.imgdb.cn/item/66dbff82d9c307b7e9b75a35.png', price: 2000, quantity: 0, description: '上古时代流传的符文，用于合成4~6级宝石' },
    { name: 'gemLuckyBag', displayName: '宝石袋盲盒', url: 'https://pic.imgdb.cn/item/66db2daed9c307b7e9c7508a.png', price: 50, quantity: 0, description: '打开后获得一颗随机的一级宝石' },
    { name: 'advancedSkillBook', displayName: '高级天赋技能', url: 'https://pic.imgdb.cn/item/66e1a8bdd9c307b7e950654b.png', price: 12500, quantity: 0, description: '破旧的书卷记录着上古的语言，点击破译后可获得一本所有宠物都可学习的极稀有SSS技能' },
    { name: 'lizhuamengji', displayName: '利爪猛击天赋书', url: 'https://pic.imgdb.cn/item/66e142acd9c307b7e9acc8b9.png', price: 10000, quantity: 0, description: '教会你的宠物释放高级天赋技能：利爪猛击' },
    { name: 'huoyanchongji', displayName: '火焰冲击天赋书', url: 'https://pic.imgdb.cn/item/66e142acd9c307b7e9acc8b9.png', price: 10000, quantity: 0, description: '教会你的宠物释放高级天赋技能：火焰冲击' },
    { name: 'tiankongshouhu', displayName: '天空守护天赋书', url: 'https://pic.imgdb.cn/item/66e142acd9c307b7e9acc8b9.png', price: 10000, quantity: 0, description: '教会你的宠物释放高级天赋技能：天空守护' },
    { name: 'suohou', displayName: '锁喉天赋书', url: 'https://pic.imgdb.cn/item/66e142acd9c307b7e9acc8b9.png', price: 10000, quantity: 0, description: '教会你的宠物释放高级天赋技能：锁喉' },
    { name: 'jiyanggangqi', displayName: '极阳罡气天赋书', url: 'https://pic.imgdb.cn/item/66e142acd9c307b7e9acc8b9.png', price: 10000, quantity: 0, description: '教会你的宠物释放高级天赋技能：极阳罡气' },
    { name: 'beimingshengong', displayName: '北冥神功天赋书', url: 'https://pic.imgdb.cn/item/66e142acd9c307b7e9acc8b9.png', price: 10000, quantity: 0, description: '教会你的宠物释放高级天赋技能：北冥神功' },
    { name: 'tianshenzhufu', displayName: '天神祝福天赋书', url: 'https://pic.imgdb.cn/item/66e142acd9c307b7e9acc8b9.png', price: 10000, quantity: 0, description: '教会你的宠物释放高级天赋技能：天神祝福' },
    { name: 'tianwanghuwei', displayName: '天王护卫天赋书', url: 'https://pic.imgdb.cn/item/66e142acd9c307b7e9acc8b9.png', price: 10000, quantity: 0, description: '教会你的宠物释放高级天赋技能：天王护卫' },
    { name: 'xingzhizhufu', displayName: '星之祝福天赋书', url: 'https://pic.imgdb.cn/item/66e142acd9c307b7e9acc8b9.png', price: 10000, quantity: 0, description: '教会你的宠物释放高级天赋技能：星之祝福' },
    { name: 'zhenbaoshenquan', displayName: '震爆神拳天赋书', url: 'https://pic.imgdb.cn/item/66e142acd9c307b7e9acc8b9.png', price: 10000, quantity: 0, description: '教会你的宠物释放高级天赋技能：震爆神拳' },
    { name: 'hongHuang', displayName: '洪荒至尊仙葫', url: 'https://pic.imgdb.cn/item/66d0b3f3d9c307b7e995a14c.png', price: 8000, quantity: 0, description: '上古传说中的仙葫，流传久远，极其稀有，打开可获得随机珍稀道具' },
    { name: 'rareEventBooster', displayName: '八方来财', url: 'https://pic.imgdb.cn/item/66e683eed9c307b7e9551be4.png', price: 2000, quantity: 0, description: '【经商法宝】（仅在商店-倒买倒卖中使用）应用此法宝时，你在经商时遇到市场特殊事件的概率提升50%' },
    { name: 'fitnessPowder', displayName: '强身散', url: 'https://pic.imgdb.cn/item/66e683eed9c307b7e9551bdf.png', price: 2000, quantity: 0, description: '【经商法宝】（仅在商店-倒买倒卖中使用）应用此法宝时，每周精力下降的幅度减少30%' },
    { name: 'heroToken', displayName: '英雄令', url: 'https://pic.imgdb.cn/item/66e6841ad9c307b7e9554384.png', price: 2000, quantity: 0, description: '【经商法宝】（仅在商店-倒买倒卖中使用）作为对英雄的尊敬，应用此法宝时，每周店租下降30%' },
    { name: 'extensionCharter', displayName: '续租契', url: 'https://pic.imgdb.cn/item/66e68b4ed9c307b7e962b841.png', price: 2000, quantity: 0, description: '【经商法宝】（仅在商店-倒买倒卖中使用）应用此法宝时，经商时间可特许延长一个月（4周）' },
    { name: 'treasureWood', displayName: '珍宝案', url: 'https://pic.imgdb.cn/item/66e68b4dd9c307b7e962b7ca.png', price: 2000, quantity: 0, description: '【经商法宝】（仅在商店-倒买倒卖中使用）此法宝应用后可降低20%未变现的资产缩水幅度' },
    { name: 'investmentCharter', displayName: '特许招商令', url: 'https://pic.imgdb.cn/item/66e68c8ed9c307b7e963c42d.png', price: 2000, quantity: 0, description: '【经商法宝】（仅在商店-倒买倒卖中使用）应用此法宝后，可额外增加一次投资次数' },
    { name: 'merchantPointsCard', displayName: '经商积分卡', url: 'https://pic.imgdb.cn/item/66e6a031d9c307b7e97c84c7.png', price: 1000, quantity: 5, description: '打开后可以获得2000点经商积分。经商积分用于在商店-倒买倒卖购买经商法宝，增加你的资产运作能力' },
    { name: 'wealthOfNations', displayName: '国富论', url: 'https://pic.imgdb.cn/item/66e7aabfd9c307b7e9ce4e8c.png', price: 1000, quantity: 0, description: '【经商法宝】（仅在商店-倒买倒卖中使用）亚当斯密作为经济学大师，认为管理者应当一定程度干涉市场，本年度市场每周商品数量下限将提升1' },
    { name: 'revokeSand', displayName: '唤神砂', url: 'https://pic.imgdb.cn/item/66e7aabfd9c307b7e9ce4e59.png', price: 1000, quantity: 0, description: '【经商法宝】（仅在商店-倒买倒卖中使用）在精力不支时，仍然能够支持你进行一次买卖行为，生效后自动失效' },
    { name: 'qianKunBag', displayName: '乾坤袋', url: 'https://pic.imgdb.cn/item/66e82554d9c307b7e96cab02.png', price: 1000, quantity: 0, description: '【经商法宝】（仅在商店-倒买倒卖中使用）即使市面并没有仓库内的货物，仍能够以进货价出售一次，生效后自动失效' },
    { name: 'doubleLuck', displayName: '双喜临门', url: 'https://pic.imgdb.cn/item/66e8256dd9c307b7e96cc570.png', price: 1000, quantity: 0, description: '【经商法宝】（仅在商店-倒买倒卖中使用）经商结束时，积分结算翻倍' },
    { name: 'zibenyunzuo', displayName: '资本运作', url: 'https://pic.imgdb.cn/item/66e99553f21886ccc0502e94.png', price: 1000, quantity: 0, description: '【经商法宝】（仅在商店-倒买倒卖中使用）通过高效的资本运作，投资股票后减少一周收益等待时间' },
    { name: 'kaimanzhizhao', displayName: '开曼岛执照', url: 'https://pic.imgdb.cn/item/66e994f2f21886ccc04fd099.png', price: 1000, quantity: 0, description: '【经商法宝】（仅在商店-倒买倒卖中使用）将企业注册在避税天堂，交易股票时税费减少50%' },
    { name: 'jiazuxintuo', displayName: '家族信托', url: 'https://pic.imgdb.cn/item/66ed48f0f21886ccc007aa0b.png', price: 1000, quantity: 0, description: '【经商法宝】（仅在商店-倒买倒卖中使用）来自权贵家族的委托基金，每周将随机获得5000~10000元现金' },
    { name: 'caopanjubo', displayName: '操盘巨擘', url: 'https://pic.imgdb.cn/item/66ed48f0f21886ccc007a9ff.png', price: 1000, quantity: 0, description: '【经商法宝】（仅在商店-倒买倒卖中使用）应用此法宝时，将延长50%股票周期的持续时间（无论牛市/熊市都会延长）' },
    { name: 'timeMachine', displayName: '百达翡丽', url: 'https://pic.imgdb.cn/item/66ed48f0f21886ccc007a9e5.png', price: 1000, quantity: 0, description: '【经商法宝】（仅在商店-倒买倒卖中使用）令人着迷的百达翡丽605怀表，应用此法宝时，将有15%概率在每周刷新时不更新时间' },
    { name: 'jiechengxianai', displayName: '结城夏奈召唤卡', url: 'https://pic.imgdb.cn/item/66e856f0d9c307b7e9bee42a.png', price: 10000, quantity: 0, description: '召唤一位神秘女嘉宾和她的夫君' },
    { name: 'spiritBottle', displayName: '精灵魔瓶', url: 'https://pic.imgdb.cn/item/66d004a1d9c307b7e99d4b93.png', price: 0, quantity: 0, description: '打开精灵面板，这是一个未来可期的伙伴，可以给你提供极大的助力' }
];

// 切换锦囊抽屉的显示状态
function toggleJinnangDrawer() {
    const drawer = document.getElementById('jinnang-drawer');
    const info = document.getElementById('jinnang-info');
    drawer.classList.toggle('open');
    info.classList.toggle('open');
    selectedItem = null;
    updateJinnangItems();
}

function generateItemToJinnang(name, displayName, url, price = 0, quantity = 0, description = '') {
    let item = jinnangItems.find(i => i.name === name);

    if (item) {
        // 如果该物品已存在，则增加数量
        item.quantity += quantity;
    } else {
        // 如果该物品不存在，则创建新物品并添加到背包
        const newItem = {
            name: name,
            displayName: displayName,
            url: url,
            price: price,
            quantity: quantity,
            description: description,
            timestamp: Date.now()  // 添加时间戳
        };
        jinnangItems.push(newItem);
    }

    updateJinnangItems(); // 更新背包显示
}

function addItemToJinnang(itemName, quantity = 1) {
    let item = jinnangItems.find(i => i.name === itemName);

    // 计算当前背包中的总物品数量
    let currentTotalQuantity = jinnangItems.reduce((sum, i) => sum + i.quantity, 0);

    if (item) {
        // 如果已有该物品，计算可以添加的数量
        let availableSpace = jinnangCapacity - currentTotalQuantity;
        if (availableSpace > 0) {
            let quantityToAdd = Math.min(quantity, availableSpace);
            item.quantity += quantityToAdd;
            quantity -= quantityToAdd;
        }

        // 若有剩余数量，提示背包已满
        if (quantity > 0) {
            showInfoBox("当前背包已没有空余位置！",
               () => {
                   enlargeCapacity();
               },
               () => {
                   enlargeCapacity();
               });
        }
    } else {
        // 如果没有该物品，则调用 generateItemToJinnang 生成并添加新物品
        let availableSpace = jinnangCapacity - currentTotalQuantity;
        if (availableSpace > 0) {
            let quantityToAdd = Math.min(quantity, availableSpace);
            generateItemToJinnang(itemName, itemName, 'https://example.com/item.png', 0, quantityToAdd, '新生成的物品描述');
            quantity -= quantityToAdd;
        }

        // 若有剩余数量，提示背包已满
        if (quantity > 0) {
            showInfoBox("当前背包已没有空余位置！",
               () => {
                   enlargeCapacity();
               },
               () => {
                   enlargeCapacity();
               });
        }
    }

    updateJinnangItems(); // 保持调用顺序不变
}


// 合并后的 useItem 函数
function useItem(itemName, quantity = 1) {
    const itemIndex = jinnangItems.findIndex(item => item.name === itemName);
    if (itemIndex !== -1 && jinnangItems[itemIndex].quantity >= quantity) {
        jinnangItems[itemIndex].quantity -= quantity;
        if (jinnangItems[itemIndex].quantity < 0) {
            jinnangItems[itemIndex].quantity = 0;
        }
        updateJinnangItems();
        updateJinnangCapacityDisplay();
        return true;
    }
    showInfoBox("道具数量不足或未找到该道具");
    return false;
}

function showItemDescription(price, description, itemDiv, item) {
    const jinnangDescription = document.getElementById('jinnang-description');
        jinnangDescription.innerHTML = `<p>${description}, 出售单价: ${convertPrice(item.price)}金</p>`;; // 清空现有内容

}

function updateJinnangCapacityDisplay() {
    let currentTotalQuantity = jinnangItems.reduce((sum, i) => sum + i.quantity, 0);
    document.getElementById('jinnang-capacity').innerText = `容量：${currentTotalQuantity}/${jinnangCapacity}`;
}
        
function closeDescriptionBox() {
    if (currentDescriptionBox) {
        currentDescriptionBox.remove();
        currentDescriptionBox = null;
        clearTimeout(autoCloseTimer);
    }
}

// 创建或替换进度条元素


// 删除进度条
function removeProgressBar() {
    const existingProgressBarWrapper = document.querySelector('.progress-bar-wrapper');
    if (existingProgressBarWrapper) {
        existingProgressBarWrapper.remove();
    }
}

// 更新后的sellItem函数
function sellItem() {
    if (!selectedItem) {
        showInfoBox("你没有选中道具，是否出售所有背包内的道具？", () => {
            let totalSoldItems = 0;
            let totalGoldEarned = 0;

            jinnangItems.forEach(item => {
                if (item.quantity > 0) {
                    totalGoldEarned += item.quantity * item.price;
                    totalSoldItems += item.quantity;
                    item.quantity = 0;  // 将所有物品数量设置为0
                }
            });

            if (totalSoldItems > 0) {
                goldAmount += totalGoldEarned;
                showInfoBox(`成功出售所有道具，获得${convertPrice(totalGoldEarned)}金子`);
                updateJinnangItems();
                updateGoldDisplay(goldAmount);
            } else {
                showInfoBox("背包内没有可出售的道具！");
            }
        });
        return;
    }

    const itemName = selectedItem.dataset.itemName;
    const itemIndex = jinnangItems.findIndex(i => i.name === itemName);

    if (itemIndex !== -1) {
        const selectedItem = jinnangItems[itemIndex];
        
        // 创建或更新进度条
        const progressBarWrapper = createOrUpdateProgressBar(selectedItem);

        // 显示出售确认框
        showInfoBox('拖动进度条选择出售数量的比例，并点击确认', () => {
            const progressBar = progressBarWrapper.querySelector('input[type="range"]');
            const sellPercentage = progressBar.value;  // 获取用户拖动的比例
            const quantityToSell = Math.floor((sellPercentage / 100) * selectedItem.quantity);

            if (quantityToSell > 0) {
                selectedItem.quantity -= quantityToSell;
                const totalPrice = quantityToSell * selectedItem.price;
                goldAmount += totalPrice;
                showInfoBox(`成功出售${quantityToSell}个${selectedItem.displayName}，获得${convertPrice(totalPrice)}金子`);

                updateJinnangItems();
                updateGoldDisplay(goldAmount);
            } else {
                showInfoBox('没有选择有效的出售数量');
            }

            // 无论成功或失败，都移除进度条
            removeProgressBar();
        }, () => removeProgressBar(),'black');
            
    } else {
        showInfoBox("请先选择需要出售的物品！");
    }
}

//拓展背包
function enlargeJinnangCapacity(amount) {
    jinnangCapacity += amount;
    showInfoBox(`容量已增加${amount}，当前容量为${jinnangCapacity}`);
    updateJinnangCapacityDisplay();
}
        
function enlargeCapacity() {
    let cost;
    let increaseAmount;

    if (jinnangCapacity < 6000) {
        cost = 100000;
        increaseAmount = 500;
    } else if (jinnangCapacity < 7000) {
        cost = 150000;
        increaseAmount = 500;
    } else if (jinnangCapacity < 8000) {
        cost = 180000;
        increaseAmount = 500;
    } else if (jinnangCapacity < 10000) {
        cost = 240000;
        increaseAmount = 500;
    } else if (jinnangCapacity < 20000) {
        cost = 500000;
        increaseAmount = 500;
    } else if (jinnangCapacity < 50000) {
        cost = 1000000;
        increaseAmount = 500;
    } else {
        cost = 3000000;
        increaseAmount = 1000;
    }

    // 显示花费信息并请求确认
    showInfoBox(`花费${convertPrice(cost)}金子可以增加${increaseAmount}容量，是否确认？`, () => {
        if (confirm) {
            if (goldAmount >= cost) {
                goldAmount -= cost;
                jinnangCapacity += increaseAmount;
                showInfoBox(`容量已增加${increaseAmount}，当前容量为${jinnangCapacity}`);
                updateGoldDisplay(goldAmount);
                updateJinnangCapacityDisplay();
            } else {
                showInfoBox("金子不足，无法增加容量。");
            }
        } else {
            return;
        }
    });
}

// 单位换算函数
function convertPrice(price) {
    let ding = Math.floor(price / 1000000);
    price %= 1000000;
    let liang = Math.floor(price / 1000);
    let wen = price % 1000;

    let result = '';
    if (ding > 0) {
        result += `${ding}锭 `;
    }
    if (liang > 0) {
        result += `${liang}两 `;
    }
    if (wen > 0 || result === '') {
        result += `${wen}文`;
    }
    return result.trim();
}

// 更新锦囊内道具数量
let selectedItem = null; // 在函数外部定义selectedItem

function updateJinnangItems() {
    const jinnangReward = document.getElementById('jinnang-reward');
    jinnangReward.innerHTML = ''; // 清空现有内容

    if (isNaN(jinnangCapacity)) {
        jinnangCapacity = 2000;
    }

    // 按照时间戳排序，确保最早获得的物品显示在前面
    const sortedItems = [...jinnangItems].sort((a, b) => b.price - a.price);

    sortedItems.forEach(item => {
        if (item.quantity > 0) {
            const itemDiv = document.createElement('div');
            itemDiv.className = 'jinnang-item';
            itemDiv.style.position = 'relative'; // 为了定位描述框
            itemDiv.style.display = 'flex'; 
            itemDiv.style.flexDirection = 'row'; 
            itemDiv.style.alignItems = 'center'; 
            itemDiv.style.justifyContent = 'space-between'; 
            itemDiv.style.padding = '4px'; 
            itemDiv.style.boxShadow = 'rgb(131, 74, 15) 0px 0px 0px 1px inset';
            itemDiv.style.border = '1px solid rgb(131,74,15)';
            itemDiv.innerHTML = `
                <img src="${item.url}" alt="${item.name}" style="border: 1px solid black;height: 45px;width: 45px;">
                <div class="item-text-container">
                <div id="jinnang-item-name" class="item-text-top">${item.displayName}</div>
                <div id="jinnang-item-quantity" class="item-text-bottom">${item.quantity}个</div>
                </div>
            `;

            // 添加点击事件监听器
            itemDiv.addEventListener('click', () => {
                showItemDescription(item.price, item.description, itemDiv, item);

                // 移除之前选中项的视觉提示
                if (selectedItem) {
                    selectedItem.style.border = '1px solid rgb(131,74,15)';
                    selectedItem.style.boxShadow = 'rgb(131, 74, 15) 0px 0px 0px 1px inset';
                }

                // 添加当前选中项的视觉提示
                selectedItem = itemDiv;
                selectedItem.style.border = '1px solid white';
                selectedItem.style.boxShadow = 'red 0px 0px 0px 2px inset';

                // 将 item 存储到 selectedItem 的 dataset 中，以便出售时使用
                selectedItem.dataset.itemName = item.name;
                selectedItem.dataset.itemDisplayName = item.displayName;
                
            });

            jinnangReward.appendChild(itemDiv);
        }
    });

    updateJinnangCapacityDisplay();
}

const attributeMap = {
    endurance: "耐力",
    intelligence: "智力",
    strength: "强壮",
    agility: "敏捷",
    faith: "信仰"
};

// 定义一个包含道具效果的映射表
const itemEffects = {
    celebrationCake: () => {
        const attributeKeys = Object.keys(additionalAttributes);
        const randomAttribute = attributeKeys[Math.floor(Math.random() * attributeKeys.length)];
        const attributeNameInChinese = attributeMap[randomAttribute];
        
        if (additionalAttributes[randomAttribute] <= 1000) {
            additionalAttributes[randomAttribute] += 5;
            showInfoBox(`美味蛋糕下肚，您的${attributeNameInChinese}增加了5点。`);
        } else {
            additionalAttributes[randomAttribute] = 1000;
            showInfoBox(`蛋糕虽好，吃太多也会发胖哦！${attributeNameInChinese}已经提升至最大值了。`);
        }
        updateAttributePanel();
    },
    cultivationPill200: () => increaseCultivation(200),
    cultivationPill500: () => increaseCultivation(500),
    blessGift: () => getBlessGift(),
    poisonSkillBook: () => {
        showInfoBox('你可以使用1本施毒之术兑换5个毒粉',
            () => {
               addItemToJinnang('poisonPowder',5);
               showInfoBox('成功兑换5个毒粉！');
            },
            () => {
                addItemToJinnang('poisonSkillBook',1);
                showInfoBox('取消兑换！');
            });
    },
    tinyBag: () => {
        goldAmount += 88000;
        updateGoldDisplay(goldAmount);
        showInfoBox("您获得了88两金子。");
    },
    redEnvelope: () => {
        const randomGold = Math.floor(Math.random() * (188800 - 666 + 1)) + 666;
        goldAmount += randomGold;
        updateGoldDisplay(goldAmount);
        showInfoBox(`您获得了${convertPrice(randomGold)}两金子。`);
    },
    summonCharmPaper: () => {
        showSummonPanel();
        setTimeout(handleSummonPet, 0);
    },
    liguolin: () => useLiguolin(),
    jiechengxianai: () => {
        addPetToSelect('jiecheng', '结城夏奈');
        addItemToJinnang('liguolin', 1);
    },
    mutationScroll: () => {
        useMutationScroll();
        addItemToJinnang('mutationScroll',1);
    },
    advancedSkillPill: () => fulfillPetSkill(),
    drugBox: () => getRandomDrug(10,20),
    fancyDrugBox: () => getRandomDrug(20,40),
    advancedExperienceBook: () => directlyAbsorbExperience(30000),
    normalExperienceBook: () => directlyAbsorbExperience(10000),
    fragmentsPackage: () => addWuxingFragments(100),
    firstFragments: () => addWuxingFragments(625),
    secondFragments: () => addWuxingFragments(125),
    thirdFragments: () => addWuxingFragments(25),
    fourthFragments: () => addWuxingFragments(5),
    fifthFragments: () => addWuxingFragments(1),
    goldAmuletPackage: () => {
        const colors = ['red', 'purple', 'orange', 'blue', 'green'];
        
        // 遍历颜色数组，将金符添加到管理器中
        colors.forEach(color => addAmuletToManager('goldAmulet', color, 1));
        
        showInfoBox('你获得金符（红）金符（紫）金符（橙）金符（蓝）金符（绿），请在五行面板中查看！');
    },
    spiritWine: () => useSpiritWine(),
    qualityEnhancePill: () => {
        if (!isNaN(qualityPillCount)){
            qualityPillCount += 1;
            updateQualityDisplayWithPillBonus();
            showInfoBox(`成功应用资质仙丹，宠物升级时会享受额外的资质加成！当前仙丹总数为${qualityPillCount}，宠物等级每提升一级会减少一颗`);
        }
        
    },
    qualityEnhancePillPKG: () => {
        addItemToJinnang('qualityEnhancePill',5);
    },
    battleWithTree: () => summonEnemyByType('practiceEnemy'),
    battleWithAncientEvil: () => summonEnemyByType('ancientEvil'),
    battleWithExpEnemy: () => summonEnemyByType('expEnemy'),
    noWorkBoss: () => summonEnemyByType('noWorkBoss'),
    qiongQi: () => summonEnemyByType('qiongQi'),
    practiceEnemyPlus: () => summonEnemyByType('practiceEnemyPlus'),
    stoneDragon: () => summonEnemyByType('stoneDragon'),
    baiYinPKG: () => {
        addItemToJinnang('baiYinCard',30);
    },
    baiYinCard: () => {
        if (baiYinInterval !== null) {
            showInfoBox('试炼之地正在持续中，无法叠加！', null, null, 'red');
            return;
        }
        
        handleBattleWithBaiYin();  // 开始与 'baiYin' 的战斗
        document.getElementById('baiyinOverlay').style.display = 'block';
    
        setTimeout(() => {
            if (baiYinInterval) {  // 检查 baiYinInterval 是否存在
                clearInterval(baiYinInterval);
                baiYinInterval = null;  // 清除后将其重置为 null
            }
    
            summonEnemy = false;  // 设置 `summonEnemy` 为 `false`
            clearAutoBattle();
            showInfoBox('试炼之地结束了', null, null, 'black');  // 显示提示框
            document.getElementById('baiyinOverlay').style.display = 'none';
        }, 60000);  
    },
    universalCrystal: () => {
        levelUpSkill();
        addItemToJinnang('universalCrystal',1);
    },
    universalKernel: () => {
        levelUpSkill();
        addItemToJinnang('universalKernel',1);
    },
    universalHeart: () => {
        levelUpSkill();
        addItemToJinnang('universalHeart',1);
    },
    resetEarningMultiplierPowder: () => resetEarningMultiplier(),
    bossSealCard: () => generateSealCard(),
    seperateStone: () => {
        hallucinatePet();
        addItemToJinnang('seperateStone',1);
    },
    coagulateStone: () => {
        if (!hallucinated) {
            showInfoBox('你的宠物还没有开启幻化状态，请先使用离魂石开启！',null,null,'red');
        } else {
            hallucinatePet();
        }
        addItemToJinnang('coagulateStone',1);
    },
    redApple: () => {
        additionalPlayerCultivation += 1;
        showInfoBox(`${currentPet.name}吃了一个苹果`,null,null,'green');
    },
    resetJinnang: () => showInfoBox(
        '\n此操作会清空背包所有内容并刷新页面，请务必知悉！\n\n（仅当背包信息错误时才推荐使用，道具一经丢失无法恢复！\n\n⚠️⚠️⚠️如果你确认背包存在不可描述的问题，请点击确认键清空并刷新！）',
        async () => {  // 直接使用 async 函数
            await clearOldItems();  // 等待清除旧物品完成
            await saveGameState();  // 等待保存游戏状态完成
            window.location.reload();  // 刷新页面
        },
        () => {
            showInfoBox('取消成功！');
            addItemToJinnang('resetJinnang',1);
        },
        'red',
        'https://pic.imgdb.cn/item/66e043bad9c307b7e94c14df.gif',
        '192px * 108px'
    ),
    chocolate: () => {
        let currentPetState = advancementStates.find(state => state.petName === currentPet.name);
        currentPetState.intimacy += 10;
        additionalPlayerCultivation += 2;
        updateAdvancement();
        showInfoBox(`${currentPetState.petName}吃了一个费罗列，增加了10点亲密度`,null,null,'brown'); 
    },
    fancyFlower: () => {
        let currentPetState = advancementStates.find(state => state.petName === currentPet.name);
        currentPetState.intimacy += 100;
        additionalPlayerCultivation += 2;
        updateAdvancement();
        showInfoBox(`你向${currentPetState.petName}送出了一捧花束，${currentPetState.petName}看到你突然的举动，一时局促地害羞起来`,null,null,'lightred'); 
    },
    damoTumbler: () => {
        showInfoBox('快给你最中意的崽玩吧',null,null,'black');
    },
    tejiWisdomPill: () => {
        upgradeWisdom();
        showInfoBox(`你使用了一颗特级悟性丹，将悟性提升至${currentWisdom}`);
    },
    spiritBottle: () => {
        displayInBottle();
        const bottleItem = jinnangItems.find(item => item.name === 'spiritBottle');
        if (bottleItem && bottleItem.quantity !== 1) {
            bottleItem.quantity = 1;
        }
        updateJinnangItems();
    },
    hongHuang: () => openHongHuangTreasure(),
    attentionValue: () => {
        increaseCurrentPetAttention(4);
        showInfoBox('当前宠物增加了4点集中值');
    },
    learningValueBook: () => {
        increaseCurrentPetLearningValue(20000);
        showInfoBox('当前宠物增加了20000学习度');
    },
    enlargeCapacityCard: () => enlargeJinnangCapacity(1000),
    backToOne: () => {
        addItemToJinnang('infiniteGem',100);
        addItemToJinnang('ignoranceWater',100);
    },
    universalAsh: () => {
        addItemToJinnang('universalAsh',1);
        const universalAshItem = jinnangItems.find(item => item.name === 'universalAsh');
        if (universalAshItem && universalAshItem.quantity < 5) {
            showInfoBox('你的宇宙之尘数量不足5个，无法合成宇宙之晶！',null,null,'red');
        } else {
            useItem('universalAsh',5);
            addItemToJinnang('universalCrystal',1);
            showInfoBox('消耗5个宇宙之尘合成一个宇宙之晶！',null,null,null,'https://pic.imgdb.cn/item/66cc940cd9c307b7e9cb752e.png');
        }
    },
    goldBlock: ()=> sellGoldBlock(200000000),
    tinyGoldBlock: ()=> sellGoldBlock(8000000),
    qiongmeiCard: () => {
        addPetToSelect('qiongmei', 'かすがのそら');
        showInfoBox('你获得了春日野穹（かすがのそら）',null,null,'blue','https://pic.imgdb.cn/item/66d7f116d9c307b7e9a009b9.jpg','192px * 108px');
    },
    blueArmComponents: () => {
        addItemToJinnang('blueArmComponents',1);
        const blueAC = jinnangItems.find(item => item.name === 'blueArmComponents');
        if (blueAC.quantity >= 25) {
            useItem('blueArmComponents',25);
            addItemToJinnang('orangeArmComponents',1);
            goldAmount -= 20000;
            updateGoldDisplay(goldAmount);
            showInfoBox('消耗25个蓝色武装原料和20两金，成功合成1个橙色武装原料',null,null,null,'https://pic.imgdb.cn/item/66d8732dd9c307b7e96449c0.png');
        } else {
            showInfoBox('原料数量不足，无法合成！',null,null,'red');
        }
    },
    orangeArmComponents: () => {
        addItemToJinnang('orangeArmComponents',1);
        const OrangeAC = jinnangItems.find(item => item.name === 'orangeArmComponents');
        if (OrangeAC.quantity >= 1) {
            useItem('orangeArmComponents',1);
            addItemToJinnang('blueArmComponents',25);
            goldAmount -= 100000;
            updateGoldDisplay(goldAmount);
            showInfoBox('消耗1个橙色武装原料和100两金，成功分解为25个蓝色武装原料',null,null,null,'https://pic.imgdb.cn/item/66d8732dd9c307b7e964497d.png');
        } else {
            showInfoBox('原料数量不足，无法分解！',null,null,'red');
        }
    },
    forgeTool: () => {
        addItemToJinnang('forgeTool',1);
        if (!useItem('orangeArmComponents',25)) {
            showInfoBox('你的橙色武装原料不足25个，无法合成原始宠物武装！',null,null,'red');
        } else {
            generateItemToJinnang('nativePetArms','原始宠物武装','https://pic.imgdb.cn/item/66d87511d9c307b7e9673f68.png', price = 20000, quantity =  1, description = '充满灵力的原始宠物武装，用于给任意的武装解锁，解锁后宠物可得到强大的属性');
            showInfoBox('消耗25个蓝色武装原料，成功合成1个原始宠物武装',null,null,null,'https://pic.imgdb.cn/item/66d87511d9c307b7e9673f68.png');
        }
    },
    wealthyGemBag: () => getGem(null, '3', null, null, null, null),
    starGemPKG: () => addItemToJinnang('starGem',200),
    starGemPlusPKG: () => addItemToJinnang('starGemPlus',200),
    purpleSixthGem: () => getGem('purple', '6', null, null, null, 1),
    pinkSixthGem: () => getGem('pink', '6', null, null, null, 1),
    gemLuckyBag: () => getGem(null, '1', null, null, null, 1),
    ignoranceWater: () => resetSpecialization(),
    resetTrainingCount: () => {
        if (petLevel < 180) {
            showInfoBox('你的宠物尚未满级，仍然存在没有开发的培养机会，请满级后培养次数耗尽再使用！',null,null,'red');
            addItemToJinnang('resetTrainingCount',1);
            return;
        }
        
        if (trainingCount !== null) {
            trainingCount = 0;
            showInfoBox('你的宠物培养次数重置为5次！',null,null,'black');
        } else {
            showInfoBox('使用出错！',null,null,'red');
        }
    },
    talentedBless: () => getBlessSkills(),
    advancedSkillBook: () => {
        const item = ['lizhuamengji', 'huoyanchongji', 'tiankongshouhu', 'suohou', 'jiyanggangqi', 'tianshenzhufu', 'tianwanghuwei', 'beimingshengong', 'xingzhizhufu', 'zhenbaoshenquan'];
        const randomIndex = Math.floor(Math.random() * item.length);
        const selectedItem = item[randomIndex];
        addItemToJinnang(selectedItem, 1);
    },
    lizhuamengji: () => createSkills('利爪猛击', 'SSS', 'PAE', 1, 3, '凶狠的近战之术，运用自身尖锐利爪给予敌人舍命一击，造成大量物理伤害的同时附加百分百流血效果'),
    huoyanchongji: () => createSkills('火焰冲击', 'SSS', 'MAE', 1, 3, '精通元素之力的宠物懂得如何将致命元素化为己用，掌握此技能将会运用高温火焰喷向敌人，造成猛烈伤害并大幅腐蚀敌人护甲'),
    tiankongshouhu: () => createSkills('天空守护', 'SSS', 'PHE', 1, 2.5, '为我方恢复大量生命值，并附加持续治疗效果。持续治疗效果根据技能等级和玩家法术攻击力、修为决定。'),
    suohou: () => createSkills('锁喉', 'SSS', 'PPE', 1, 2.5, '敌人中毒时，将按照毒伤永久降低敌人的生命值上限（战局刷新后失效）。'),
    jiyanggangqi: () => createSkills('极阳罡气', 'SSS', 'PDE', 1, 0.01, '为自身增加一个用于接受并放大敌人伤害的罡气环绕状态，敌人造成伤害时会以非常大的比例进行反弹。'),
    beimingshengong: () => createSkills('北冥神功', 'SSS', 'PHE', 1, 2, '来自北冥之地的修炼之术，运用无上念力治愈自身的同时随机附加一个属性增益。'),
    tianshenzhufu: () => createSkills('天神祝福', 'SSS', 'NE', 1, 1, '大幅度增加宠物的生命值和速度，每级提升2000点。'),
    tianwanghuwei: () => createSkills('天王护卫', 'SSS', 'NE', 1, 1, '大幅度增加宠物的物理防御和法术防御，每级提升500点。'),
    xingzhizhufu: () => createSkills('星之祝福', 'SSS', 'JKE', 1, 0.025, '敌人攻击我方时有概率解除自身减益效果，并恢复一定生命值。'),
    zhenbaoshenquan: () => createSkills('震爆神拳', 'SSS', 'TC', 1, 10, '降下天雷惩戒敌人，造成大量伤害的同时会对自身造成一定损伤，双方速度之差越大，伤害越大。'),
    merchantPointsCard: () => {
        scalpingScore += 2000;
        showMerchant(`你的经商积分增加了2000，当前积分为${scalpingScore}。`);
    },
    lifeGem: () => {
        currentLifeSpan = Math.min(maxLifeSpan, currentLifeSpan + 5000);
        showInfoBox(`成功恢复5000点寿命，当前宠物寿命为${currentLifeSpan}/${maxLifeSpan}。`);
    }
};

function useAssignedItem() {
    if (!selectedItem || !selectedItem.dataset.itemName) {
        showInfoBox("请先选择一个道具。");
        return;
    }
    const itemName = selectedItem.dataset.itemName;
    const itemDisplayName = selectedItem.dataset.itemDisplayName;
    
    // 如果 itemDisplayName 包含 "级天"，则将其识别为 availableGemItems
    const availableGemItems = itemDisplayName.includes('级天') ? itemDisplayName : null;
    lastUsedItemName = itemName; // 更新最近使用的道具名称

    // 检查道具是否在映射表中
    if (itemEffects[itemName]) {
        if (useItem(itemName)) {
            itemEffects[itemName](); // 执行对应道具的效果
            updateJinnangItems(); // 更新锦囊内容显示
        } else {
            showInfoBox("道具已耗尽。");
        }
    } else if (itemDisplayName && availableGemItems) {
        mergeGem(itemDisplayName, null);
    } else {
        showInfoBox('此道具不能直接在背包内使用！');
    }
}

function createOrUpdateProgressBar(item, useMode = false) {
    // 检查是否已经存在进度条，如果存在则先移除
    const existingProgressBarWrapper = document.querySelector('.progress-bar-wrapper');
    if (existingProgressBarWrapper) {
        existingProgressBarWrapper.remove();
    }

    // 创建新的进度条容器
    const progressBarWrapper = document.createElement('div');
    progressBarWrapper.classList.add('progress-bar-wrapper');
    progressBarWrapper.style = 'background: rgba(0, 0, 0, 0.8);display: flex;flex-direction: column;align-items: center;position: fixed;left: 50%;top: 40%;transform: translate(-50%, -50%);width: 80%;max-height: 80%;min-height: 10%;z-index: 9999;font-size: 14px;padding: 10px 20px 5px;background-color: rgb(223, 191, 110);color: rgb(146, 52, 28);background-image: url(https://pic.imgdb.cn/item/663885620ea9cb14033e4f6e.png);background-repeat: repeat;background-size: auto;box-shadow: rgb(30, 46, 47) 0px 0px 0px 1px, rgb(111, 57, 28) 0px 0px 0px 1px inset;border: 1px solid rgb(235, 172, 59);';


    // 创建进度条
    const progressBar = document.createElement('input');
    progressBar.style = 'width: 100%;height: 16px;appearance: none;background-color: rgb(255 255 255 / 90%);cursor: grabbing;border: 1px solid white;border-radius: 50px;';
    progressBar.type = 'range';
    progressBar.min = '0';
    progressBar.max = '100';
    progressBar.value = '0';  // 初始值为0
    progressBar.classList.add('progress-bar');

    // 显示进度条当前选择的数量
    const progressValueDisplay = document.createElement('span');
    progressValueDisplay.classList.add('progress-value-display');
    progressValueDisplay.style.color = 'black';
    progressValueDisplay.style.marginTop = '5px';
    progressValueDisplay.textContent = `${item.displayName}，0 / ${item.quantity} 个`;

    progressBarWrapper.appendChild(progressBar);
    progressBarWrapper.appendChild(progressValueDisplay);

    if (useMode) {
        progressBar.addEventListener('input', () => {
            const progressPercentage = progressBar.value;
            const quantityToUse = Math.floor((progressPercentage / 100) * item.quantity);
            progressValueDisplay.textContent = `${item.displayName}，${quantityToUse} / ${item.quantity} 个`;
        });
    } else {
    // 监听进度条的拖动事件，实时更新数量显示
        progressBar.addEventListener('input', () => {
            const progressPercentage = progressBar.value;
            const quantityToSell = Math.floor((progressPercentage / 100) * item.quantity);
            progressValueDisplay.textContent = `${item.displayName}，${quantityToSell} / ${item.quantity} 个，可售${convertPrice(item.price * quantityToSell)}金`;
        });
    }
    
    document.body.appendChild(progressBarWrapper);  // 将进度条添加到页面上

    return progressBarWrapper;
}
        
function useAllItems() {
    if (!selectedItem || !selectedItem.dataset.itemName) {
        showInfoBox("请先选择一个道具。");
        return;
    }

    const itemName = selectedItem.dataset.itemName;
    const itemIndex = jinnangItems.findIndex(i => i.name === itemName);

    if (!itemEffects[itemName]) {
        showInfoBox('此道具不能直接在背包内使用！',null,null,'red');
        return;
    }

    if (itemIndex !== -1) {
        const selectedItem = jinnangItems[itemIndex];
        
        // 创建或更新进度条
        const progressBarWrapper = createOrUpdateProgressBar(selectedItem, true);

        showInfoBox('此功能不稳定，如非必要请手动使用！', () => {
            const progressBar = progressBarWrapper.querySelector('input[type="range"]');
            const usePercentage = progressBar.value;  // 获取用户拖动的比例
            const quantityToUse = Math.min(Math.floor((usePercentage / 100) * selectedItem.quantity), selectedItem.quantity); // 计算数量并确保不超过现有数量

            if (quantityToUse > 1000) {
                showInfoBox('道具数量过多！请控制在1000个以内，以防止卡死或道具丢失！',null,null,'red');
                removeProgressBar();
                return;
            }
            
            if (quantityToUse > 0) {
                selectedItem.quantity -= quantityToUse;
                useItemsInBatches(itemName, quantityToUse);  // 批量使用道具
                updateJinnangItems();
            } else {
                showInfoBox('没有选择有效的使用数量');
            }
    
            // 移除进度条
            removeProgressBar();
        }, () => removeProgressBar(), 'black');  
    } else {
        showInfoBox("未知错误！");
    }        
}

function useItemsInBatches(itemName, totalAmount) {
    let itemsProcessed = 0;

    function processNextBatch() {
        const batchSize = Math.min(10, totalAmount - itemsProcessed);  // 每次批处理最多10个道具
        let itemsInThisBatch = 0;

        while (itemsInThisBatch < batchSize && itemsProcessed < totalAmount) {
            itemEffects[itemName]();  // 执行道具效果
            itemsProcessed++;
            itemsInThisBatch++;
        }

        updateJinnangItems();  // 更新锦囊显示

        if (itemsProcessed < totalAmount) {
            // 还有剩余道具未处理，继续异步处理
            setTimeout(processNextBatch, 0);
        } else {
            selectedItem = null;  // 所有道具使用完毕后重置选中状态
        }
    }

    processNextBatch();  // 开始异步批处理
}


function generateSealCard() {
    // 定义封印卡片的英文名称和对应的汉字名称映射
    const sealCardsMap = new Map([
        ['battleWithTree', '树桩魔魂封印'],
        ['battleWithExpEnemy', '战神魔魂封印'],
        ['battleWithAncientEvil', '太古魔魂封印'],
        ['noWorkBoss', '無班之魂'],
        ['qiongQi', '穷奇'],
        ['practiceEnemyPlus', '高级树桩封印卡'],
        ['stoneDragon', '岩龙封印卡']
    ]);

    // 封印卡片的英文名称数组
    const sealCards = ['battleWithTree', 'battleWithExpEnemy', 'battleWithAncientEvil', 'noWorkBoss', 'qiongQi','practiceEnemyPlus','stoneDragon'];

    // 随机选择一个封印卡片的英文名称
    const randomIndex = Math.floor(Math.random() * sealCards.length);
    const selectedCard = sealCards[randomIndex];

    // 获取对应的汉字名称
    const chineseName = sealCardsMap.get(selectedCard);

    // 将选中的封印卡片名称传入 addItemToJinnang 函数，并增加数量 1
    addItemToJinnang(selectedCard, 1);

    // 显示提示框，告知玩家解锁了哪张封印卡片，并显示汉字名称
    showInfoBox(`你解锁了一张${chineseName}`);
}
        
function useSpiritWine() {
     if (!awakened) {
         showInfoBox("你的宠物还没有通过觉醒获取战斗精灵的庇护，琼浆玉露被宠物偷偷喝掉了");
         return;
     }
    
     if (spiritLevel >= 120) {
        showInfoBox('你的精灵等级已达到最大级，无法继续使用此道具。', null, null, 'red');
        return;
    }

    if (spiritLevel < 100) {
        showInfoBox(
            '你的精灵未满100级，建议使用精炼石提升等级。如需继续使用，请点击确认。',
            () => {
                spiritLevel += 2;
                showInfoBox(`成功提升2级精灵等级，当前精灵为${spiritLevel}级`, null, null, 'green');
            },
            () => {
                addItemToJinnang('spiritWine', 1);
            },
            'yellow'
        );
    } else {
        // 精灵等级在100到119之间时直接提升等级
        spiritLevel += 2;
        showInfoBox(`成功提升2级精灵等级，当前精灵为${spiritLevel}级`, null, null, 'green');
    }
}
        
function getRandomDrug(minNum, maxNum) {
    // 在指定范围内生成一个随机药物数量
    const drugQuantity = Math.floor(Math.random() * (maxNum - minNum + 1)) + minNum;

    // 药材的键名数组
    const drugKeys = Object.keys(drugInventory);
    
    // 记录获得的药材信息
    let drugsObtained = '';

    for (let i = 0; i < drugQuantity; i++) {
        const randomDrug = drugKeys[Math.floor(Math.random() * drugKeys.length)];
        drugInventory[randomDrug].quantity += 1;

        // 记录每个获得的药材名
        drugsObtained += `${randomDrug} `;
    }

    // 一次性显示获得的所有药材
    showInfoBox(`你获得了 ${drugsObtained.trim()}`, 'pink');
}
            
function useLiguolin() {
    const petSelect = document.getElementById('pet-select');
    const petKey = Object.keys(pets).find(key => pets[key].name === 'Guolin·Li');
    
    if (Array.from(petSelect.options).some(option => option.value === petKey)) {
        showInfoBox(`您已召唤Mr.right！`);
    } else {
        showInfoBox(`您成功俘获了Guolin·Li！`);
        const option = document.createElement('option');
        option.value = petKey;
        option.text = 'Guolin·Li';
        petSelect.appendChild(option);
    }
}
            
// 通用的修为增加函数
function increaseCultivation(amount) {
    if (additionalPlayerCultivation >= 1000000) {
        additionalPlayerCultivation = 1000000;
        showInfoBox("由于你的修炼修为达到最大值，使用此道具没有任何效果", null, null, 'red');
    } else {
        additionalPlayerCultivation = Math.min(1000000, additionalPlayerCultivation + amount);
        showInfoBox(`${currentPet.name}的修为增加了${amount}点，当前修炼修为值为${additionalPlayerCultivation}`);
    }
}

function deleteItems() {
    if (!selectedItem) {
        // 没有选中物品，提示是否删除所有背包内的道具
        showInfoBox("你没有选中道具，是否删除所有背包内的道具？", () => {
            // 用户确认后执行以下代码
            let totalDeletedItems = 0;

            jinnangItems.forEach(item => {
                if (item.quantity > 0) {
                    totalDeletedItems += item.quantity;
                    item.quantity = 0; // 将所有物品数量设置为0
                }
            });

            if (totalDeletedItems > 0) {
                showInfoBox(`成功删除所有道具。`, null, null, 'green');
                updateJinnangItems();
            } else {
                showInfoBox("背包内没有可删除的道具！");
            }
        }, null, 'red');
        return;
    }

    const itemName = selectedItem.dataset.itemName;
    const itemIndex = jinnangItems.findIndex(i => i.name === itemName);

    if (itemIndex !== -1) {
        // 确认删除特定数量的道具
        showInfoBox(`您确定要删除所有的 ${jinnangItems[itemIndex].displayName} 吗？`, () => {
            jinnangItems[itemIndex].quantity = 0; // 将选中物品的数量设置为0
            showInfoBox(`${jinnangItems[itemIndex].displayName} 已成功删除。`, null, null, 'green');

            updateJinnangItems();
        }, null, 'red');
    } else {
        showInfoBox("请先选择需要删除的物品！");
    }
}
        
// 更新顶栏道具数量
function updateTopBarItems() {
    const topBarItems = {
        'high-grade-pill': highGradePill,
        'transmutation-pill': transmutationPill,
        'reborn-pill': rebornPill,
        'quality-pill': qualityPill,
        'miraculous-pill': miraculousPill,
        'bingpo-reborn-pill': bingpoRebornPill,
        'golden-reborn-pill': goldenRebornPill,
    };

    for (const [id, quantity] of Object.entries(topBarItems)) {
        const itemDiv = document.getElementById(id);
        itemDiv.innerText = quantity;
        itemDiv.onclick = () => showTopBarItemDescription(getTopBarItemDescription(id), itemDiv, { id, quantity, price: getTopBarItemPrice(id) });
    }
}

function getTopBarItemDescription(itemId) {
    switch (itemId) {
        case 'high-grade-pill':
            return '用于提升宠物1~20悟性，悟性越高失败率越高，需要谨慎使用。';
        case 'transmutation-pill':
            return '重置当前宠物所掌握的技能。';
        case 'reborn-pill':
            return '重置当前宠物的资质、成长率、技能和悟性，等级恢复至1级，变异状态重新生成。';
        case 'quality-pill':
            return '重新生成宠物的当前资质。';
        case 'miraculous-pill':
            return '可以直接让宠物变异的神奇丹药。';
        case 'bingpo-reborn-pill':
            return '重置当前宠物的资质、成长率、技能和悟性，等级恢复至1级，但不改变变异状态。';
        case 'golden-reborn-pill':
            return '重置当前宠物的变异状态、技能和悟性，等级恢复至1级，但不改变资质、成长率。';
        default:
            return '未知道具';
    }
}

function getTopBarItemPrice(itemId) {
    switch (itemId) {
        case 'high-grade-pill':
            return 20;
        case 'transmutation-pill':
            return 30;
        case 'reborn-pill':
            return 30;
        case 'quality-pill':
            return 50;
        case 'miraculous-pill':
            return 500;
        case 'bingpo-reborn-pill':
            return 80;
        case 'golden-reborn-pill':
            return 60;
        default:
            return 0;
    }
}
let currentDescriptionBox = null;
function showTopBarItemDescription(description, itemDiv, item) {
    // 如果当前有描述框，移除它
    if (currentDescriptionBox) {
        currentDescriptionBox.remove();
        currentDescriptionBox = null;
    }

    let descriptionBox = document.createElement('div');
    descriptionBox.className = 'description-box';
    descriptionBox.style.position = 'fixed';
    descriptionBox.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
    descriptionBox.style.color = 'white';
    descriptionBox.style.padding = '10px';
    descriptionBox.style.borderRadius = '5px';
    descriptionBox.style.zIndex = '1000';
    descriptionBox.style.width = '300px';
    descriptionBox.style.maxWidth = '80%';
    descriptionBox.style.top = '50%';
    descriptionBox.style.left = '50%';
    descriptionBox.style.transform = 'translate(-50%, -50%)';
    descriptionBox.style.wordWrap = 'break-word';
    descriptionBox.style.textAlign = 'center';
    descriptionBox.innerHTML = `<p>${description}</p>`;

    let sellButton = document.createElement('button');
    sellButton.innerText = '出售道具';
    sellButton.style.marginTop = '10px';
    sellButton.addEventListener('click', () => sellTopBarItem(item));
    descriptionBox.appendChild(sellButton);

    document.body.appendChild(descriptionBox);
    currentDescriptionBox = descriptionBox;

    // 设置3秒后自动关闭
    setTimeout(() => {
        if (descriptionBox) {
            descriptionBox.remove();
            currentDescriptionBox = null;
        }
    }, 3000);
}

// 出售顶部道具函数
function sellTopBarItem(item) {
    let quantityToSell = prompt('请输入要出售的数量:');
    if (quantityToSell !== null) {
        quantityToSell = parseInt(quantityToSell, 10);
        if (isNaN(quantityToSell) || quantityToSell <= 0) {
            showInfoBox('请输入有效的数量');
            return;
        }
        if (quantityToSell > item.quantity) {
            showInfoBox('您没有足够的道具数量');
            return;
        }

        // 更新全局变量
        switch (item.id) {
            case 'high-grade-pill':
                highGradePill -= quantityToSell;
                break;
            case 'transmutation-pill':
                transmutationPill -= quantityToSell;
                break;
            case 'reborn-pill':
                rebornPill -= quantityToSell;
                break;
            case 'quality-pill':
                qualityPill -= quantityToSell;
                break;
            case 'miraculous-pill':
                miraculousPill -= quantityToSell;
                break;
            case 'bingpo-reborn-pill':
                bingpoRebornPill -= quantityToSell;
                break;
            case 'golden-reborn-pill':
                goldenRebornPill -= quantityToSell;
                break;
            default:
                return;
        }

        goldAmount += quantityToSell * item.price; // 使用 item.price 作为单价
        showInfoBox(`成功出售${quantityToSell}个道具，获得${convertPrice(quantityToSell * item.price)}金子`);

        updateTopBarItems();
        updateGoldDisplay(goldAmount); // 更新金币数量显示的函数
    }
}

function addItemToTopBar(item) {
    switch (item.name) {
        case '神兽还童丹':
            rebornPill++;
            break;
        case '还童金丹':
            goldenRebornPill++;
            break;
        case '资质重生丹':
            qualityPill++;
            break;
        case '灵异金丹':
            miraculousPill++;
            break;
        case '高级悟性丹':
            highGradePill++;
            break;
        case '冰魄还童丹':
            bingpoRebornPill++;
            break;
        case '万化灵丹':
            transmutationPill++;
            break;
        default:
            // 未知道具
            return;
    }
    updateTopBarItems();
}

function jumpToQuality() {
    toggleAttributeDrawer();
    const drawer = document.getElementById('quality-drawer');
    if (!drawer.classList.contains('open')) {
        toggleDrawer();
    }
    return true;
}
function jumpToAttribute() {
    toggleAttributeDrawer();
}

function toggleAttributeDrawer() {
    const drawer = document.getElementById('attribute-drawer');
    const info = document.getElementById('attribute-info');
    drawer.classList.toggle('open');
    info.classList.toggle('open');

    if (autoTrainingInterval && autoTrainingTimeout) {
        stopAutoTraining();
    }
    updateAttributePanel();
}

//宠物武装
let armsAttributes = {
    horn: { type: "尖角", value: 0, attributes: ["physicalAttack", "magicAttack", "health", "mana"], url: "https://pic.imgdb.cn/item/666f194ed9c307b7e907bfb2.png", enduranceValue: 500, activated: false, description:'锐利无比的尖角，能轻易刺穿敌人的弱点' },
    fur: { type: "毛皮", value: 0, attributes: ["physicalDefense", "magicDefense", "health"], url: "https://pic.imgdb.cn/item/666f194dd9c307b7e907bf7b.png", enduranceValue: 500, activated: false, description:'手感非凡的护甲之物，能带来不俗的防御能力' },
    fang: { type: "獠牙", value: 0, attributes: ["physicalAttack", "speed", "magicAttack"], url: "https://pic.imgdb.cn/item/666f194dd9c307b7e907bed6.png", enduranceValue: 500, activated: false, description:'上古神兽曾用它噬铁碎骨' },
    claw: { type: "利爪", value: 0, attributes: ["physicalAttack", "speed", "magicAttack", "mana"], url: "https://pic.imgdb.cn/item/666f194dd9c307b7e907be47.png", enduranceValue: 500, activated: false, description:'利爪挥过，血流成河' },
    tailWhip: { type: "尾鞭", value: 0, attributes: ["physicalAttack", "speed", "magicAttack"], url: "https://pic.imgdb.cn/item/666f194cd9c307b7e907bdd1.png", enduranceValue: 500, activated: false, description:'虽不如毒鳌般凌厉，仍有破势之力' },
    husk: { type: "甲壳", value: 0, attributes: ["physicalDefense", "speed", "magicDefense"], url: "https://pic.imgdb.cn/item/667fc40cd9c307b7e941f3bd.png", enduranceValue: 500, activated: false, description:'自然之力形成的坚硬盔甲，可抵敌人中伤' }
};

let armsOpened = false;
        
function refreshAndCheckAllArmsEndurance() {
    // 遍历 armsAttributes 中的所有武器
    Object.keys(armsAttributes).forEach(key => {
        const arm = armsAttributes[key];

        // 检查并设置武器的耐久度，只在未定义或非数字的情况下重置
        if (typeof arm.enduranceValue === 'undefined' || isNaN(arm.enduranceValue)) {
            arm.enduranceValue = 500;
        }

        if (typeof arm.activated === 'undefined' || isNaN(arm.activated)) {
            arm.activated = false;
        }

        if (typeof arm.description === 'undefined' || isNaN(arm.description)) {
            arm.description = '威力不俗的装备，只有神兽能够驾驭，灵力若隐若现，还有待进一步开发';
        }

        // 获取对应的 infoDiv 并更新信息
        const infoDiv = document.querySelector(`.info-${key}`);
        if (infoDiv) {
            updateArmInfoDiv(infoDiv, arm);
        }
        
        if (arm.enduranceValue === 0 && arm.activated !== undefined) {
            arm.activated = false;
        } else if (arm.enduranceValue === 0) {
            arm.activated = flase;
        } else {
            arm.activated = true;
        }
        updateAttributePanel();
    });
}
        
function handlePetArmsClick() {
    //console.log('petArms clicked: armsOpened:', armsOpened); // 调试输出

    if (!armsOpened) {
        openPetArms();
    } else {
        showPetArmsWindow();
        setTimeout(()=>refreshAndCheckAllArmsEndurance(),0);
    }
}

function openPetArms() {
    showInfoBox(
        "武装系统在后期可以为宠物增加随机的二级属性。开启需要花费200两金，是否开启？",
        () => { // onConfirm 回调
            if (goldAmount >= 200000) {
                goldAmount -= 200000;
                showInfoBox("你花费20万文金子（200两），为宠物开启了灵兽武装，现在有更强的能力提升方式了！");
                updateGoldDisplay(goldAmount);
                armsOpened = true;
                //console.log('openPetArms: armsOpened set to true'); // 调试输出
                showPetArmsWindow();
            } else {
                showInfoBox("你的金子不足20万文（200两），无法开启武装系统！");
            }
        },
        () => { // onCancel 回调
        }
    );
}

function showPetArmsWindow() {
    const existingArmsWindow = document.getElementById('petArmsWindow');
    if (existingArmsWindow) {
        existingArmsWindow.remove();
    }

    const newArmsWindow = document.createElement('div');
    newArmsWindow.id = 'petArmsWindow';
    newArmsWindow.style = `position: fixed;
                            top: 50%;
                            left: 50%;
                            display: flex;
                            flex-direction: column;
                            justify-content: space-around;
                            align-items: stretch;
                            transform: translate(-50%, -50%);
                            width: 360px;
                            max-height: 80%;
                            z-index: 1000;
                            overflow-y: auto;
                            border-radius: 2px;
                            color: #92341c;
                            background: #B07638;
                            padding: 2px;
                            box-shadow: inset 0px 0px 3px 1px #92341C;
                            border: 1px solid black;`;
    document.body.appendChild(newArmsWindow);

    const titleContainer = document.createElement('div');
    titleContainer.innerText = '宠物武装';
    titleContainer.style = `padding: 5px;
                            text-align: center;
                            background-image: url(https://pic.imgdb.cn/item/66bf32d9d9c307b7e9995d58.png);
                            background-repeat: repeat;
                            background-size: contain;
                            color: #E3A73B;
                            cursor: pointer;
                            box-shadow: inset 0px 1px 2px 0px #E3A73B;
                            border: 1px solid black;
                            position: relative;`;
    newArmsWindow.appendChild(titleContainer);

    const commonButtonStyle = `border: 1px solid #6F391C;
                               background: linear-gradient(to bottom, #E47F47, #CE6633, #963D1C);
                               box-shadow: inset 0px 0px 2px 1px #87431F;
                               font-size: 12px;
                               border-radius: 5px;
                               color: #F9DE9B;
                               padding: 2px 10px;
                               cursor: pointer;
                               margin: 2px;
                               transition: transform 0.1s, box-shadow 0.1s;`;
    
        
    const topButtonStyle = `position: absolute;
    cursor: pointer;
    font-size: 16px;
    color: white;
    background: linear-gradient(rgb(219, 186, 137), rgb(132, 82, 44), rgb(124, 52, 17), rgb(172, 75, 29), rgb(200, 94, 36));
    width: 25px;
    height: 25px;
    text-align: center;
    border-radius: 2px;
    border: 1px solid rgb(151, 112, 37);
    box-shadow: rgb(50, 28, 12) 0px 0px 0px 1px, rgb(50, 28, 12) 0px 0px 0px 1px inset;
    margin: 2px;`;


    const closeButton = document.createElement('button');
    closeButton.innerText = 'X';
    closeButton.style = `position: fixed;
                        top: 4px;
                        right: 4px;
                        ${topButtonStyle}`;
    closeButton.addEventListener('click', closePetArmsWindow);
    newArmsWindow.appendChild(closeButton);

    const infoButton = document.createElement('button');
    infoButton.innerText = '?';
    infoButton.style = `position: fixed;
                        top: 4px;
                        left: 4px;
                        ${topButtonStyle}`;
    infoButton.addEventListener('click', showInfo);
    newArmsWindow.appendChild(infoButton);

    const armsContent = document.createElement('div');
    armsContent.id = 'petArmsContent';
    armsContent.style = `display: flex;
                        flex-direction: column;
                        gap: 10px;
                        padding: 20px;
                        background-color: #DFBF6E;
                        box-shadow: inset 0px 0px 0px 1px #6f391c;
                        color: black;
                        background-image: url(https://pic.imgdb.cn/item/663885620ea9cb14033e4f6e.png);
                        background-repeat: repeat;
                        background-size: auto;
                        height: 100%;`;
    

    const attributeMap = {
        physicalAttack: '物攻',
        magicAttack: '法攻',
        physicalDefense: '物防',
        magicDefense: '法防',
        speed: '速度',
        health: 'HP',
        mana: 'MP'
    };

    const armKeys = Object.keys(armsAttributes);
    armKeys.forEach((key, index) => {
        const arm = armsAttributes[key];
        const armDiv = document.createElement('div');
        armDiv.className = 'petArms-item';
        armDiv.style = `display: flex;
                        align-items: center;
                        padding: 5px;
                        gap: 5px;
                        border: 1px solid rgba(0, 0, 0, 0.8);
                        flex-direction: row;`;

        const img = document.createElement('img');
        img.src = index === 0 || arm.unlocked ? arm.url : 'https://pic.imgdb.cn/item/666f194bd9c307b7e907ba91.png';
        img.alt = arm.type;
        img.style.width = '45px';
        img.style.height = '45px';
        img.style.border = '1px solid black';
        img.style.cursor = 'pointer';
        img.addEventListener('click', () => {
            if (arm.unlocked) {
                openInlayGemDisplay(key);
            } else {
                showInfoBox('从第二件武装开始，点击武装图标可以进入强化页面，对武装进行强化、升星、镶嵌宝石等操作');
            }
        });

        const infoDiv = document.createElement('div');
        infoDiv.style.flexGrow = '1';
        infoDiv.style.marginLeft = '5px';
        infoDiv.style.fontSize = '14px';
        infoDiv.classList.add(`info-${key}`); // 用于全局更新时的选择器
        
        updateArmInfoDiv(infoDiv, arm); // 显示耐久度信息
        infoDiv.addEventListener('click', () => {
            repairArm(infoDiv, arm, key);
        });
        armDiv.appendChild(infoDiv);

        const buttonContainer = document.createElement('div');
        buttonContainer.style.display = 'flex';
        buttonContainer.style.flexDirection = 'column';
        buttonContainer.style.justifyContent = 'space-around';
        
        const forgeButton = document.createElement('button');
        forgeButton.style = commonButtonStyle;
        buttonContainer.appendChild(forgeButton);  // 将按钮添加到容器中

        const energyForgeButton = document.createElement('button');
        energyForgeButton.innerText = '灵气';
        energyForgeButton.style.display = 'none';
        energyForgeButton.style = commonButtonStyle;
        buttonContainer.appendChild(energyForgeButton);  // 将按钮添加到容器中

        if (index === 0 || arm.unlocked) {
            updateArmInfoDiv(infoDiv, arm, key); // 更新武装信息，包括耐久度
            forgeButton.innerText = '锻造';
            forgeButton.addEventListener('click', () => forgeArm(key, infoDiv));
            energyForgeButton.style.display = 'block';
            energyForgeButton.addEventListener('click', () => energyForgeArm(key, infoDiv));
        } else {
            infoDiv.innerHTML = '<div>？？？</div><div>？？？</div>';
            forgeButton.innerText = '解锁';
            forgeButton.classList.add('locked');
            forgeButton.addEventListener('click', () => unlockArm(index, arm, infoDiv, forgeButton, img, energyForgeButton));
        }

        armDiv.appendChild(img);
        armDiv.appendChild(infoDiv);
        armDiv.appendChild(buttonContainer);
        armsContent.appendChild(armDiv);
    });

    newArmsWindow.appendChild(armsContent);
    refreshAndCheckAllArmsEndurance();
}

function unlockArm(index, arm, infoDiv, forgeButton, img, energyForgeButton) {
    if (isUnlocked(index)) {
        if (!arm.unlocked) {
            showInfoBox(
                "武装系统可以增强宠物的二级属性，如果你拥有原始宠物武装，你可以直接激活一件",
                () => {
                    if (useItem('nativePetArms')) {
                        showInfoBox("您使用一个原始宠物武装，为宠物解锁了一件新的强力装备！");
                        arm.unlocked = true;
                        // 初始化 armState（解锁后才创建）
                        arm.armState = {
                            starLevel: 0, // 初始化星级为0
                            baseValue: 0,
                            gemSlots: {
                                current: 1, // 初始宝石孔数量为1
                                max: 10, // 最多6个宝石孔
                                colors: [randomGemColor()], // 随机初始化第一个宝石孔颜色
                                inlaid: [null], // 初始化未镶嵌状态
                                gemAttribute: { // 初始化所有属性为0
                                    physicalAttack: 0,
                                    magicAttack: 0,
                                    physicalDefense: 0,
                                    magicDefense: 0,
                                    speed: 0,
                                    health: 0,
                                    mana: 0,
                                    endurance: 0,
                                    intelligence: 0,
                                    strength: 0,
                                    agility: 0,
                                    faith: 0
                                }
                            }
                        };
                        img.src = arm.url;
                        showPetArmsWindow();
                        forgeButton.innerText = '锻造';
                        forgeButton.classList.remove('locked');
                        forgeButton.replaceWith(forgeButton.cloneNode(true));
                        forgeButton = infoDiv.nextElementSibling;
                        forgeButton.addEventListener('click', () => forgeArm(Object.keys(armsAttributes)[index], infoDiv));
                        energyForgeButton.style.display = 'block';
                        energyForgeButton.addEventListener('click', () => energyForgeArm(Object.keys(armsAttributes)[index], infoDiv));
                    } else {
                        showInfoBox("道具不足，无法解锁！");
                    }
                },
                () => {}
            );
        } else if (arm.unlocked) {
            showInfoBox("武装已经解锁！");
        } 
    } else {
        showInfoBox("宠物等级不足，无法解锁！");
    }
}

function updateArmInfoDiv(infoDiv, arm, key) {
    let enduranceElement;  // 在函数作用域内声明

    if (arm.enduranceValue <= 200) {
        const enduranceText = `(耐久:${arm.enduranceValue}/500)🔨`;
        enduranceElement = `<span style="cursor:pointer;color:red;" id="endurance-${key}">${enduranceText}</span>`;
    } else {
        const enduranceText = `(耐久:${arm.enduranceValue}/500)`;
        enduranceElement = `<span style="cursor:pointer;" id="endurance-${key}">${enduranceText}</span>`;
    }
    
    const infoText = `增益: + ${arm.value}${translateAttribute(arm.attribute)}`;
    
    // 使用构建的 enduranceElement 和 infoText 更新 infoDiv
    infoDiv.innerHTML = `<div>${arm.type} ${enduranceElement}</div><div>${infoText}</div>`;
}

function repairArm(infoDiv, arm, key) {
    const repairTool = jinnangItems.find(item => item.name === 'blueArmComponents');

    if (arm.enduranceValue >= 500) {
        showInfoBox('当前耐久度充足，不需要修复！',null,null,'red');
        return;
    }
    
    if (repairTool.quantity >= 5) {
        showInfoBox('你将花费5个蓝色武装原料恢复100点耐久度，是否继续？', () => {
            useItem('blueArmComponents',5);
            arm.enduranceValue = Math.min(500, arm.enduranceValue + 100); // 修复耐久度，但不超过500
            refreshAndCheckAllArmsEndurance();
            updateArmInfoDiv(infoDiv, arm, key);
        }, null, 'red');
    } else {
        showInfoBox('你的蓝色武装原料数量不足5个，无法恢复耐久值！',null,null,'red');
    }
    updateAttributePanel();
}
        
// 减少武装的耐久度
function decreaseArmsEndurance(key = null, value) {
    if (key) {
        const arm = armsAttributes[key];
        if (arm.enduranceValue <= 0) {
            arm.enduranceValue = 0;
            
        }
        arm.enduranceValue = Math.max(0, arm.enduranceValue - value);

    } else {
        Object.keys(armsAttributes).forEach(key => {
            const arm = armsAttributes[key];
            if (arm.value !== 0) {
                arm.enduranceValue = Math.max(0, arm.enduranceValue - value);
            }

            if (arm.enduranceValue === 0) {
                logBattleEvent(`${currentPet.name}的${arm.type}已经完全损坏，将无法再提供任何属性增益！`,'red');
            }
        });
    }
    
    refreshAndCheckAllArmsEndurance(); // 刷新所有武装显示信息
    updateAttributePanel();
}

function isUnlocked(index) {
    switch (index) {
        case 1:
            return petLevel >= 60;
        case 2:
            return petLevel >= 100;
        case 3:
            return petLevel >= 149;
        case 4:
            return petLevel >= 160;
        case 5:
            return petLevel >= 180;
        default:
            return false;
    }
}

function closePetArmsWindow() {
    const armsWindow = document.getElementById('petArmsWindow');
    if (armsWindow) {
        armsWindow.style.display = 'none';
    }
}

function forgeArm(key, infoDiv, useGold = true) {
    const gemUI = document.getElementById('inlayGemUI');
    const arm = armsAttributes[key];

    if (gemUI.style.display !== 'none') {
        showInfoBox('请先关闭宝石面板！',null,null,'red');
    }

    if (arm.enduranceValue === 0) {
        showInfoBox("该武装已经完全损坏，将无法再提供任何增益！",null,null,'red');
        return;
    }

    if (arm.type !== '尖角' && arm.armState.starLevel >= 1) {
        showInfoBox('当前武装已经升过星，重新锻造会重置星级');
    }
  
    if (useGold) {
        if (goldAmount < 8000) {
            showInfoBox("金子不足，无法锻造！");
            return;
        }
        goldAmount -= 8000;
        updateGoldDisplay(goldAmount);
    } else {
        if (!useItem('earthlyEnergy', 100)) {
            showInfoBox("您还没有天地灵气，此道具可通过开启武神仙葫或商店购买获得。");
            return;
        }
    }
    const attribute = arm.attributes[Math.floor(Math.random() * arm.attributes.length)];

    let newValue;
    if (useGold) {
        let rand = Math.random();
        if (rand < 0.9) {
            newValue = Math.floor(100 + Math.random() * 0.3 * (
                attribute === "physicalDefense" || attribute === "magicDefense" ? 10888 :
                attribute === "magicAttack" ? 6666 :
                attribute === "speed" ? 3333 :
                attribute === "health" || attribute === "mana" ? 66666 : // 更新生命值和法力值的范围
                7777
            ));
        } else {
            newValue = Math.floor(100 + Math.random() * 0.5 * (
                attribute === "physicalDefense" || attribute === "magicDefense" ? 10888 :
                attribute === "magicAttack" ? 6666 :
                attribute === "speed" ? 3333 :
                attribute === "health" || attribute === "mana" ? 66666 : // 更新生命值和法力值的范围
                7777
            ));
        }
    } else {
        const maxRanges = {
            physicalDefense: 10888,
            magicDefense: 10888,
            magicAttack: 6666,
            speed: 3333,
            health: 66666,
            mana: 66666,
            default: 7777
        };

        const maxRange = maxRanges[attribute] || maxRanges.default;

        const minValue = 100 + 0.8 * maxRange;  // 80% 的极值
        const maxValue = 100 + maxRange;        // 100% 的极值

        newValue = Math.floor(minValue + Math.random() * (maxValue - minValue));
    }

    arm.value = newValue;
    arm.attribute = attribute;
    
    if (arm.armState && typeof arm.armState.starLevel === 'number') {
        arm.armState.starLevel = 0;
    } else {
        // 如果 armState 或 starLevel 无效，可以初始化或其他操作
        if (!arm.armState) {
            arm.armState = {
                starLevel: 0,
                baseValue: 0,
                gemSlots: {
                    current: 1,
                    max: 10,
                    colors: [randomGemColor()],
                    inlaid: [null]
                }
            };
        }
    }

    const attributeMap = {
        physicalAttack: '物攻',
        magicAttack: '法攻',
        physicalDefense: '物防',
        magicDefense: '法防',
        speed: '速度',
        health: 'HP',
        mana: 'MP'
    };

    const attributeNameInChinese = attributeMap[arm.attribute];

    arm.forgedInfo = `增益: ${arm.value} ${attributeNameInChinese}`; // 保存锻造后的增益信息
    arm.armState.baseValue = arm.value;

    infoDiv.innerHTML = `<div>${arm.type}</div><div>${arm.forgedInfo}</div>`;
    updateSkillScore();
    updateTitle();
    updateAttributePanel();
    decreaseArmsEndurance(key, 10); // 只减少特定武装的耐久度
    updateArmInfoDiv(infoDiv, arm); // 更新展示
}
// 使用金子锻造
function goldForgeArm(key, infoDiv) {
    forgeArm(key, infoDiv, true);
}
// 使用天地灵气锻造
function energyForgeArm(key, infoDiv) {
    forgeArm(key, infoDiv, false); // 调用锻造函数
}

function lockArms() {
    const armKeys = Object.keys(armsAttributes);
    armKeys.forEach((key, index) => {
        if (index > 0) {
            armsAttributes[key].unlocked = false;
            armsAttributes[key].activated = false;
        }
    });
    armsOpened = false;
    //console.log('All arms are now locked.');
}

function removeArmsAttributes() {
    const armKeys = Object.keys(armsAttributes);
    armKeys.forEach(key => {
        armsAttributes[key].value = 0;
        armsAttributes[key].attribute = null;
        armsAttributes[key].forgedInfo = null;
    });
    //console.log('All arms attributes have been reset to zero.');
}

// 计算所有宝石提供的属性
function calculateGemAttributes() {
    let gemAttributeMessage = {};

    // 遍历 armsAttributes 对象
    Object.keys(armsAttributes).forEach(key => {
        const arm = armsAttributes[key];

        // 检查 armState 和 gemSlots 是否存在
        if (arm.armState && arm.armState.gemSlots && arm.armState.gemSlots.gemAttribute) {
            const gemAttributes = arm.armState.gemSlots.gemAttribute;

            // 累加每个宝石的属性值
            Object.keys(gemAttributes).forEach(gemAttr => {
                const gemAttrValue = gemAttributes[gemAttr] != null ? gemAttributes[gemAttr] : 0;
                if (gemAttributeMessage[gemAttr]) {
                    gemAttributeMessage[gemAttr] += gemAttrValue; // 累加宝石属性值
                } else {
                    gemAttributeMessage[gemAttr] = gemAttrValue;
                }
            });
        }
    });

    return gemAttributeMessage;
}

// 显示武装和宝石属性的总和
function showInfo() {
    // 初始化累加后的信息对象
    let armAttributeMessage = {};

    // 遍历 armsAttributes 对象
    Object.keys(armsAttributes).forEach(key => {
        const arm = armsAttributes[key];

        // 获取属性名和属性值
        const attribute = arm.attribute; // 这是一个字符串，例如 'magicAttack'
        const value = arm.value != null ? arm.value : 0;

        // 如果属性名存在，累加其值
        if (attribute) {
            if (armAttributeMessage[attribute]) {
                armAttributeMessage[attribute] += value;
            } else {
                armAttributeMessage[attribute] = value;
            }
        }
    });

    // 计算宝石属性并将其累加到 armAttributeMessage 中
    const gemAttributes = calculateGemAttributes();
    Object.keys(gemAttributes).forEach(attr => {
        if (armAttributeMessage[attr]) {
            armAttributeMessage[attr] += gemAttributes[attr]; // 累加宝石属性到相同类别的武装属性中
        } else {
            armAttributeMessage[attr] = gemAttributes[attr]; // 初始化新的属性
        }
    });

    // 属性名映射表
    const nameMap = new Map([
        ['health', '生命值'],
        ['magicAttack', '法术攻击'],
        ['magicDefense', '法术防御'],
        ['mana', '法力值'],
        ['physicalAttack', '物理攻击'],
        ['physicalDefense', '物理防御'],
        ['speed', '速度'],
        ['endurance', '耐力'],
        ['intelligence', '智力'],
        ['agility', '敏捷'],
        ['strength', '强壮'],
        ['faith', '信仰']
    ]);

    // 将累加后的信息转换为数组形式，并映射中文名称，同时过滤掉值为 0 的属性
    let armAttributeMessageArray = Object.entries(armAttributeMessage)
        .filter(([attribute, value]) => value !== 0)  // 过滤掉值为 0 的属性
        .map(([attribute, value]) => {
            const translatedAttribute = nameMap.get(attribute) || attribute; // 若无映射，返回原始属性名
            return `${translatedAttribute}: ${value}`;
        });

    // 将数组转换为字符串，方便显示
    const armAttributesString = armAttributeMessageArray.join('\n');

    // 显示信息
    const message = `
当前武装属性（包含宝石）：
${armAttributesString}

武装系统功能和操作说明：
1. 武装是宠物的装备系统，需要由原料打造得来
2. 生成武装后，可以通过锻造随机提升宠物的各项属性
3. 除金子锻造外，还可以每次使用100个“天地灵气”进行附魔（提升更多的属性）。
4. 生成武装需要消耗一个原始宠物武装，你可以通过宝箱等渠道获得它的必要原材料。
5. 锻造、战斗等事件会消耗武装的耐久，耐久为0时，将不再提供任何增益
6. 玩家可以使用一定数量的蓝色武装原料进行修复
7. 不同宠物的武装不通用，出售宠物后也会丢失武装，请知悉
`;

    showInfoBox(message);
}


function closeInlayGemDisplay() {
    const gemUI = document.getElementById('inlayGemUI');
    gemUI.style.display = 'none'; // 显示镶嵌界面
    currentKey = null;
}


const gemData = [
        { color: 'pink', level: 7, name: '天寿石', attribute: 'endurance', value: 233 },
        { color: 'pink', level: 7, name: '天机石', attribute: 'intelligence', value: 233 },
        { color: 'pink', level: 7, name: '天猛石', attribute: 'strength', value: 233 },
        { color: 'pink', level: 7, name: '天佑石', attribute: 'faith', value: 233 },
        { color: 'pink', level: 7, name: '天速石', attribute: 'agility', value: 233 },
        { color: 'pink', level: 6, name: '天寿石', attribute: 'endurance', value: 179 },
        { color: 'pink', level: 6, name: '天机石', attribute: 'intelligence', value: 179 },
        { color: 'pink', level: 6, name: '天猛石', attribute: 'strength', value: 179 },
        { color: 'pink', level: 6, name: '天佑石', attribute: 'faith', value: 179 },
        { color: 'pink', level: 6, name: '天速石', attribute: 'agility', value: 179 },
        { color: 'pink', level: 5, name: '天寿石', attribute: 'endurance', value: 119 },
        { color: 'pink', level: 5, name: '天机石', attribute: 'intelligence', value: 119 },
        { color: 'pink', level: 5, name: '天猛石', attribute: 'strength', value: 119 },
        { color: 'pink', level: 5, name: '天佑石', attribute: 'faith', value: 119 },
        { color: 'pink', level: 5, name: '天速石', attribute: 'agility', value: 119 },
        { color: 'pink', level: 4, name: '天寿石', attribute: 'endurance', value: 66 },
        { color: 'pink', level: 4, name: '天机石', attribute: 'intelligence', value: 66 },
        { color: 'pink', level: 4, name: '天猛石', attribute: 'strength', value: 66 },
        { color: 'pink', level: 4, name: '天佑石', attribute: 'faith', value: 66 },
        { color: 'pink', level: 4, name: '天速石', attribute: 'agility', value: 66 },
        { color: 'pink', level: 3, name: '天寿石', attribute: 'endurance', value: 33 },
        { color: 'pink', level: 3, name: '天机石', attribute: 'intelligence', value: 33 },
        { color: 'pink', level: 3, name: '天猛石', attribute: 'strength', value: 33 },
        { color: 'pink', level: 3, name: '天佑石', attribute: 'faith', value: 33 },
        { color: 'pink', level: 3, name: '天速石', attribute: 'agility', value: 33 },
        { color: 'pink', level: 2, name: '天寿石', attribute: 'endurance', value: 17 },
        { color: 'pink', level: 2, name: '天机石', attribute: 'intelligence', value: 17 },
        { color: 'pink', level: 2, name: '天猛石', attribute: 'strength', value: 17 },
        { color: 'pink', level: 2, name: '天佑石', attribute: 'faith', value: 17 },
        { color: 'pink', level: 2, name: '天速石', attribute: 'agility', value: 17 },
        { color: 'pink', level: 1, name: '天寿石', attribute: 'endurance', value: 9 },
        { color: 'pink', level: 1, name: '天机石', attribute: 'intelligence', value: 9 },
        { color: 'pink', level: 1, name: '天猛石', attribute: 'strength', value: 9 },
        { color: 'pink', level: 1, name: '天佑石', attribute: 'faith', value: 9 },
        { color: 'pink', level: 1, name: '天速石', attribute: 'agility', value: 9 },
        { color: 'purple', level: 7, name: '天损石', attribute: 'physicalAttack', value: 772 },
        { color: 'purple', level: 7, name: '天勇石', attribute: 'magicAttack', value: 772 },
        { color: 'purple', level: 6, name: '天损石', attribute: 'physicalAttack', value: 594 },
        { color: 'purple', level: 6, name: '天勇石', attribute: 'magicAttack', value: 594 },
        { color: 'purple', level: 5, name: '天损石', attribute: 'physicalAttack', value: 396 },
        { color: 'purple', level: 5, name: '天勇石', attribute: 'magicAttack', value: 396 },
        { color: 'purple', level: 4, name: '天损石', attribute: 'physicalAttack', value: 220 },
        { color: 'purple', level: 4, name: '天勇石', attribute: 'magicAttack', value: 220 },
        { color: 'purple', level: 3, name: '天损石', attribute: 'physicalAttack', value: 110 },
        { color: 'purple', level: 3, name: '天勇石', attribute: 'magicAttack', value: 110 },
        { color: 'purple', level: 2, name: '天损石', attribute: 'physicalAttack', value: 55 },
        { color: 'purple', level: 2, name: '天勇石', attribute: 'magicAttack', value: 55 },
        { color: 'purple', level: 1, name: '天损石', attribute: 'physicalAttack', value: 28 },
        { color: 'purple', level: 1, name: '天勇石', attribute: 'magicAttack', value: 28 },
        { color: 'yellow', level: 7, name: '天英石', attribute: 'speed', value: 330 },
        { color: 'yellow', level: 7, name: '天贵石', attribute: 'health', value: 1564 },
        { color: 'yellow', level: 7, name: '天满石', attribute: 'mana', value: 1564 },
        { color: 'yellow', level: 6, name: '天英石', attribute: 'speed', value: 264 },
        { color: 'yellow', level: 6, name: '天贵石', attribute: 'health', value: 1264 },
        { color: 'yellow', level: 6, name: '天满石', attribute: 'mana', value: 1264 },
        { color: 'yellow', level: 5, name: '天英石', attribute: 'speed', value: 198 },
        { color: 'yellow', level: 5, name: '天贵石', attribute: 'health', value: 964 },
        { color: 'yellow', level: 5, name: '天满石', attribute: 'mana', value: 964 },
        { color: 'yellow', level: 4, name: '天英石', attribute: 'speed', value: 165 },
        { color: 'yellow', level: 4, name: '天贵石', attribute: 'health', value: 824 },
        { color: 'yellow', level: 4, name: '天满石', attribute: 'mana', value: 824 },
        { color: 'yellow', level: 3, name: '天英石', attribute: 'speed', value: 132 },
        { color: 'yellow', level: 3, name: '天贵石', attribute: 'health', value: 632 },
        { color: 'yellow', level: 3, name: '天满石', attribute: 'mana', value: 632 },
        { color: 'yellow', level: 2, name: '天英石', attribute: 'speed', value: 66 },
        { color: 'yellow', level: 2, name: '天贵石', attribute: 'health', value: 482 },
        { color: 'yellow', level: 2, name: '天满石', attribute: 'mana', value: 482 },
        { color: 'yellow', level: 1, name: '天英石', attribute: 'speed', value: 33 },
        { color: 'yellow', level: 1, name: '天贵石', attribute: 'health', value: 232 },
        { color: 'yellow', level: 1, name: '天满石', attribute: 'mana', value: 232 },
        { color: 'blue', level: 7, name: '天拜石', attribute: 'physicalDefense', value: 728 },
        { color: 'blue', level: 7, name: '天退石', attribute: 'magicDefense', value: 728 },
        { color: 'blue', level: 6, name: '天拜石', attribute: 'physicalDefense', value: 560 },
        { color: 'blue', level: 6, name: '天退石', attribute: 'magicDefense', value: 560 },
        { color: 'blue', level: 5, name: '天拜石', attribute: 'physicalDefense', value: 280 },
        { color: 'blue', level: 5, name: '天退石', attribute: 'magicDefense', value: 280 },
        { color: 'blue', level: 4, name: '天拜石', attribute: 'physicalDefense', value: 140 },
        { color: 'blue', level: 4, name: '天退石', attribute: 'magicDefense', value: 140 },
        { color: 'blue', level: 3, name: '天拜石', attribute: 'physicalDefense', value: 70 },
        { color: 'blue', level: 3, name: '天退石', attribute: 'magicDefense', value: 70 },
        { color: 'blue', level: 2, name: '天拜石', attribute: 'physicalDefense', value: 35 },
        { color: 'blue', level: 2, name: '天退石', attribute: 'magicDefense', value: 35 },
        { color: 'blue', level: 1, name: '天拜石', attribute: 'physicalDefense', value: 18 },
        { color: 'blue', level: 1, name: '天退石', attribute: 'magicDefense', value: 18 }
    ];
//生成宝石的函数
function generateGemToJinnang(color, level, name, attribute, value, quantity = 1) {
    // 颜色映射
    const colorMap = {
        'yellow': '鹅黄色',
        'pink': '粉红色',
        'blue': '天蓝色',
        'purple': '淡紫色'
    };

    // 等级映射
    const levelMap = {
        1: '一级',
        2: '二级',
        3: '三级',
        4: '四级',
        5: '五级',
        6: '六级',
        7: '七级'
    };

    // 属性映射
    const attributeMap = {
        physicalAttack: '物理攻击',
        magicAttack: '法术攻击',
        physicalDefense: '物理防御',
        magicDefense: '法术防御',
        speed: '速度',
        health: '生命',
        mana: '法力',
        endurance: '耐力',
        intelligence: '智力',
        strength: '强壮',
        agility: '敏捷',
        faith: '信仰'
    };

    // 图片 URL 映射（根据颜色和等级映射不同的图片）
    const imgUrlMap = {
        'pink_1': 'https://pic.imgdb.cn/item/66d9e89bd9c307b7e93b5c14.png',
        'pink_2': 'https://pic.imgdb.cn/item/66db0468d9c307b7e9895fc7.png',
        'pink_3': 'https://pic.imgdb.cn/item/66d9e814d9c307b7e93afc59.png',
        'pink_4': 'https://pic.imgdb.cn/item/66dab4f5d9c307b7e917470a.png',
        'pink_5': 'https://pic.imgdb.cn/item/66dab344d9c307b7e915e434.png',
        'pink_6': 'https://pic.imgdb.cn/item/66d9e814d9c307b7e93afc0d.png',
        'pink_7': 'https://pic.imgdb.cn/item/66d9e814d9c307b7e93afc29.png',
        'purple_1': 'https://pic.imgdb.cn/item/66dab5fbd9c307b7e9182384.png',
        'purple_2': 'https://pic.imgdb.cn/item/66db0468d9c307b7e9895fc0.png',
        'purple_3': 'https://pic.imgdb.cn/item/66d9e814d9c307b7e93afc4c.png',
        'purple_4': 'https://pic.imgdb.cn/item/66db0038d9c307b7e980b9ad.png',
        'purple_5': 'https://pic.imgdb.cn/item/66dab2d4d9c307b7e9157e85.png',
        'purple_6': 'https://pic.imgdb.cn/item/66d9e814d9c307b7e93afc21.png',
        'purple_7': 'https://pic.imgdb.cn/item/66db062fd9c307b7e98aeddb.png',
        'yellow_1': 'https://pic.imgdb.cn/item/66d9e89bd9c307b7e93b5c08.png',
        'yellow_2': 'https://pic.imgdb.cn/item/66db0468d9c307b7e9895fe9.png',
        'yellow_3': 'https://pic.imgdb.cn/item/66d9e814d9c307b7e93afc35.png',
        'yellow_4': 'https://pic.imgdb.cn/item/66dab660d9c307b7e9187d69.png',
        'yellow_5': 'https://pic.imgdb.cn/item/66dab47dd9c307b7e916e88c.png',
        'yellow_6': 'https://pic.imgdb.cn/item/66dab404d9c307b7e9167df8.png',
        'yellow_7': 'https://pic.imgdb.cn/item/66db0469d9c307b7e9895ffb.png',
        'blue_1': 'https://pic.imgdb.cn/item/66db093dd9c307b7e98dad0d.png',
        'blue_2': 'https://pic.imgdb.cn/item/66db0468d9c307b7e9895fd1.png',
        'blue_3': 'https://pic.imgdb.cn/item/66d9e814d9c307b7e93afc41.png',
        'blue_4': 'https://pic.imgdb.cn/item/66dbff9dd9c307b7e9b7919f.png',
        'blue_5': 'https://pic.imgdb.cn/item/66db0b52d9c307b7e9914fba.png',
        'blue_6': 'https://pic.imgdb.cn/item/66db0b52d9c307b7e9914f8e.png',
        'blue_7': 'https://pic.imgdb.cn/item/66db0b52d9c307b7e9914f63.png'
    };

    // 生成宝石的唯一名称 (格式: colorGem_attribute_value)
    const gemName = `${color}Gem_${attribute}_${value}`;

    // 宝石显示的名称 (格式: 等级+name，例如: "一级天寿石")
    const displayName = `${levelMap[level]}${name}`;

    // 获取图片 URL
    const imgUrlKey = `${color}_${level}`;
    const imgUrl = imgUrlMap[imgUrlKey] || 'https://pic.imgdb.cn/item/66d9e814d9c307b7e93afc59.png';  // 默认 URL

    // 生成描述信息
    let description = `${levelMap[level]}${name}，用于镶嵌在${colorMap[color]}宝石孔，可提供${value}点${attributeMap[attribute]}`;

    // 调用现有的函数生成宝石 item
    generateItemToJinnang(gemName, displayName, imgUrl, 500, quantity, description);
    // 示例调用: generateGemToJinnang('pink', 1, '天寿石', 'endurance', 7, 1); 
}

function getGem(color = null, level = null, name = null, attribute = null, value = null, quantity = null) {
    // 根据传入的参数进行筛选
    let filteredGems = gemData.filter(gem => {
        return (color === null || gem.color === color) &&
               (level === null || gem.level === parseInt(level)) &&
               (name === null || gem.name === name) &&
               (attribute === null || gem.attribute === attribute) &&
               (value === null || gem.value === parseInt(value));
    });

    // 如果没有传入数量参数，默认生成 1~2 个宝石
    const numGemsToGenerate = quantity ? parseInt(quantity) : Math.floor(Math.random() * 2) + 1;

    // 如果筛选出的宝石数量不足，提示信息并返回
    if (filteredGems.length === 0) {
        showInfoBox('没有符合条件的宝石');
        return;
    }

    // 随机选择宝石
    const shuffledGems = filteredGems.sort(() => 0.5 - Math.random()); // 随机排序
    const gemsToGenerate = shuffledGems.slice(0, numGemsToGenerate); // 返回前 numGems 个

    // 执行生成宝石
    gemsToGenerate.forEach(gem => {
        generateGemToJinnang(gem.color, gem.level, gem.name, gem.attribute, gem.value, 1);
    });

    // 生成简洁的提示信息
    const gemNames = gemsToGenerate.map(gem => `${gem.level}级${gem.name}`);
    const gemMessage = gemNames.join('，'); // 使用逗号隔开
    showInfoBox(`你获得了${gemMessage}`);
}
      
        
// 打开镶嵌宝石界面，动态根据传入的 key 显示指定装备的镶嵌界面
let currentKey = null; // 全局变量用于存储当前的 key

// 打开镶嵌宝石界面
function openInlayGemDisplay(key) {
    const arm = armsAttributes[key];
    if (!arm) {
        showInfoBox("该装备不存在！");
        return;
    }

    // 检查装备是否解锁
    if (!arm.unlocked) {
        showInfoBox("装备未解锁！");
        return;
    }

    currentKey = key;

    // 显示装备的 UI 信息
    const gemUI = document.getElementById('inlayGemUI');
    gemUI.style.display = 'block';

    // 根据星级数显示相应数量的星星
    const starDisplay = '⭐️'.repeat(arm.armState.starLevel || 0);

    // 更新星级显示为星星符号
    document.getElementById('starLevel').innerText = starDisplay;

    if (arm.armState.starLevel >= 13) {
        document.getElementById('upgradeStarBtn').style.display = 'none';
    } else {
        document.getElementById('upgradeStarBtn').style.display = 'block';
    }

    // 更新基础属性显示
    document.getElementById('baseAttribute').innerText = `+ ${Math.floor(arm.value)} ${translateAttribute(arm.attribute)}`;
    document.getElementById('zhuang-bei').src = `${arm.url}`;
    document.getElementById('arm-description').innerText = arm.description || '威力不俗的装备，尚有开发空间';
    document.getElementById('arm-name').innerText = `光芒的灵兽${arm.type}（神品）`;
    document.getElementById('gem-slots-number').innerText = `当前孔数/最大孔数:${arm.armState.gemSlots.current}/${arm.armState.gemSlots.max}`;
    document.getElementById('endurance-display').innerText = `${arm.enduranceValue}`;
    document.getElementById('arm-type-display').innerText = `${arm.type}`;

    // 显示当前宝石孔状态
    displayGemSlots(arm);
}


// 显示当前宝石孔状态
function displayGemSlots(arm) {
    for (let i = 0; i < 10; i++) {
        const slotElement = document.getElementById(`slot${i + 1}`);

        if (i < arm.armState.gemSlots.current) {
            slotElement.parentElement.style.display = 'block'; // 显示该槽位
            const gemSlotColor = arm.armState.gemSlots.colors[i];
            const inlaid = arm.armState.gemSlots.inlaid[i];

            if (inlaid) {
                // 已镶嵌宝石时，显示实心圆和宝石信息，保持 class="slot"
                slotElement.innerHTML = `<span style="color:${gemSlotColor};">●</span> ${inlaid.displayName}${translateGem(inlaid.name)}`;
            } else {
                // 未镶嵌宝石时，显示空心圆和“空”，保持 class="slot"
                slotElement.innerHTML = `<span style="color:${gemSlotColor};">〇 ${translateColor(gemSlotColor)}宝石孔</span>`;
            }
            slotElement.classList.add('slot'); // 确保 slotElement 仍然有 class="slot"
        } else {
            slotElement.parentElement.style.display = 'none'; // 隐藏未解锁的槽位
        }
    }
    document.getElementById('gem-slots-number').innerText = `当前孔数/最大孔数:${arm.armState.gemSlots.current}/${arm.armState.gemSlots.max}`;
}


function updateGemSlotDisplay(arm, gem, slotIndex) {
    const slotElement = document.getElementById(`slot${slotIndex + 1}`);
    const gemSlotColor = arm.armState.gemSlots.colors[slotIndex];
    const slotsDetail = document.getElementById('button-detail');

    // 检查传入的 arm 中的 gemSlots.inlaid 数组
    const inlaidSlotsNums = arm.armState.gemSlots.inlaid
        .filter(slot => slot === null || slot.length === 0) // 筛选出未镶嵌的孔
        .length;
    console.log(inlaidSlotsNums);

    // 根据未镶嵌的孔位数量调整 slotsDetail 的显示状态
    if (inlaidSlotsNums === 0) {
        slotsDetail.style.display = 'none';
    } else {
        slotsDetail.style.display = 'flex';
    }

    if (gem) {
        // 有宝石镶嵌，显示实心圆和宝石信息
        slotElement.innerHTML = `<span style="color:${gemSlotColor};">●</span> ${gem.displayName}${translateGem(gem.name)}`;
    } else {
        // 没有宝石，显示空心圆和宝石孔信息
        slotElement.innerHTML = `<span style="color:${gemSlotColor};">〇 ${translateColor(gemSlotColor)}宝石孔</span>`;
    }
    slotElement.classList.add('slot');  // 确保 slotElement 仍然有 class="slot"
}

// 随机生成宝石孔颜色
function randomGemColor() {
    const colors = ["yellow", "blue", "pink", "purple"];
    const probabilities = [0.4, 0.4, 0.1, 0.1]; // 各种颜色的概率
    const randomValue = Math.random();
    let cumulativeProbability = 0;
    for (let i = 0; i < colors.length; i++) {
        cumulativeProbability += probabilities[i];
        if (randomValue < cumulativeProbability) {
            return colors[i];
        }
    }
    return colors[0]; // 默认返回黄色
}

// 刷新宝石孔颜色
function refreshGemSlots(arm) {
    const refreshItem = jinnangItems.find(item => item.name === 'refreshGemSlot');
    const inlaidGems = arm.armState.gemSlots.inlaid;
    const inlaidNums = inlaidGems.filter(gem => gem !== null).length; //find语法只能返回在数组中找到的第一个对象，而filter可以找到所有符合条件的对象
    const availableSlots = arm.armState.gemSlots.current - inlaidNums;
    
    if (refreshItem.quantity < availableSlots) {
        showInfoBox('你没有足够的宝石洗孔符！洗孔符的单次消耗数量与可镶嵌孔数一致，请注意消耗。', null, null, 'red');
        return;
    }

    let hasRefreshed = false; // 用于记录是否有孔位被刷新
    
    arm.armState.gemSlots.colors.forEach((color, index) => {
        // 仅刷新未镶嵌的孔
        if (!arm.armState.gemSlots.inlaid[index] || arm.armState.gemSlots.inlaid[index].length === 0) {
            useItem('refreshGemSlot', 1);
            
            let newColor;
            do {
                newColor = randomGemColor();
                const colorCount = arm.armState.gemSlots.colors.filter(c => c === newColor).length;
                if (colorCount < 5) {
                    break;
                }
            } while (true);
            
            arm.armState.gemSlots.colors[index] = newColor;
            hasRefreshed = true; // 标记至少有一个孔位被刷新
        }
    });

    if (!hasRefreshed) {
        showInfoBox('当前没有可镶嵌的孔进行刷新！', null, null, 'red');
    } else {
        showInfoBox(`你消耗了${availableSlots}个宝石洗孔符，更新了目前所有可镶嵌孔的颜色！`);
    }

    displayGemSlots(arm); // 刷新界面显示
}

// 打孔操作
function punchHole(arm) {
    if (arm.armState.gemSlots.current >= arm.armState.gemSlots.max) {
        showInfoBox("宝石孔已达到最大数量！");
        return;
    }

    const punchItem = jinnangItems.find(item => item.name === 'punchHoleTool');
    if (punchItem.quantity <= 0) {
        showInfoBox('你没有打孔工具，开孔失败',null,null,'red');
        return;
    }
    
    useItem('punchHoleTool',1);

    // 增加一个宝石孔
    arm.armState.gemSlots.current += 1;
    arm.armState.gemSlots.colors.push(randomGemColor());
    arm.armState.gemSlots.inlaid.push(null);  // 初始化未镶嵌
    showInfoBox('消耗一个任意打孔器，成功开启一个孔位');

    displayGemSlots(arm);  // 刷新界面显示
}

// 合成宝石
function mergeGem(fullName, refreshCallback = null) {
    const levelMap = {
        '一': 1,
        '二': 2,
        '三': 3,
        '四': 4,
        '五': 5,
        '六': 6,
        '七': 7
    };

    const gemLevelChinese = fullName.split('级')[0];  // 获取宝石的汉字等级，比如 '二'
    const gemLevel = levelMap[gemLevelChinese];  // 转换为数字等级
    const gemName = fullName.split('级')[1];  // 获取宝石的名称，比如 '天寿石'

    // 检查合成符文的数量
    const mergeAmuletItem = jinnangItems.find(item => item.name === 'mergeAmulet' && item.quantity > 0);
    const mergeAmuletPlusItem = jinnangItems.find(item => item.name === 'mergeAmuletPlus' && item.quantity > 0);

    if (!gemLevel) {
        showInfoBox('无法识别宝石的等级。');
        return;
    }

    const currentGem = gemData.find(gem => gem.name === gemName && gem.level === gemLevel);
    if (!currentGem) {
        showInfoBox('未找到可合成的宝石，或者宝石已经达到最高等级。');
        return;
    }

    const nextGem = gemData.find(gem => gem.name === gemName && gem.level === gemLevel + 1);
    if (!nextGem) {
        showInfoBox('该宝石已经达到最高等级，无法继续合成。');
        return;
    }

    const currentGemItem = jinnangItems.find(item => item.displayName === fullName);
    if (!currentGemItem || currentGemItem.quantity < 3) {
        showInfoBox('你没有足够的宝石进行合成，需要3个同级别的宝石。');
        return;
    }

    // 合成 1~3 级的宝石时使用 mergeAmuletItem
    if (gemLevel >= 1 && gemLevel <= 3) {
        if (!mergeAmuletItem) {
            showInfoBox('你没有足够的低级宝石合成符。');
            return;
        }
        useItem('mergeAmulet', 1); // 使用1个合成符文
    } 
    // 合成 4~6 级的宝石时使用 mergeAmuletPlusItem
    else if (gemLevel >= 4 && gemLevel <= 6) {
        if (!mergeAmuletPlusItem) {
            showInfoBox('你没有足够的高级宝石合成符。');
            return;
        }
        useItem('mergeAmuletPlus', 1); // 使用1个高级合成符文
    }

    // 扣除3个当前宝石
    useItem(currentGemItem.name, 3);

    // 生成新宝石
    generateGemToJinnang(nextGem.color, nextGem.level, nextGem.name, nextGem.attribute, nextGem.value, 1);

    // 显示合成成功的提示
    showInfoBox(`成功合成了一颗${nextGem.level}级${nextGem.name}！`);

    // 合成成功后调用刷新函数
    if (refreshCallback) {
        refreshCallback();
    }
}


// 处理镶嵌宝石逻辑
function handleGemInlay(arm, slotIndex) {
    const gemSlotColor = arm.armState.gemSlots.colors[slotIndex];

    // 移除之前可能存在的 gemSelectionDiv，防止重复叠加
    const existingGemSelectionDiv = document.getElementById('gemSelectionDiv');
    if (existingGemSelectionDiv) {
        existingGemSelectionDiv.remove();
    }

    // 创建并展示可用宝石，供玩家选择镶嵌
    const gemSelectionDiv = document.createElement('div');
    gemSelectionDiv.id = 'gemSelectionDiv';
    gemSelectionDiv.style = 'background-color: #6f391c;display: flex;flex-flow: column;align-items: center;width: 95%;box-shadow: inset rgb(111, 57, 28) 0px 0px 2px 1px;max-height: 480px;position: fixed;top: 50%;left: 50%;transform: translate(-50%, -50%);border: 1px solid black;font-size: 14px;flex-direction: column;justify-content: flex-start;padding: 2px;';

    const cancelInlayBtn = document.createElement('button');
    cancelInlayBtn.innerText = '关闭面板';
    cancelInlayBtn.style = 'display: flex;gap: 5px;align-items: center;justify-content: center;padding: 5px;text-align: center;background-image: url(https://pic.imgdb.cn/item/66bf32d9d9c307b7e9995d58.png);background-repeat: repeat;background-size: contain;color: rgb(227, 167, 59);cursor: pointer;box-shadow: rgb(227, 167, 59) 0px 1px 2px 0px inset;border: 1px solid black;position: relative;font-size: 16px; width:100%;';
    cancelInlayBtn.addEventListener('click', function() {
        gemSelectionDiv.remove();
    });
    gemSelectionDiv.appendChild(cancelInlayBtn);

    // 创建容器包裹每个 gemDetailContainer
    const gemContainer = document.createElement('div');
    gemContainer.style = 'overflow-y: scroll;width: 99%;display: flex;flex-direction: column;background-image: url(https://pic.imgdb.cn/item/663885620ea9cb14033e4f6e.png);background-repeat: repeat;background-size: auto;';
    gemSelectionDiv.appendChild(gemContainer); // 只需添加一次 gemContainer

    // 刷新宝石显示内容的函数
    const refreshGemSelection = () => {
        // 清空现有的宝石列表
        gemContainer.innerHTML = '';

        const availableGems = jinnangItems.filter(item => item.name.includes(`${gemSlotColor}Gem`) && item.quantity > 0);
        

        if (availableGems.length === 0) {
            showInfoBox("没有可用的宝石！");
            return;
        }

        availableGems.forEach(gem => {
            // 创建每个宝石的容器
            const gemDetailContainer = document.createElement('div');
            gemDetailContainer.style = 'display: flex;flex-direction: row;align-items: center;width: 100%;justify-content: space-between;border-bottom: 1px solid rgb(135, 67, 31);background-image: url(https://pic.imgdb.cn/item/663885620ea9cb14033e4f6e.png);background-repeat: repeat;background-size: auto;height: 100%;'; // 确保内容居中对齐

            const gemIcon = document.createElement('img');
            gemIcon.src = gem.url;
            gemIcon.style = 'width: 45px;height: 45px;margin-right: 10px;border: 1px solid black;margin-left: 5px;';
            gemDetailContainer.appendChild(gemIcon);

            const gemInfo = document.createElement('span');
            const gemQuantity = gem.quantity;
            gemInfo.innerText = `${gem.displayName}${translateGem(gem.name)}(${gemQuantity})`;
            gemDetailContainer.appendChild(gemInfo);

            const gemButtonContainer = document.createElement('div');
            gemButtonContainer.style = 'display: flex;gap: 5px;flex-direction: column;padding: 5px;';
            
            // 添加镶嵌按钮
            const inlayButton = document.createElement('button');
            inlayButton.innerText = '镶嵌';
            inlayButton.style = 'border: 1px solid rgb(111, 57, 28);background: linear-gradient(rgb(228, 127, 71), rgb(206, 102, 51), rgb(150, 61, 28));box-shadow: rgb(135, 67, 31) 0px 0px 2px 1px inset;font-size: 12px;border-radius: 5px;color: rgb(249, 222, 155);padding: 2px 10px;cursor: pointer;transition: transform 0.1s, box-shadow 0.1s;';
            inlayButton.addEventListener('click', function() {
                const inlayAmuletItem = jinnangItems.find(item => item.name === 'inlayAmulet');
                if (inlayAmuletItem.quantity <= 0) {
                    showInfoBox('你没有镶嵌符文，无法进行镶嵌', null, null, 'red');
                    return;
                }
                useItem('inlayAmulet', 1); // 使用镶嵌符文
                useItem(`${gem.name}`, 1);  // 扣除一个宝石
                
                applyGemBonus(arm, gem, slotIndex); // 应用宝石增益
                updateGemSlotDisplay(arm, gem, slotIndex); // 更新界面
                gemSelectionDiv.remove(); // 移除宝石详情
            });
            gemButtonContainer.appendChild(inlayButton);

            // 添加合成按钮
            const mergeButton = document.createElement('button');
            mergeButton.innerText = '合成';
            mergeButton.style = 'border: 1px solid rgb(111, 57, 28);background: linear-gradient(rgb(60, 120, 200), rgb(40, 90, 150), rgb(30, 70, 120));box-shadow: rgb(60, 120, 200) 0px 0px 2px 1px inset;font-size: 12px;border-radius: 5px;color: rgb(249, 222, 155);padding: 2px 10px;cursor: pointer;transition: transform 0.1s, box-shadow 0.1s;';
            mergeButton.addEventListener('click', function() {
                const gemFullName = gem.displayName;  // 例如 '二级天寿石'
                mergeGem(gemFullName, refreshGemSelection);  // 直接传入宝石的完整名字和刷新函数
            });

            gemButtonContainer.appendChild(inlayButton);
            gemButtonContainer.appendChild(mergeButton); // 添加合成按钮
            gemDetailContainer.appendChild(gemButtonContainer);

            gemContainer.appendChild(gemDetailContainer); // 添加 gemDetailContainer 到 gemContainer
        });
    };

    refreshGemSelection();  // 初次调用以显示宝石列表
    document.getElementById('inlayGemUI').appendChild(gemSelectionDiv);
}

// 应用宝石增益
function applyGemBonus(arm, gem, slotIndex) {
    const bonusMatch = gem.name.match(/(\w+)Gem_(\w+)_(\d+)/);
    if (bonusMatch) {
        const attribute = bonusMatch[2];
        const bonusValue = parseInt(bonusMatch[3]);

        // 更新 gemAttributes 中的对应属性
        if (arm.armState.gemSlots.gemAttribute[attribute] !== undefined) {
            arm.armState.gemSlots.gemAttribute[attribute] += bonusValue;
        }

        // 标记该宝石孔已镶嵌宝石
        arm.armState.gemSlots.inlaid[slotIndex] = gem;

        // 立即更新显示
        updateGemSlotDisplay(arm, gem, slotIndex);
        updateAttributePanel(); // 更新属性面板
    }
}

// 摘除已镶嵌的宝石
function removeGemFromSlot(arm, slotIndex) {
    const gem = arm.armState.gemSlots.inlaid[slotIndex];
    const removeAmuletItem = jinnangItems.find(item => item.name === 'removeAmulet');
    
    if (removeAmuletItem.quantity <= 0) {
        showInfoBox('你没有宝石摘除符文，无法摘除已经镶嵌的宝石！',null,null,'red');
        return;
    }

    showInfoBox('摘除宝石需要用到特殊的摘除符文，确认请继续',
               () => {
                    if (gem) {
                        const bonusMatch = gem.name.match(/(\w+)Gem_(\w+)_(\d+)/);
                        if (bonusMatch) {
                            const attribute = bonusMatch[2];
                            const bonusValue = parseInt(bonusMatch[3]);
                
                            // 从 gemAttributes 中扣除对应属性
                            if (arm.armState.gemSlots.gemAttribute[attribute] !== undefined) {
                                arm.armState.gemSlots.gemAttribute[attribute] -= bonusValue;
                            }
                
                            arm.armState.gemSlots.inlaid[slotIndex] = null; // 清除已镶嵌的宝石
                            addItemToJinnang(`${gem.name}`, 1); // 归还宝石
                
                            // 立即更新显示
                            updateGemSlotDisplay(arm, null, slotIndex);
                            updateAttributePanel(); // 更新属性面板
                            useItem('removeAmulet',1);
                        }
                    }
               },
                () => {return;},
                'red');
}

// 翻译宝石
function translateGem(gemName) {
    const attributeMap = {
        physicalAttack: '物攻',
        magicAttack: '法攻',
        physicalDefense: '物防',
        magicDefense: '法防',
        speed: '速度',
        health: '生命',
        mana: '法力',
        endurance: '耐力',
        intelligence: '智力',
        strength: '强壮',
        agility: '敏捷',
        faith: '信仰'
    };

    const colorMap = {
        pink: '粉红色',
        blue: '天蓝色',
        yellow: '鹅黄色',
        purple: '淡紫色'
    };

    const match = gemName.match(/(\w+)Gem_(\w+)_(\d+)/);
    if (match) {
        const color = match[1];
        const attribute = match[2];
        const value = match[3];

        return `(+${value} ${attributeMap[attribute]} )`;
    }
    return gemName; // 如果没有匹配，返回原始名称
}

// 翻译宝石孔颜色
function translateColor(color) {
    const colorMap = {
        yellow: '鹅黄色',
        blue: '天蓝色',
        pink: '粉红色',
        purple: '淡紫色'
    };
    return colorMap[color] || "未知";
}

// 翻译属性
function translateAttribute(attribute) {
    const attributeMap = {
        physicalAttack: '物理攻击',
        magicAttack: '法术攻击',
        physicalDefense: '物理防御',
        magicDefense: '法术防御',
        speed: '速度',
        health: '生命',
        mana: '法力',
        endurance: '耐力',
        intelligence: '智力',
        strength: '强壮',
        agility: '敏捷',
        faith: '信仰'
    };
    return attributeMap[attribute] || "无";
}

// 升星操作
function upgradeStar(arm) {
    if (arm.armState.starLevel >= 13) {
        showInfoBox("星级已达到最大值！");
        return;
    }

    // 根据星级选择对应的宝石类型
    const starGemOneToSeven = jinnangItems.find(item => item.name === 'starGem');
    const starGemEightToThirteen = jinnangItems.find(item => item.name === 'starGemPlus');

    // 判断宝石是否足够
    if (arm.armState.starLevel <= 7) {
        if (starGemOneToSeven.quantity < 100) {
            showInfoBox('你的升星宝石（极品）不足，无法升星！', null, null, 'red');
            return;
        }
    } else {
        if (starGemEightToThirteen.quantity < 100) {
            showInfoBox('你的升星宝石（神品）不足，无法升星！', null, null, 'red');
            return;
        }
    }

    // 随机数决定是否升级成功
    const successChance = Math.random();
    let successThreshold = arm.armState.starLevel <= 7 ? 0.8 : 0.6;

    // 根据不同星级使用不同宝石
    if (arm.armState.starLevel <= 7) {
        useItem('starGem', 100);
    } else {
        useItem('starGemPlus', 100);
    }

    // 升星逻辑
    if (successChance < successThreshold) {
        // 成功升级，增加星级
        arm.armState.starLevel += 1;
    } else {
        // 升星失败，星级下降
        arm.armState.starLevel = Math.max(arm.armState.starLevel - (arm.armState.starLevel <= 7 ? 1 : 2), 0);
    }

    // 直接根据当前星级计算starBonus
    const baseValue = arm.armState.baseValue || arm.value;  // 假设arm有一个基础值baseValue（初始值）
    const starBonus = baseValue * arm.armState.starLevel * 0.05;

    // 每次直接基于基础值计算属性值
    arm.value = Math.round(baseValue + starBonus);

    // 更新UI显示
    const starDisplay = '⭐️'.repeat(arm.armState.starLevel);
    document.getElementById('starLevel').innerText = starDisplay;
    document.getElementById('baseAttribute').innerText = `+ ${Math.floor(arm.value)} ${translateAttribute(arm.attribute)}`;

    // 控制升级按钮显示
    document.getElementById('upgradeStarBtn').style.display = arm.armState.starLevel >= 13 ? 'none' : 'block';

    updateAttributePanel();
    refreshAndCheckAllArmsEndurance();
}






document.getElementById('upgradeStarBtn').addEventListener('click', function() {
    if (currentKey) {
        upgradeStar(armsAttributes[currentKey]);  // 使用当前装备的 key
    }
});

document.getElementById('punchHoleBtn').addEventListener('click', function() {
    if (currentKey) {
        punchHole(armsAttributes[currentKey]);  // 使用当前装备的 key
    }
});

document.getElementById('refreshSlotsBtn').addEventListener('click', function() {
    if (currentKey) {
        refreshGemSlots(armsAttributes[currentKey]);  // 使用当前装备的 key
    }
});

document.getElementById('gemSlots').addEventListener('click', function(event) {
    const target = event.target.closest('.slot'); // 确保找到包含 slot 类的元素
    if (target) {
        const slotId = target.id;
        const slotIndex = parseInt(slotId.replace('slot', '')) - 1;
        const arm = armsAttributes[currentKey]; // 使用当前打开的装备

        if (slotIndex < arm.armState.gemSlots.current) {
            const inlaid = arm.armState.gemSlots.inlaid[slotIndex];
            if (inlaid) {
                removeGemFromSlot(arm, slotIndex); // 移除已镶嵌的宝石
            } else {
                handleGemInlay(arm, slotIndex); // 处理镶嵌逻辑
            }
        }
    }
});

       
let currentSpecialization = null;
let specializations = {
    慧光辉耀: { level: 0, attribute: 'intelligence', baseMultiplier: 0.055, levelIncrement: 0.0035, url: 'https://pic.imgdb.cn/item/6688dc1ed9c307b7e99d94ce.png' },
    神魔之力: { level: 0, attributes: ['strength', 'agility'], baseMultiplier: 0.055, levelIncrement: 0.0035, url: 'https://pic.imgdb.cn/item/6688dc1ed9c307b7e99d9458.png' },
    坚韧之心: { level: 0, attributes: ['endurance', 'faith'], baseMultiplier: 0.055, levelIncrement: 0.0035, url: 'https://pic.imgdb.cn/item/6688dc1ed9c307b7e99d94db.png' }
};

function resetSpecialization() {
    showInfoBox('你将重置所有已开启的专精进度',
               () => resetSpec(),
               () => {
                   addItemToJinnang('ignoranceWater',1);
                   showInfoBox('操作已取消！',null,null,'red');
                   return;},
               'red');
    function resetSpec() {
        if (currentSpecialization !== null && specializations) {
            specializations = {
                慧光辉耀: { level: 0, attribute: 'intelligence', baseMultiplier: 0.055, levelIncrement: 0.0035, url: 'https://pic.imgdb.cn/item/6688dc1ed9c307b7e99d94ce.png' },
                神魔之力: { level: 0, attributes: ['strength', 'agility'], baseMultiplier: 0.055, levelIncrement: 0.0035, url: 'https://pic.imgdb.cn/item/6688dc1ed9c307b7e99d9458.png' },
                坚韧之心: { level: 0, attributes: ['endurance', 'faith'], baseMultiplier: 0.055, levelIncrement: 0.0035, url: 'https://pic.imgdb.cn/item/6688dc1ed9c307b7e99d94db.png' }
                }
            currentSpecialization = null;
            transformPet();
            showInfoBox('专精进度已全部重置！',null,null,'red');
        } 
    }
}
        
function calculateSecondaryAttributes(currentAttributes, currentWisdom) {
    let multiplier;
    if (currentWisdom <= 12) {
        multiplier = 1 + (currentWisdom * 0.005);
    } else if (currentWisdom <= 20) {
        multiplier = 1.06 + (currentWisdom - 12) * 0.01;
    } else {
        switch (currentWisdom) {
            case 21:
                multiplier = 1.20;
                break;
            case 22:
                multiplier = 1.21;
                break;
            case 23:
                multiplier = 1.22;
                break;
            case 24:
                multiplier = 1.23;
                break;
            case 25:
                multiplier = 1.25;
                break;
            default:
                multiplier = 1;
        }
    }

    // 应用专精乘数逻辑
    if (currentSpecialization) {
        const spec = specializations[currentSpecialization];
        const increment = spec.baseMultiplier + spec.levelIncrement * spec.level;
        if (spec.attributes) {
            spec.attributes.forEach(attr => {
                currentAttributes[attr] *= (1 + increment);
            });
        } else {
            currentAttributes[spec.attribute] *= (1 + increment);
        }
    }

    const skillAttributes = calculateSkillAttributes();

    // 计算基础二级属性
    const baseSecondaryAttributes = {
        health: Math.floor((currentAttributes.endurance * 24 + currentAttributes.intelligence * 1 + currentAttributes.strength * 2 + currentAttributes.agility * 3 + currentAttributes.faith * 3) * multiplier),
        mana: Math.floor((currentAttributes.endurance * 1 + currentAttributes.intelligence * 10 + currentAttributes.strength * 2 + currentAttributes.agility * 2 + currentAttributes.faith * 2) * multiplier),
        physicalAttack: Math.floor((currentAttributes.endurance * 0.1 + currentAttributes.intelligence * 0.1 + currentAttributes.strength * 2.2 + currentAttributes.agility * 0.2 + currentAttributes.faith * 0.2) * multiplier),
        physicalDefense: Math.floor((currentAttributes.endurance * 0.1 + currentAttributes.intelligence * 0.1 + currentAttributes.strength * 0.2 + currentAttributes.agility * 0.2 + currentAttributes.faith * 2.2) * multiplier),
        magicAttack: Math.floor((currentAttributes.endurance * 0 + currentAttributes.intelligence * 1.7 + currentAttributes.strength * 0 + currentAttributes.agility * 0 + currentAttributes.faith * 0) * multiplier),
        magicDefense: Math.floor((currentAttributes.endurance * 2.2 + currentAttributes.intelligence * 0 + currentAttributes.strength * 0 + currentAttributes.agility * 0 + currentAttributes.faith * 0) * multiplier),
        speed: Math.floor((currentAttributes.endurance * 0.2 + currentAttributes.intelligence * 0.1 + currentAttributes.strength * 0.2 + currentAttributes.agility * 2 + currentAttributes.faith * 0.2) * multiplier)
    };

    // 图鉴加成
    const hpBonus = 1 + collectedPetCount * 0.05;
    const mpBonus = 1 + collectedPetCount * 0.04;
    const physicalAttackBonus = 1 + collectedPetCount * 0.012;
    const magicalAttackBonus = 1 + collectedPetCount * 0.01;
    const physicalDefenseBonus = 1 + collectedPetCount * 0.035;
    const magicalDefenseBonus = 1 + collectedPetCount * 0.035;
    const speedBonus = 1 + collectedPetCount * 0.005;

    baseSecondaryAttributes.health = Math.floor(baseSecondaryAttributes.health * hpBonus) + drugBonus.health + skillAttributes.health + drugBonus0.health;
    baseSecondaryAttributes.mana = Math.floor(baseSecondaryAttributes.mana * mpBonus) + drugBonus.mana + skillAttributes.mana + drugBonus0.mana;
    baseSecondaryAttributes.physicalAttack = Math.floor(baseSecondaryAttributes.physicalAttack * physicalAttackBonus) + drugBonus.physicalAttack + skillAttributes.physicalAttack + drugBonus0.physicalAttack;
    baseSecondaryAttributes.magicAttack = Math.floor(baseSecondaryAttributes.magicAttack * magicalAttackBonus) + drugBonus.magicAttack + skillAttributes.magicAttack + drugBonus0.magicAttack;
    baseSecondaryAttributes.physicalDefense = Math.floor(baseSecondaryAttributes.physicalDefense * physicalDefenseBonus) + drugBonus.physicalDefense + skillAttributes.physicalDefense + drugBonus0.physicalDefense;
    baseSecondaryAttributes.magicDefense = Math.floor(baseSecondaryAttributes.magicDefense * magicalDefenseBonus) + drugBonus.magicDefense + skillAttributes.magicDefense + drugBonus0.magicDefense;
    baseSecondaryAttributes.speed = Math.floor(baseSecondaryAttributes.speed * speedBonus) + drugBonus.speed + skillAttributes.speed + drugBonus0.speed;

    // 累加武装增益值，只包括二级属性的增益
    Object.keys(armsAttributes).forEach(key => {
        const arm = armsAttributes[key];
        if (arm.attribute && arm.activated) {
            // 先增加 arm 本身的属性值
            if (!['endurance', 'intelligence', 'strength', 'agility', 'faith'].includes(arm.attribute)) {
                baseSecondaryAttributes[arm.attribute] += arm.value;
            }

            // 处理 gemAttributes 中的值，只累加二级属性
            const gemAttributes = arm.armState?.gemSlots?.gemAttribute;
            if (gemAttributes) {
                Object.keys(gemAttributes).forEach(attr => {
                    if (!['endurance', 'intelligence', 'strength', 'agility', 'faith'].includes(attr) && baseSecondaryAttributes[attr] !== undefined) {
                        baseSecondaryAttributes[attr] += gemAttributes[attr];
                    }
                });
            }
        }
    });

    return baseSecondaryAttributes;
}

function updateSecondaryAttributes() {
    const currentAttributes = calculateCurrentAttributes();
    const secondaryAttributes = calculateSecondaryAttributes(currentAttributes, currentWisdom);

    let wisdomBonus;
    if (currentWisdom <= 12) {
        wisdomBonus = currentWisdom * 0.5;
    } else if (currentWisdom <= 20) {
        wisdomBonus = 7 + (currentWisdom - 12) * 1;
    } else {
        switch (currentWisdom) {
            case 21:
                wisdomBonus = 20;
                break;
            case 22:
                wisdomBonus = 21;
                break;
            case 23:
                wisdomBonus = 22;
                break;
            case 24:
                wisdomBonus = 23;
                break;
            case 25:
                wisdomBonus = 25;
                break;
            default:
                wisdomBonus = 0;
        }
    }

    document.getElementById("secondary-health").innerText = secondaryAttributes.health;
    const healthBonusElement = document.getElementById("secondary-health-bonus");
    healthBonusElement.innerText = `+${wisdomBonus}%`;
    healthBonusElement.classList.toggle("red-text", wisdomBonus > 0);

    document.getElementById("secondary-mana").innerText = secondaryAttributes.mana;
    const manaBonusElement = document.getElementById("secondary-mana-bonus");
    manaBonusElement.innerText = `+${wisdomBonus}%`;
    manaBonusElement.classList.toggle("red-text", wisdomBonus > 0);

    document.getElementById("secondary-physical-attack").innerText = secondaryAttributes.physicalAttack;
    const physicalAttackBonusElement = document.getElementById("secondary-physical-attack-bonus");
    physicalAttackBonusElement.innerText = `+${wisdomBonus}%`;
    physicalAttackBonusElement.classList.toggle("red-text", wisdomBonus > 0);

    document.getElementById("secondary-physical-defense").innerText = secondaryAttributes.physicalDefense;
    const physicalDefenseBonusElement = document.getElementById("secondary-physical-defense-bonus");
    physicalDefenseBonusElement.innerText = `+${wisdomBonus}%`;
    physicalDefenseBonusElement.classList.toggle("red-text", wisdomBonus > 0);

    document.getElementById("secondary-magic-attack").innerText = secondaryAttributes.magicAttack;
    const magicAttackBonusElement = document.getElementById("secondary-magic-attack-bonus");
    magicAttackBonusElement.innerText = `+${wisdomBonus}%`;
    magicAttackBonusElement.classList.toggle("red-text", wisdomBonus > 0);

    document.getElementById("secondary-magic-defense").innerText = secondaryAttributes.magicDefense;
    const magicDefenseBonusElement = document.getElementById("secondary-magic-defense-bonus");
    magicDefenseBonusElement.innerText = `+${wisdomBonus}%`;
    magicDefenseBonusElement.classList.toggle("red-text", wisdomBonus > 0);

    document.getElementById("secondary-speed").innerText = secondaryAttributes.speed;
    const speedBonusElement = document.getElementById("secondary-speed-bonus");
    speedBonusElement.innerText = `+${wisdomBonus}%`;
    speedBonusElement.classList.toggle("red-text", wisdomBonus > 0);

    updateSkillScore();
}

function transformPet() {
    const existingOverlay = document.getElementById('transformPetOverlay');
    if (existingOverlay) {
        document.body.removeChild(existingOverlay);
    }

    if (petLevel < 160 || !petAscended) {
        showInfoBox("转职功能在飞升之后开启。宠物飞升后，你可以选择宠物成长的专攻方向，让它们掌握某类属性的专精修炼方法，获得更显著的属性增长。");
        return;
    }

    const overlay = document.createElement('div');
    overlay.id = 'transformPetOverlay';
    overlay.className = 'transform-pet-overlay';

    const modal = document.createElement('div');
    modal.className = 'transform-pet-modal';

    const title = document.createElement('h2');
    title.innerText = '属性专精';
    title.className = 'transform-pet-title';
    modal.appendChild(title);

    const closeButton = document.createElement('span');
    closeButton.innerText = 'X';
    closeButton.className = 'transform-pet-close-button';
    closeButton.onclick = () => document.body.removeChild(overlay);
    modal.appendChild(closeButton);

    const specializationsDiv = document.createElement('div');
    specializationsDiv.className = 'transform-pet-specializations';

    Object. keys(specializations).forEach(key => {
        const spec = specializations[key];
        const specDiv = document.createElement('div');
        specDiv.className = 'transform-pet-spec';

        const specInfoDiv = document.createElement('div');
        specInfoDiv.className = 'transform-pet-spec-info';

        const specIcon = document.createElement('img');
        specIcon.src = spec.url;
        specIcon.className = 'transform-pet-spec-icon';
        specInfoDiv.appendChild(specIcon);

        const specTitle = document.createElement('h3');
        specTitle.innerText = `专精：${key} Lv${spec.level}`;
        specTitle.id = `${key}-title`;
        specInfoDiv.appendChild(specTitle);

        const specDescription = document.createElement('p');
        specDescription.className = 'transform-pet-spec-description';
        specDescription.innerText = getSpecDescription(key);
        specInfoDiv.appendChild(specDescription);

        // 添加进度条容器
        const progressBarContainer = document.createElement('div');
        progressBarContainer.style = `
            width: 100%;
            background-color: rgb(48, 72, 44);
            overflow: hidden;
            font-size: 14px;
            color: rgb(239, 239, 240);
            box-shadow: rgb(17, 25, 25) 0px 0px 2px 2px inset;
            margin: 0px 0px 5px 0px;
            height: 14px;
            border: 1px solid #634A23;
        `;

        const progressBar = document.createElement('div');
        const progressPercentage = (spec.level / 1000) * 100; // 1000为假定的最大等级
        progressBar.style = `
            height: 100%;
            background: linear-gradient(to bottom, #34773D, #34773D, #69E055, #69E055, #34773D, #34773D);
            width: ${progressPercentage}%;
        `;
        progressBarContainer.appendChild(progressBar);
        specInfoDiv.appendChild(progressBarContainer);

        const buttonsDiv = document.createElement('div');
        buttonsDiv.className = 'transform-pet-buttons';
        buttonsDiv.id = `${key}-buttons`; // 为每个按钮组设置唯一ID

        const createButton = (text, handler) => {
            const button = document.createElement('button');
            button.innerText = text;
            button.className = 'transform-pet-button';
            button.onclick = handler;
            return button;
        };

        const openButton = createButton(
            currentSpecialization === key ? '已开' : '开启',
            () => {
                if (currentSpecialization === key) {
                    showInfoBox("你已经开启过本专精了！");
                } else if (currentSpecialization) {
                    showInfoBox("你只能同时开启一个专精，请先关闭当前专精后再开启其他专精！");
                } else {
                    if (useItem('infiniteGem', 1)) {
                        handleSpecializationChange(key);
                        showInfoBox(`在无限宝石的指引下，你的宠物选择了${key}专精！`);
                    } else {
                        showInfoBox("您还没有无限宝石，此道具可通过开启奇馈宝箱概率获得。");
                    }
                }
                refreshSpecializationUI();
            }
        );
        buttonsDiv.appendChild(openButton);

        const closeSpecButton = createButton(
            '关闭',
            () => {
                if (currentSpecialization !== key) {
                    showInfoBox("本专精尚未启用！");
                } else {
                    if (useItem('ignoranceWater', 1)) {
                        handleSpecializationChange(null);
                        showInfoBox("清心酿使你的宠物忘记了历年所学，返璞归真");
                    } else {
                        showInfoBox("您还没有清心酿，此道具可通过开启奇馈宝箱概率获得。");
                    }
                }
                refreshSpecializationUI();
            }
        );
        buttonsDiv.appendChild(closeSpecButton);

        const upgradeButton = createButton(
            '升级',
            () => {
                if (currentSpecialization !== key) {
                    showInfoBox("未开启此专精！");
                } else {
                    upgradeSpecialization(key);
                }
                refreshSpecializationUI();
            }
        );
        buttonsDiv.appendChild(upgradeButton);

        const upgradeToMaxButton = createButton(
            '升满',
            () => {
                if (currentSpecialization !== key) {
                    showInfoBox("未开启此专精！");
                } else {
                    upgradeToMax(key);
                }
                refreshSpecializationUI();
            }
        );
        buttonsDiv.appendChild(upgradeToMaxButton);

        specInfoDiv.appendChild(buttonsDiv); // 按钮组放置在进度条下方
        specDiv.appendChild(specInfoDiv);
        specializationsDiv.appendChild(specDiv);
    });

    modal.appendChild(specializationsDiv);
    overlay.appendChild(modal);
    document.body.appendChild(overlay);
}

function refreshSpecializationUI() {
    Object.keys(specializations).forEach(key => {
        const spec = specializations[key];
        document.getElementById(`${key}-title`).innerText = `专精：${key} Lv${spec.level}`;

        // 更新进度条
        const progressBar = document.querySelector(`#${key}-buttons`).previousElementSibling.firstChild;
        const progressPercentage = (spec.level / 1000) * 100; // 1000为假定的最大等级
        progressBar.style.width = `${progressPercentage}%`;

        const buttons = document.querySelectorAll(`#${key}-buttons button`);
        buttons.forEach(button => {
            if (button.innerText === '开启' || button.innerText === '已开') {
                button.innerText = currentSpecialization === key ? '已开' : '开启';
                button.style.backgroundColor = currentSpecialization === key ? 'grey' : 'linear-gradient(to bottom, #E47F47, #CE6633, #963D1C)';
            }
        });
    });
    updateAttributePanel();
}

function getSpecDescription(key) {
    switch (key) {
        case '慧光辉耀':
            return '宠物的智力属性会按更高的比例增加对应二级属性（法术攻击、法力值）。与此同时，宠物修为的提升会更显著';
        case '神魔之力':
            return '宠物的强壮和敏捷属性会按更高的比例增加对应二级属性。（物理攻击、速度）';
        case '坚韧之心':
            return '宠物的耐力和信仰属性会大幅增加对应的二级属性。（生命值、物理防御、法术防御）';
    }
}

function handleSpecializationChange(newSpec) {
    currentSpecialization = newSpec;
    applySpecialization();
    refreshSpecializationUI();
}

function upgradeSpecialization(key) {
    const spec = specializations[key];
    if (spec.level >= 1000) {
        showInfoBox("专精等级已达上限！");
        return;
    }

    let upgradeCost = (spec.level >= 100 ? (spec.level - 99) * 5000 : spec.level * 200 + 200);

    if (spec.level >= 100) {
        // 优先尝试使用塔草
        if (useItem('towerGrass', 1)) {
            spec.level++;
            showInfoBox(`你消耗一颗融会贯通，将专精${key}已升级Lv${spec.level}！`);
        } else if (goldAmount >= upgradeCost) {
            // 若无法使用塔草，尝试使用金子
            goldAmount -= upgradeCost;
            spec.level++;
            updateGoldDisplay(goldAmount);
            showInfoBox(`你花费了${convertPrice(upgradeCost)}金子，将专精${key}已升级至Lv${spec.level}！（如果需要持续升级，无需关闭本窗口即可继续操作）`);
        } else if (useItem('towerGrass', 1)) {
            // 如果金子不足，再次尝试使用塔草
            spec.level++;
            showInfoBox(`金子不足，但你消耗一颗融会贯通，将专精${key}已升级Lv${spec.level}！`);
        } else {
            // 两者都无法使用时提示
            showInfoBox(`金子或融会贯通不足，无法升级专精${key}。`);
        }
    } else {
        // 低于100级的情况，直接使用金子升级
        if (goldAmount >= upgradeCost) {
            goldAmount -= upgradeCost;
            spec.level++;
            updateGoldDisplay(goldAmount);
            showInfoBox(`你花费了${convertPrice(upgradeCost)}金子，将专精${key}已升级至Lv${spec.level}！（如果需要持续升级，无需关闭本窗口即可继续操作）`);
        } else {
            showInfoBox(`升级所需金子不足，需要${convertPrice(upgradeCost)}金子。`);
        }
    }

    refreshSpecializationUI();
    updateSkillScore();
}


function upgradeToMax(key) {
    const spec = specializations[key];
    let totalCost = 0;
    let tempLevel = spec.level;
    let projectedGold = goldAmount;

    // 计算玩家当前金币能升级到的最大等级以及所需总费用
    while (tempLevel < 1000 && projectedGold >= (tempLevel >= 100 ? (tempLevel - 99) * 5000 : tempLevel * 200 + 200)) {
        let upgradeCost = (tempLevel >= 100 ? (tempLevel - 99) * 5000 : tempLevel * 200 + 200);
        totalCost += upgradeCost;
        projectedGold -= upgradeCost;
        tempLevel++;
    }

    // 提示玩家确认
    showInfoBox(`确定花费共计${convertPrice(totalCost)}金子将${key}升级到Lv${tempLevel}吗？`, () => {
        while (spec.level < 1000 && goldAmount >= (spec.level >= 100 ? (spec.level - 99) * 5000 : spec.level * 200 + 200)) {
            upgradeSpecialization(key);
        }
        refreshSpecializationUI();
    });
    updateSkillScore();
}
        
function applySpecialization() {
    updateSecondaryAttributes();
    updateAttributePanel();
    refreshSpecializationUI();
    updateSkillScore();
}

let trainingCosts = [20000, 60000, 500000, 1000000, 2000000]; // 定义每次金子培养所需的金子数量
let trainingMultipliers = [1.05, 1.04, 1.03, 1.02, 1.01]; // 定义每次金子培养的属性提升倍数
let trainingCount = 0; // 初始化已经使用的金子培养次数

function calculateAvailableTrainingCount(petLevel) {
    // 计算可用的金子培养次数
    let count = 0;
    if (petLevel >= 0) count++; // 宠物等级大于等于0时增加一次
    if (petLevel >= 60) count++; // 宠物等级大于等于60时增加一次
    if (petLevel >= 149) count++; // 宠物等级大于等于149时增加一次
    if (petLevel >= 160) count++; // 宠物等级大于等于160时增加一次
    if (petLevel >= 180) count++; // 宠物等级大于等于180时增加一次
    return count;
}

let triggerAutoTrainingCountDown = 0;
let autoTrainingInterval = null;
let autoTrainingTimeout = null;

function startAutoTraining() {
    // 开始以0.1秒频率自动执行trainAttributesAfterFifth
    autoTrainingInterval = setInterval(() => {
        if (goldAmount <= 5000) {
            stopAutoTraining();
        } else {
            trainAttributesAfterFifth();
        }
    }, 100);

    // 60秒后停止自动执行
    autoTrainingTimeout = setTimeout(() => {
        stopAutoTraining(); // 在 60 秒后直接停止
    }, 60000);
}

function stopAutoTraining() {
    // 如果定时器已经被清除，直接返回
    if (!autoTrainingInterval && !autoTrainingTimeout) {
        return;
    }

    // 清除定时器和状态重置
    clearInterval(autoTrainingInterval);
    clearTimeout(autoTrainingTimeout);

    autoTrainingInterval = null;
    autoTrainingTimeout = null;
    triggerAutoTrainingCountDown = 0;
    showInfoBox("自动培养已停止。");
}

function trainAttributesAfterFifth() {
    if (goldAmount < 5000) {
        showInfoBox("金子不足5两，无法培养！");
        return;
    }
    
    triggerAutoTrainingCountDown += 1;

    const leftAttributes = attributesForTraning();

    const maxEndurance = Math.round((leftAttributes.endurance - additionalAttributes.endurance) * 0.4);
    const maxIntelligence = Math.round((leftAttributes.intelligence - additionalAttributes.intelligence) * 0.4);
    const maxStrength = Math.round((leftAttributes.strength - additionalAttributes.strength) * 0.4);
    const maxAgility = Math.round((leftAttributes.agility - additionalAttributes.agility) * 0.4);
    const maxFaith = Math.round((leftAttributes.faith - additionalAttributes.faith) * 0.4);
    console.log(`金子培养上限值：${maxEndurance}, ${maxIntelligence}, ${maxStrength}, ${maxAgility}, ${maxFaith},`);

    const randomGrowthCount = () => {
        const rand = Math.random();
        if (rand < 0.05) return 5;
        if (rand < 0.20) return 4;
        if (rand < 0.45) return 3;
        if (rand < 0.80) return 2;
        return 1;
    }

    const growthCount = randomGrowthCount();
    let attributes = ['endurance', 'intelligence', 'strength', 'agility', 'faith'];
    const maxAttributes = {
        endurance: maxEndurance,
        intelligence: maxIntelligence,
        strength: maxStrength,
        agility: maxAgility,
        faith: maxFaith
    };
    let results = [];

    for (let i = 0; i < growthCount; i++) {
        const randomIndex = Math.floor(Math.random() * attributes.length);
        const attribute = attributes[randomIndex];
        attributes.splice(randomIndex, 1); // 移除已经选择的属性

        const maxAttribute = maxAttributes[attribute];
        const bonusAttribute = bonusAttributes[attribute];
        const currentAttribute = leftAttributes[attribute];

        let growthRange = [0, 3];
        if (bonusAttribute === maxAttribute) {
            growthRange = [0, 0];
        } else if (bonusAttribute >= maxAttribute * 0.9) {
            growthRange = [-1, 2];
        }

        const growthValue = Math.floor(Math.random() * (growthRange[1] - growthRange[0] + 1)) + growthRange[0];
        const newBonusValue = Math.min(bonusAttribute + growthValue, maxAttribute);
        const attributeMap = {
            endurance: "耐力",
            intelligence: "智力",
            strength: "强壮",
            agility: "敏捷",
            faith: "信仰"
        };

        bonusAttributes[attribute] = Math.max(newBonusValue, 0);
        results.push(`${i + 1}. ${attributeMap[attribute]}: ${growthValue > 0 ? '+' : ''}${growthValue}`);
    }

    goldAmount -= 5000;
    updateGoldDisplay(goldAmount);
    updateAttributePanel();

    showInfoBox(`金培消耗5两金：\n${results.join('\n')}`);

    // 如果触发自动执行条件且尚未开始自动执行
    if (triggerAutoTrainingCountDown >= 5 && !autoTrainingInterval) {
        startAutoTraining();
    }
}

function bonusAttributesDisplay() {
    const attributeNames = ['endurance', 'intelligence', 'strength', 'agility', 'faith'];
    const leftAttributes = attributesForTraning();
    const maxAttributes = {
        endurance: Math.round((leftAttributes.endurance - additionalAttributes.endurance) * 0.4),
        intelligence: Math.round((leftAttributes.intelligence - additionalAttributes.intelligence) * 0.4),
        strength: Math.round((leftAttributes.strength - additionalAttributes.strength) * 0.4),
        agility: Math.round((leftAttributes.agility - additionalAttributes.agility) * 0.4),
        faith: Math.round((leftAttributes.faith - additionalAttributes.faith) * 0.4)
    };

    attributeNames.forEach(attribute => {
        const spanElement = document.getElementById(`bonusAttribute-${attribute}`);
        if (spanElement) {
            const bonusValue = bonusAttributes[attribute];
            const maxValue = maxAttributes[attribute];
            if (bonusValue >= maxValue) {
                spanElement.innerText = `(+${bonusValue}(满))`;
                 spanElement.style.color = "#fb3c2e";
            } else {
                spanElement.innerText = `(+${bonusValue})`;
                spanElement.style.color = "white";
            }
        }
    });
}

function trainAttributes() {
    // 计算可用的金子培养次数
    const availableTrainingCount = calculateAvailableTrainingCount(petLevel);

    // 检查当前培养次数是否达到可用次数
    if (trainingCount >= availableTrainingCount && trainingCount >= 5) {
        trainAttributesAfterFifth();
        return;
    } else if (trainingCount >= availableTrainingCount){
        showInfoBox("当前没有可用培养次数。\n1. 当等级达到60/120/160/180级时会各获得一次培养机会 \n2. 每次培养会按比固定例增加宠物的属性值 \n3. 第五次培养后可按照每一次5两的花费为宠物进行随机属性增长 \n4. 连续随机增长5次会自动执行10秒培养，请注意金子花费 \n5. 随机金子培养值存在上限，宠物资质越好上限越高 ");
        return; // 退出函数
    }

    // 获取当前培养所需的金子数量
    const cost = trainingCosts[trainingCount];

    // 提示玩家当前花费
    showInfoBox(`这次金子培养需要${convertPrice(cost)}金子，是否继续？`, function() {
        // 玩家点击确认按钮，继续执行培养操作

        // 检查金子数量是否足够
        if (goldAmount < cost) {
            showInfoBox("金子不足！"); // 如果金子不足，提示用户
            return; // 退出函数
        }

        // 扣除金子
        goldAmount -= cost;
        updateGoldDisplay(goldAmount); // 更新显示的金子数量

        // 获取当前培养的属性提升倍数
        const multiplier = trainingMultipliers[trainingCount];
        // 获取可供培养的属性上限
        const leftAttributes = attributesForTraning();
    
        const maxEndurance = Math.round((leftAttributes.endurance - additionalAttributes.endurance) * 0.4);
        const maxIntelligence = Math.round((leftAttributes.intelligence - additionalAttributes.intelligence) * 0.4);
        const maxStrength = Math.round((leftAttributes.strength - additionalAttributes.strength) * 0.4);
        const maxAgility = Math.round((leftAttributes.agility - additionalAttributes.agility) * 0.4);
        const maxFaith = Math.round((leftAttributes.faith - additionalAttributes.faith) * 0.4);
    

        // 提升bonusAttributes中的值
        bonusAttributes.endurance += Math.floor(leftAttributes.endurance * (multiplier - 1));
        bonusAttributes.intelligence += Math.floor(leftAttributes.intelligence * (multiplier - 1));
        bonusAttributes.strength += Math.floor(leftAttributes.strength * (multiplier - 1));
        bonusAttributes.agility += Math.floor(leftAttributes.agility * (multiplier - 1));
        bonusAttributes.faith += Math.floor(leftAttributes.faith * (multiplier - 1));

        bonusAttributes.endurance = Math.min(maxEndurance, bonusAttributes.endurance);
        bonusAttributes.intelligence = Math.min(maxIntelligence, bonusAttributes.intelligence);
        bonusAttributes.strength = Math.min(maxStrength, bonusAttributes.strength);
        bonusAttributes.agility = Math.min(maxAgility, bonusAttributes.agility);
        bonusAttributes.faith = Math.min(maxFaith, bonusAttributes.faith);

        // 增加金子培养次数
        trainingCount++;

        // 更新属性面板
        updateAttributePanel();
    }, function() {
        // 玩家点击取消按钮，退出函数
        return;
    });
}

function updatePetLevel() {
    document.getElementById('pet-level').innerText = petLevel;
    document.getElementById('your-pet-level').innerText = petLevel;
    updateAttributePanel();
    updateSkillScore();
    updateTitle();
}

function updatePetWisdom() {
    document.getElementById("current-wisdom").innerText = petWisdom;
    document.getElementById("attribute-wisdom").innerText = petWisdom; // 更新属性面板中的悟性
    updateAttributePanel();
}
        
function showBiography() {
    const currentPetName = document.getElementById("pet-select").value;
    const biography = biographies[currentPetName];
    const skillScore = parseInt(document.getElementById("skill-score").innerText, 10);

    let message = "";

    if (skillScore < 1000000) {
        message = "您的宠物评分过低，请提升到1000000后再试！（宠物传记共有3段，评分达到1000000、2000000和3000000时会分别解锁）";
    } else {
        // 使用数组来存储每个可能的段落
        const paragraphs = [];

        if (biography[0] && skillScore >= 1000000) {
            paragraphs.push(biography[0]);
        }
        if (biography[1] && skillScore >= 2000000) {
            paragraphs.push(biography[1]);
        }
        if (biography[2] && skillScore >= 3000000) {
            paragraphs.push(biography[2]);
        }
        if (biography[3] && skillScore >= 4000000) {
            paragraphs.push(biography[3]);
        }

        // 将所有段落拼接成一个字符串，用换行符分隔
        message = paragraphs.join("\n");
    }

    showInfoBox(message, null, null, 'black');
}


let goldenRebornPill = 10;
function useGoldenRebornPill() {
    if (goldenRebornPill < 1) {
        showInfoBox("您的还童金丹已耗尽！");
        return;
    }
    if (awakened) {
        showInfoBox("您的宠物已经觉醒，无法还童！");
        return;
    }
    goldenRebornPill--;
    document.getElementById("golden-reborn-pill").innerText = goldenRebornPill;

    const qualities = currentPet.qualities;
    if (qualities.mutated) {
        qualities.tier = Math.random() < 0.5 ? '卓越' : '完美';
        qualities.growthRate = qualities.tier === '卓越' ? getWeightedRandom([300, 320], [0.5, 0.5]) : getWeightedRandom([340, 360, 380, 400], [0.3, 0.5, 0.15, 0.05]);
    } else {
        qualities.tier = '普通';
        qualities.growthRate = 100;
    }

    qualities.endurance.current = getRandomInt(qualities.endurance.min, qualities.endurance.max);
    qualities.strength.current = getRandomInt(qualities.strength.min, qualities.strength.max);
    qualities.faith.current = getRandomInt(qualities.faith.min, qualities.faith.max);
    qualities.agility.current = getRandomInt(qualities.agility.min, qualities.agility.max);
    qualities.intelligence.current = getRandomInt(qualities.intelligence.min, qualities.intelligence.max);

    // 更新技能
    const skillNum = getRandomInt(0, 3);
    const newSkills = [];
    const bSkills = currentPet.skills.filter(skill => skill.rarity === 'B');
    for (let i = 0; i < skillNum; i++) {
        const skill = bSkills[Math.floor(Math.random() * bSkills.length)];
        if (!newSkills.some(s => s.name === skill.name)) {
            newSkills.push(skill);
        }
    }
    updateSkillsArea(newSkills);
    updateSkillScore(newSkills);
    updateTitle();
    
    petLevel = 1;
    currentWisdom = 0;
    petWisdom = currentWisdom;
    petAscended = false; //新增宠物失去飞升的还童规则
    petMaxLevel = 149;
    
    updateQualityCard();
    updateSkillScore();
    updatePetWisdom();
}

let goldAmount = 500000; // 初始金子数量
function updateGoldDisplay(goldAmount) {
    const goldElement = document.getElementById('gold-amount');

    // 确保 goldAmount 不超过 999,999,999
    if (goldAmount > 999999999) {
        exchangeGoldBlock(true);
        showInfoBox('你的金子数已越界！已自动为你兑换成一个金锭！',null,null,'red');
    }

    const wen = goldAmount % 1000;
    const liang = Math.floor(goldAmount / 1000) % 1000;
    const ding = Math.floor(goldAmount / 1000000);

    goldElement.innerText = `${ding}锭${liang}两${wen}文`;
    goldElement.style.color = 'white';
    goldElement.style.background = '#395759'; // 兼容性处理
    goldElement.style.boxShadow = 'rgb(30, 46, 47) 0px 0px 5px 2px inset'; // 兼容性处理
    goldElement.style.padding = '2px 2px'; // 兼容性处理
    goldElement.style.fontSize = '12px'; // 兼容性处理
}

function exchangeGoldBlock(auto = false) {
    const goldBlockPrice = 180000000;
    const goldBlockName = '金锭';
    const goldBlockImage = 'https://pic.imgdb.cn/item/66d68b8dd9c307b7e90ff369.png';
    const goldBlockDescription = '价值连城的贵金属，无论在什么时代都是最好的天然货币（你可以低于市场的价格直接出售，也可以点击使用进行市场竞价）';

    function createGoldBlock() {
        goldAmount -= 200000000;
        updateGoldDisplay(goldAmount);
        generateItemToJinnang('goldBlock', goldBlockName, goldBlockImage, goldBlockPrice, 1, goldBlockDescription);
    }

    if (goldAmount < 200000000) {
        if (!auto) {
            showInfoBox('你的金子不足200锭，无法兑换金锭！', null, null, 'red');
        }
    } else {
        if (!auto) {
            showInfoBox(
                '你可以用200锭金子兑换一个金锭，金锭与所花费的金子等值，出售时价格会略微波动，是你资产过多时的良好投资品',
                () => {
                    createGoldBlock();
                    showInfoBox('获得一个金锭！', null, null, 'black');
                },
                null,
                'red'
            );
        } else {
            createGoldBlock();
        }
    }
}

function sellGoldBlock(basePrice) {
        const fluctuationPercentage = 0.02; // 2%
        const goldBlockPrice = Math.floor(basePrice * (1 + (Math.random() * 2 * fluctuationPercentage - fluctuationPercentage)));
        const difference = Math.abs(basePrice - goldBlockPrice);
        
        goldAmount += goldBlockPrice;
        updateGoldDisplay(goldAmount);
        
        if (goldBlockPrice >= basePrice) {
            showInfoBox(`你成功出售一个金锭，获得了${convertPrice(goldBlockPrice)}金子，赚了${convertPrice(difference)}金！`, null, null, 'red');
        } else {
            showInfoBox(`你成功出售一个金锭，获得了${convertPrice(goldBlockPrice)}金子，亏了${convertPrice(difference)}金！`, null, null, 'green');
        }

        setTimeout(() => {
            if (Math.random() < 0.6) {
                randomlyEventAfterSellingBlock();
            }
        },200);
}

function randomlyEventAfterSellingBlock() {
    const rareItemName = ['universalHeart', 'luckyAmulet', 'qiongmeiCard', 'advancedSkillBook', 'hongHuang']; // 可拓展更多物品
    const canChangeTinyGoldBlock = [5, 10, 50, 20, 2];  // 对应的物品价格

    // 随机选择一个物品
    const randomIndex = Math.floor(Math.random() * rareItemName.length);
    const selectedItem = {
        name: rareItemName[randomIndex],
        price: canChangeTinyGoldBlock[randomIndex]
    };

    const itemData = jinnangItems.find(item => item.name === selectedItem.name);
    const itemDisplayName = itemData ? itemData.displayName : '未知物品';
    
    // 获取tinyGoldBlock的数量
    const tinyGoldBlock = jinnangItems.find(item => item.name === 'tinyGoldBlock');
    const merchantUrl = 'https://pic.imgdb.cn/item/66e1a40fd9c307b7e948e7e9.png';
    
    showInfoBox(
        `一朝富贵天下知，四海奇珍异宝向君来，神秘商人“李金嘴”带了一些好货，其中最抢眼的尖货莫过于: \n\n${itemDisplayName} * 1\n\n你需要支付${selectedItem.price}个小金锭，是否交易？`,
        () => {
            if (tinyGoldBlock && tinyGoldBlock.quantity >= selectedItem.price) {
                // 使用小金锭进行交易
                useItem('tinyGoldBlock', selectedItem.price);
                addItemToJinnang(selectedItem.name, 1);
                showInfoBox(`交易成功！你获得一个${itemDisplayName}`, null, null, null, merchantUrl, '80px * 80px');
            } else if (goldAmount >= selectedItem.price * 8000000) {
                // 使用金币购买
                showInfoBox(`你的小金锭数量不足，是否花费${convertPrice(selectedItem.price * 8000000)}金等值购买？`,
                    () => {
                        goldAmount -= selectedItem.price * 8000000;
                        updateGoldDisplay(goldAmount);
                        addItemToJinnang(selectedItem.name, 1);
                        showInfoBox(`交易成功！你获得一个${itemDisplayName}`, null, null, null, merchantUrl, '80px * 80px');
                    },
                    () => {
                        showInfoBox('你放弃了本次神秘商人鼎力推荐的货品！', null, null, null, merchantUrl, '80px * 80px');
                    },
                    null,
                    merchantUrl,
                    '80px * 80px'
                );
            } else {
                showInfoBox('少侠，你的实力不够呀！', null, null, null, merchantUrl, '80px * 80px');
            }
        },
        () => {
            showInfoBox('没关系，下次我还会带着更好的商品来拜访您！行走江湖，买卖是次要的，结识与奇珍异宝缔结良缘的各路豪杰才是最重要的！', null, null, null, merchantUrl, '80px * 80px');
        },
        null,
        merchantUrl,
        '80px * 80px'
    );
}

        
function toggleShop() {
    const drawer = document.getElementById('shop-drawer');
    const info = document.getElementById('shop-info');
    drawer.classList.toggle('open');
    info.classList.toggle('open');

    const buttonElement = document.getElementById("bless-gift-button");
    
    if (blessGiftClaimed) {
        buttonElement.style.display = "none";
    }

    const discountElement = document.getElementById('discount-detail');
    const eightyDiscountCard = jinnangItems.find(i => i.name === 'eightyDiscountCard');
    const titleElement = document.getElementById('personal-honor');
    const currentTitleIndex = titles.indexOf(titleElement.innerText);
    const titleDiscount = 1 - (currentTitleIndex * 0.005);
    let discount = 1;

    // 应用eightyDiscountCard的折扣
    if (eightyDiscountCard && eightyDiscountCard.quantity > 0) {
        discount = 0.8;
    }
    
    discount *= titleDiscount;
    discountElement.innerText = `（称号乐享${(discount * 100).toFixed(0)}折）`;
}

function initShop() {
    refreshShop(true);  // 初始加载商品
    startShopTimer();   // 启动倒计时
}

function startShopTimer() {
    let timer = 300; // 5分钟倒计时，单位：秒
    const timerDisplay = document.getElementById('shop-timer');

    const interval = setInterval(() => {
        timer--;
        const minutes = Math.floor(timer / 60);
        const seconds = timer % 60;
        timerDisplay.innerText = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

        if (timer <= 0) {
            clearInterval(interval);
            refreshShop(true);  // 自动刷新
        }
    }, 1000);
}

let scalpingState = {
    currentSellingWeek: 0,
    maxSellingWeek: 52,
    playerReputation: 0,
    playerEnergy: 100,
    currentCash: 0, // 示例初始现金
    netAsset: 0, 
    usedWarehouseCapacity: 0,
    maxWarehouseCapacity: 100, // 初始仓库容量
    warehouseUpdateCount: 0,
    investmentCount: 0,
    holdItems: {}, // 存放玩家购买的商品
    gadgets: [], //玩家使用的增益道具
    achievements: []
};
let scalpingScore = 0; //用于兑换法宝
let highestAsset = 0;

let scalpingItems = [
    {name: '陈酿女儿红', url: 'https://pic.imgdb.cn/item/66e2e21ed9c307b7e9177f3f.png', itemActivate: false, downRate: 2, basePrice: 1500, bonusPrice: 8000, fluctuation: 0.2, goodEvent: '本周适逢三界最轰动的神仙品酒大会，女儿红被炒作至新高！', badEvent: '全面禁酒周，美酒虽好，仍不能贪杯哦', description: '陈酿女儿红，酒饕的盛宴'},
    {name: '归元灵玉', url: 'https://pic.imgdb.cn/item/66e2ded9d9c307b7e9132d0f.png', itemActivate: false, downRate: 1.5, basePrice: 20000, bonusPrice: 500000, fluctuation: 0.3, goodEvent: '仙人江灵子近日凭靠归元灵玉的灵压成功跃升修仙者，三界上下立即掀起修仙热，归元灵玉被炒至历史新高', badEvent: '姜太后下令罢黜百家，修仙者因鼓励无为而被列入重点打击对象，归元灵玉价格遇冷', description: '形若钻石的灵玉，修炼功法的绝佳媒介'},
    {name: '神器碎片', url: 'https://pic.imgdb.cn/item/66e2dfdfd9c307b7e9149cda.png', itemActivate: false, downRate: 1, basePrice: 400, bonusPrice: 1000, fluctuation: 0.1, goodEvent: '最近朝廷动荡，似乎有政变发生，各路豪杰纷纷带上趁手的武器去一探究竟，锻造所用的神器碎片价格攀升', badEvent: '举世太平，武器装备无人问津，原材料神器碎片暴跌', description: '传言取自伏羲琴的一丝灵力凝结而成的碎片，是锻造神兵的必备材料'},
    {name: '金龙蛋', url: 'https://pic.imgdb.cn/item/66e2e105d9c307b7e91616e1.png', itemActivate: false, downRate: 1, basePrice: 200, bonusPrice: 4000, fluctuation: 0.05, goodEvent: '“是真的小金龙！”头条一经发布，金龙蛋的“割韭菜”谣言不攻自破，销量长虹', badEvent: '“什么啊，原来是小鸭子！”1818黄金眼揭露金龙蛋骗局，竟是小鸭子伪装小金龙藏匿其中！骗局一经拆穿，金龙蛋价格也随名声跌落神坛', description: '神奇的一颗蛋，似乎有幼小的生命正在孕育，不少侠士正在收购以窥究竟'},
    {name: '翡翠玉珏', url: 'https://pic.imgdb.cn/item/66e2e180d9c307b7e916b19f.png', itemActivate: false, downRate: 1.5, basePrice: 2000, bonusPrice: 4000, fluctuation: 0.15, goodEvent: '玉珏就是朝云国的黄金！这句slogan一经打响，引来各界人士对古玩的强烈兴趣', badEvent: '黄金永远是黄金，尤其在真的黄金面前，你会选谁？这句辩论很快警醒了抢购玉珏的民众，纷纷抛售之', description: '上好的玉珏，古玩界不乏狂热的拥趸'},
    {name: '玫瑰花束', url: 'https://pic.imgdb.cn/item/66e3240bd9c307b7e994944b.png', itemActivate: false, downRate: 1, basePrice: 600, bonusPrice: 3000, fluctuation: 0.35, goodEvent: '本周是三界情人周，花束一经上市便被抢购一空', badEvent: '经济下行，民众都不过情人节了，花束价格一落千丈', description: '天长地久，爱无止休'},
    {name: '拇指生煎', url: 'https://pic.imgdb.cn/item/66e3c0f6d9c307b7e954f14e.png', itemActivate: false, downRate: 1, basePrice: 200, bonusPrice: 500, fluctuation: 0.5, goodEvent: '朝云国盛产各路网红，拇指生煎是带货的王牌产品，一经推出火爆全网！', badEvent: '网红永远是网红，口味不好说什么都是白搭，拇指生煎不是跌价，只是回到了它应得的价位', description: '状如拇指的小个头生煎包，曾在各大城市小吃街风靡一时'},
    {name: '珍贵皮草', url: 'https://pic.imgdb.cn/item/66e3c0f6d9c307b7e954f131.png', itemActivate: false, downRate: 2, basePrice: 20000, bonusPrice: 40000, fluctuation: 0.15, goodEvent: '时装周来袭，高定？设计师品牌？拼接元素？没有原材料统统都不行！本周谁拥有皮草谁就是最大赢家！', badEvent: '没有买卖，就没有杀害————哪怕你杀的是巨大的棕熊。皮草市场被肃清，商人们纷纷甩货', description: '不知是取自哪种凶狠野兽之身，毛发绵密柔软，保温效果极好'},
    {name: '南非水晶', url: 'https://pic.imgdb.cn/item/66e7aabfd9c307b7e9ce4e9e.png', itemActivate: false, downRate: 2.5, basePrice: 20000, bonusPrice: 300000, fluctuation: 0.05, goodEvent: '街头传言来自非洲大陆的水晶原石开石后会露出金矿，一时间南非水晶被狂热的淘金客一举收罄', badEvent: '作为工艺品的原材料，南非水晶是好东西；作为淘金客的美梦，它只能沦为破碎，南非水晶大跳水', description: '朝云船队抵达好望角，在当地开采了不少这种形制坚硬透亮的矿石，论密度又比传统水晶更大，似乎有秘密在其中'},
    {name: '月饼', url: 'https://pic.imgdb.cn/item/66e7aabfd9c307b7e9ce4eae.png', itemActivate: false, downRate: 1, basePrice: 100, bonusPrice: 2000, fluctuation: 0.15, goodEvent: '中秋佳节，月饼也成了走亲访友的送礼佳品，所谓贵的就是好的，月饼也在节日氛围里身价倍涨', badEvent: '现代人崇尚低碳水、低糖的饮食作风，月饼大量临期，折价处理', description: '农历八月十五，是万家灯火共团圆的日子'},
    {name: '浪四海', url: 'https://pic.imgdb.cn/item/66ebc319f21886ccc0a21f39.png', itemActivate: false, downRate: 2, basePrice: 3000, bonusPrice: 6000, fluctuation: 0.4, goodEvent: '小长假，踏上浪四海云游四方成为越来越多修仙者的生活方式，浪四海价格走俏', badEvent: '由于羽族开发了“共享羽翼”，浪四海因成本过高问题失去人们青睐', description: '不仅拥有飞剑的霸气造型，更有一个响亮的名字：“浪四海！'},
    {name: '灵雨', url: 'https://pic.imgdb.cn/item/66ebc319f21886ccc0a21f10.png', itemActivate: false, downRate: 4, basePrice: 15000, bonusPrice: 30000, fluctuation: 0.4, goodEvent: '一年一度的赛级大猫出圈三界——更柔顺的毛皮和更美的品相！带动灵雨全线价格上升', badEvent: '大猫固然可爱，千篇一律终让人审美疲劳，价格回归低位', description: '外形出众，性格温顺的灵猫，擅长为修仙者提供各种增益和情绪价值'}
];

let stockList = [
    {unit: 1, name: '影月坊工作室', threshold: 100000, dealWeek: 2, quantity: 0, price: 0.5, basePrice: 0.5, flow: 0.05, state: null, fluctuation: 0.03, quality: 'bad', url:'https://pic.imgdb.cn/item/66e9380df21886ccc0ca0085.png', des:'靠山吃山，靠水吃水。北影月村民坐拥两大野生森林，大力发展纺织业，男耕女织自给自足' },
    {unit: 2, name: '黑水水产商行', threshold: 500000, dealWeek: 3, quantity: 0, price: 10, basePrice: 10, flow: 0.15, state: null, fluctuation: 0.03, quality: 'medium', url:'https://pic.imgdb.cn/item/66e9380cf21886ccc0ca0060.png', des:'灵仙岛岛民在仙人飞升成名前一直以捕鱼为业，黑色水域靠近岛内，此处盛产大闸蟹，但偶尔有毒蛇伤人事件' },
    {unit: 3, name: '空岛旅行会社', threshold: 1500000, dealWeek: 3, quantity: 0, price: 60, basePrice: 60, flow: 3, state: null, fluctuation: 0.03, quality: 'medium', url:'https://pic.imgdb.cn/item/66ea482af21886ccc02b21b3.png', des:'受天空眷顾的一族——羽族聚居地，此处由悬空浮岛组成，是天书大陆旅游业最繁荣的地方' },
    {unit: 4, name: '金港码头集团', threshold: 3000000, dealWeek: 3, quantity: 0, price: 150, basePrice: 150, flow: 7, state: null, fluctuation: 0.03, quality: 'medium', url:'https://pic.imgdb.cn/item/66e9380cf21886ccc0ca0045.png', des:'作为朝云国最繁华的港口，是资本主义萌芽的地方。广负盛名的朝云商会在此地驻扎，令外贸成为朝云国的支柱产业之一' },
    {unit: 5, name: '皇城地产控股', threshold: 5000000, dealWeek: 5, quantity: 0, price: 300, basePrice: 300, flow: 15, state: null, fluctuation: 0.03, quality: 'good', url:'https://pic.imgdb.cn/item/66e9380cf21886ccc0ca001a.png', des:'无论过去还是未来，房地产都是永恒的王牌' },
    {unit: 6, name: '星之海托拉斯', threshold: 10000000, dealWeek: 5, quantity: 0, price: 1000, basePrice: 1000, flow: 30, state: null, fluctuation: 0.03, quality: 'good', url:'https://pic.imgdb.cn/item/66e9380cf21886ccc0c9ffba.png', des:'天书大航海时代来临，投资你的海底掘金企业，征战星辰和大海' },
];

let isStock = false;

function openStockPanel() {
    const middleWrap = document.getElementById('scalping-middle-wrap');
    const stockButton = document.getElementById('open-stock-button');

    if (scalpingState.currentSellingWeek === 0 && stockButton.innerText === '投资股票') {
        showMerchant('至少在市场积累一周的经商经验才能进入股市！');
        return;
    }
    
    if (!isStock) {
        hideMiddleWrapElement();
        setTimeout(() => updateStockPanelDisplay(), 0); // 使用箭头函数，确保函数在setTimeout后执行
        isStock = true;
        stockButton.innerText = '返回市场';
    } else {
        showMiddleWrapElement();
        isStock = false;
        stockButton.innerText = '投资股票';
    }
}

function hideMiddleWrapElement() {
    const middleWrapElement = document.getElementById('scalping-middle-wrap');
    middleWrapElement.style.display = 'none';  // 隐藏原有内容
    
}

function showMiddleWrapElement() {
    const middleWrapElement = document.getElementById('scalping-middle-wrap');
    const upperArea = document.getElementById('scalping-upper-area');
    const stockPanel = document.getElementById('general-stock-panel');
    upperArea.removeChild(stockPanel);
    middleWrapElement.style.display = 'flex';  // 恢复显示原有内容
    
}
        
function resetStockState() {
    stockList = [
        {unit: 1, name: '影月坊工作室', threshold: 100000, dealWeek: 2, quantity: 0, price: 0.5, basePrice: 0.5, flow: 0.05, state: null, fluctuation: 0.03, quality: 'bad', url:'https://pic.imgdb.cn/item/66e9380df21886ccc0ca0085.png', des:'靠山吃山，靠水吃水。北影月村民坐拥两大野生森林，大力发展纺织业，男耕女织自给自足' },
        {unit: 2, name: '黑水水产商行', threshold: 500000, dealWeek: 3, quantity: 0, price: 10, basePrice: 10, flow: 0.15, state: null, fluctuation: 0.03, quality: 'medium', url:'https://pic.imgdb.cn/item/66e9380cf21886ccc0ca0060.png', des:'灵仙岛岛民在仙人飞升成名前一直以捕鱼为业，黑色水域靠近岛内，此处盛产大闸蟹，但偶尔有毒蛇伤人事件' },
        {unit: 3, name: '空岛旅行会社', threshold: 1500000, dealWeek: 3, quantity: 0, price: 60, basePrice: 60, flow: 3, state: null, fluctuation: 0.03, quality: 'medium', url:'https://pic.imgdb.cn/item/66ea482af21886ccc02b21b3.png', des:'受天空眷顾的一族——羽族聚居地，此处由悬空浮岛组成，是天书大陆旅游业最繁荣的地方' },
        {unit: 4, name: '金港码头集团', threshold: 3000000, dealWeek: 3, quantity: 0, price: 150, basePrice: 150, flow: 7, state: null, fluctuation: 0.03, quality: 'medium', url:'https://pic.imgdb.cn/item/66e9380cf21886ccc0ca0045.png', des:'作为朝云国最繁华的港口，是资本主义萌芽的地方。广负盛名的朝云商会在此地驻扎，令外贸成为朝云国的支柱产业之一' },
        {unit: 5, name: '皇城地产控股', threshold: 5000000, dealWeek: 5, quantity: 0, price: 300, basePrice: 300, flow: 15, state: null, fluctuation: 0.03, quality: 'good', url:'https://pic.imgdb.cn/item/66e9380cf21886ccc0ca001a.png', des:'无论过去还是未来，房地产都是永恒的王牌' },
        {unit: 6, name: '星之海托拉斯', threshold: 10000000, dealWeek: 5, quantity: 0, price: 1000, basePrice: 1000, flow: 30, state: null, fluctuation: 0.03, quality: 'good', url:'https://pic.imgdb.cn/item/66e9380cf21886ccc0c9ffba.png', des:'天书大航海时代来临，投资你的海底掘金企业，征战星辰和大海' },
    ];
}

function resetDealWeek(stock) {
    const dealWeekOfStock = {
        '影月坊工作室': 2,
        '黑水水产商行': 3,
        '空岛旅行会社': 3,
        '金港码头集团': 3,
        '皇城地产控股': 5,
        '星之海托拉斯': 5
    };

    // 检查是否有 '资本运作' 装备
    const zibenyunzuo = scalpingState.gadgets.find(gadget => gadget === '资本运作');
    
    if (zibenyunzuo) {
        // 对每个公司名称对应的 dealWeek 值减少 1
        Object.keys(dealWeekOfStock).forEach(key => {
            if (dealWeekOfStock[key] > 1) {  // 确保不减少到小于 1
                dealWeekOfStock[key] -= 1;
            }
        });
    }

    // 设置当前股票的 dealWeek
    stock.dealWeek = dealWeekOfStock[stock.name] || 0;  // 如果找不到公司名，默认值为 0

    console.log(stock.dealWeek);
}

let keyPhaseCount = 0;
        
function updateStockPrice() {
    let info = [];
    let randomActivate = false;
    stockList.forEach(stock => {
        const basePrice = parseFloat(stock.basePrice) || 1;
        const caopanjubo = scalpingState.gadgets.find(gadget => gadget === '操盘巨擘');

        let gadgetBonus = 0;
        if (caopanjubo) gadgetBonus = 3;
        
        if (scalpingState.currentSellingWeek > 30 && scalpingState.currentSellingWeek <= 36 + gadgetBonus) {
            
            stock.basePrice = enterStockKeyPhase(stock);
            
            if (basePrice < stock.basePrice) {
                stock.state = 'higher';
            } else {
                stock.state = 'lower';
            } 
            return;
        }
        
        // 计算波动幅度，确保波动的方向有可能为负（即下跌）
        const fluctuation = Math.random() * stock.fluctuation * (Math.random() < 0.5 ? -1 : 1);
        
        // 累积增长
        const fixedAccumulation = stock.flow;

        // 根据质量决定价格下跌的概率
        const randomVal = Math.random();
        let ratio = 1;
        
        if (stock.quality === 'bad') {
            ratio = randomVal < 0.5 ? -1 : 1;  // bad 质量有 50% 可能跌价
        } else if (stock.quality === 'medium') {
            ratio = randomVal < 0.3 ? -1 : 1;  // medium 质量有 30% 可能跌价
        } else {
            ratio = randomVal < 0.1 ? -1 : 1;  // good 质量有 10% 可能跌价
        }

        // 计算基础价格，波动与累积的影响
        let stockPrice; 

        if (Math.random() < 0.05 && !currentInfoBox && !randomActivate) {
            stockPrice = basePrice + generateStockRandomEvent(stock);
            randomActivate = true;
        } else {
            stockPrice = basePrice + (basePrice * fluctuation * ratio) + (fixedAccumulation * ratio);
        }
        
        if (basePrice < stockPrice) {
            stock.state = 'higher';
        } else {
            stock.state = 'lower';
        }
        
        // 确保价格不会跌到负数
        stock.basePrice = Math.max(parseFloat(stockPrice.toFixed(2)), 0);
        info.push(`${stock.name}: 上周股价${basePrice},本周股价${stock.basePrice},股价状态为${stock.state === 'higher' ? '涨' : '跌'}`);
        
        if (keyPhaseCount !== 0) keyPhaseCount = 0;
    });
    
    // console.log(info);
    updateStockPanelDisplay();
}

function enterStockKeyPhase(stock) {
    const goodPhase = calculateNetAsset() > 5000000;
    if (goodPhase) {
        stock.basePrice *= (Math.random() * 0.05 + 1.01);
    } else {
        stock.basePrice *= (Math.random() * 0.05 + 0.8);
    }

    if (keyPhaseCount === 0) {
        if (!currentInfoBox) {
            showMerchant(goodPhase ? '【证券要闻】经济强势，证券市场进入牛市周期！' : '【证券要闻】经济萧条，证券市场进入熊市周期！');
        } else {
            setTimeout(() => {
                showMerchant(goodPhase ? '【证券要闻】经济强势，证券市场进入牛市周期！' : '【证券要闻】经济萧条，证券市场进入熊市周期！');
            }, 1000);
        }
        
        keyPhaseCount ++;
    }
    
    return parseFloat(stock.basePrice.toFixed(2)); //parseFloat处理小数，int处理字符串
}
        
function updateStockPanelDisplay() { 
    const upperArea = document.getElementById('scalping-upper-area');
    const middleWrapElement = document.getElementById('scalping-middle-wrap');
    if (middleWrapElement.style.display !== 'none') {
        return;
    }
    
    const existingStockPanel = document.getElementById('general-stock-panel');
    if (existingStockPanel) {
        upperArea.removeChild(existingStockPanel);
    }

    const stockPanel = document.createElement('div');
    stockPanel.id = 'general-stock-panel';
    stockPanel.style = 'display: flex;width: 90%;padding: 10px;border: 2px solid rgb(111, 57, 28);gap: 5px;max-height: 360px;overflow-y: scroll;flex-flow: column;background-image: url(https://pic.imgdb.cn/item/66da9042d9c307b7e9e14b2b.png);color: white;'; // 设置股票面板显示
    stockPanel.innerHTML = ''; // 清空现有内容

    stockList.forEach(stock => {
        const stockDivContainer = document.createElement('div');
        stockDivContainer.id = `stock-${stock.unit}-container`;
        stockDivContainer.style = 'display: flex;flex-direction: row;justify-content: space-between;width: 100%;';

        // 企业名称部分
        const stockDiv = document.createElement('div');
        stockDiv.style = 'display: flex;gap: 5px;flex-direction: row-reverse;align-items: center;font-size: 14px;cursor: pointer;width: 35%;justify-content: space-between;position: relative;'; // 添加 position: relative
        stockDiv.innerText = `${stock.name}`;
        stockDiv.addEventListener('click', () => {
            showMerchant(`${stock.des}`);
        })
        stockDivContainer.appendChild(stockDiv);
        
        // 企业图片部分
        const stockImg = document.createElement('img');
        stockImg.src = stock.url;
        stockImg.style.width = '45px';
        stockImg.style.height = '45px';
        stockImg.style.border = '1px solid black';
        stockDiv.appendChild(stockImg);
        
        // 显示ROI百分比部分
        const stockROI = document.createElement('div');
        stockROI.style.position = 'absolute';
        stockROI.style.top = '75%';
        stockROI.style.left = '20%';
        stockROI.style.transform = 'translate(-50%, -50%)'; // 修正拼写错误
        stockROI.innerText = `${(stock.basePrice >= stock.price ? 
            ((stock.basePrice - stock.price) / stock.price * 100).toFixed(1) : 
            ((stock.basePrice - stock.price) / stock.price * 100).toFixed(1))}%`;
        stockROI.style.textShadow = '-1px -1px 0 black, 1px -1px 0 black, -1px 1px 0 black, 1px 1px 0 black';
        stockROI.style.color = `${stock.price >= stock.basePrice ? 'lime' : '#FF4500'}`;
        stockROI.style.fontSize = '12px'; 
        stockROI.style.width = '45px'; 
        stockROI.style.textAlign = 'center'; 
        stockDiv.appendChild(stockROI); // 将 stockROI 添加到 stockDiv 而非 stockImg
        

        // 股票详细信息部分
        const stockDetail = document.createElement('div');
        stockDetail.style = 'display: flex;gap: 10px;flex-direction: row;padding: 5px;align-items: center;font-size: 14px;width: 65%;justify-content: space-between;flex-wrap: nowrap;';
        stockDivContainer.appendChild(stockDetail);

        // 股票基础价格
        const stockPrice = document.createElement('div');
        stockPrice.innerText = `${stock.basePrice}元 ${stock.state === 'higher' ? '↑' : '↓'}`;
        stockPrice.style.color = `${stock.state === 'higher' ? '#FF4500' : 'lime'}`;
        stockDetail.appendChild(stockPrice);

        const stockOwned = document.createElement('div');
        stockOwned.innerText = `持有${stock.quantity}股`;
        stockDetail.appendChild(stockOwned);

        // 购买按钮
        const buttonContainer = document.createElement('div');
        buttonContainer.style = 'display: flex;gap: 4px;flex-direction: column;width:45px;';
        
        const buyStockBtn = document.createElement('button');
        buyStockBtn.innerText = '买入';
        buyStockBtn.style = 'height: 22px;font-size: 12px;padding: 0;';
        buyStockBtn.addEventListener('click', () => {
            handleStockPurchase(stock);
            console.log('买入股票', stock.name);
        });
        buttonContainer.appendChild(buyStockBtn);

        const sellStockBtn = document.createElement('button');
        sellStockBtn.innerText = '卖出';
        sellStockBtn.style = 'height: 22px;font-size: 12px;padding: 0;';
        sellStockBtn.addEventListener('click', () => {
            handleStockSell(stock);
            console.log('卖出股票', stock.name);
        });
        buttonContainer.appendChild(sellStockBtn);
        
        stockDetail.appendChild(buttonContainer);
        stockPanel.appendChild(stockDivContainer);
        upperArea.appendChild(stockPanel);
    });
}

function generateStockRandomEvent(stock) {
    const stockName = stock.name;
    const stockOriginalPrice = stock.basePrice;
    let stockPriceAfterEvent = stockOriginalPrice;
    const playerReputation = calculatePlayerReputation();
    const repBonus = playerReputation * 0.000001; //定义声望的正向影响

    // 随机生成是好事件还是坏事件，50%几率
    const isGoodEvent = Math.random() < Math.min(0.8, 0.5 + repBonus);
    let eventEffect = 0;
    let detail = '';

    const showDetail = () => {
        showInfoBox(`【证券要闻】${detail}`, null, null, `${isGoodEvent ? 'red' : 'green'}`, stock.url, '88px * 88px');
    };

    if (isGoodEvent) {
        // 好事件：根据 fluctuation 和 flow 调整价格
        switch (stockName) {
            case '影月坊工作室':
                eventEffect = stock.fluctuation * stock.flow * (Math.random() * 0.5 + 0.5) + stock.flow;
                detail = `${stockName}在政府环保政策的扶持下，推出了绿色纺织项目，得到了市场的广泛欢迎，股价强劲上涨: +${eventEffect.toFixed(2)}元。`;
                break;
            case '黑水水产商行':
                eventEffect = stock.fluctuation * stock.flow * (Math.random() * 0.7 + 0.3) + stock.flow;
                detail = `${stockName}近期大闸蟹的市场需求大增，销量创下新高，公司的收益大幅增长，股价强劲上涨: +${eventEffect.toFixed(2)}元。`;
                break;
            case '金港码头集团':
                eventEffect = stock.fluctuation * stock.flow * (Math.random() * 1.0 + 0.5) + stock.flow;
                detail = `${stockName}获得大量的国际贸易订单，外贸业务激增，带来了可观的利润，股价强劲上涨: +${eventEffect.toFixed(2)}元。`;
                break;
            case '空岛旅行会社':
                eventEffect = stock.fluctuation * stock.flow * (Math.random() * 1.2 + 0.8) + stock.flow;
                detail = `${stockName}的旅游业务在假期高峰期中蓬勃发展，旅游区人满为患，收入大幅增长，股价强劲上涨: +${eventEffect.toFixed(2)}元。`;
                break;
            case '皇城地产控股':
                eventEffect = stock.fluctuation * stock.flow * (Math.random() * 1.5 + 1.0) + stock.flow;
                detail = `${stockName}在房地产政策宽松的背景下，投资热潮推动了地产股的强劲上涨，股价强劲上涨: +${eventEffect.toFixed(2)}元。`;
                break;
            case '星之海托拉斯':
                eventEffect = stock.fluctuation * stock.flow * (Math.random() * 2.0 + 1.5) + stock.flow;
                detail = `${stockName}的海底开采技术取得突破，开采效率大幅提高，利润翻倍，股价强劲上涨: +${eventEffect.toFixed(2)}元。`;
                break;
        }
        stockPriceAfterEvent = eventEffect;
    } else {
        // 坏事件：根据 fluctuation 和 flow 调整价格
        switch (stockName) {
            case '影月坊工作室':
                eventEffect = stock.fluctuation * stock.flow * (Math.random() * 0.5 + 0.5) - stock.flow;
                detail = `${stockName}的野生森林资源遭到破坏，导致纺织原材料短缺，公司业绩下滑，股价大幅下跌: ${eventEffect.toFixed(2)}元。`;
                break;
            case '黑水水产商行':
                eventEffect = stock.fluctuation * stock.flow * (Math.random() * 0.7 + 0.3) - stock.flow;
                detail = `${stockName}的水域受到污染，导致水产减产，公司利润大幅减少，股价大幅下跌: ${eventEffect.toFixed(2)}元。`;
                break;
            case '金港码头集团':
                eventEffect = stock.fluctuation * stock.flow * (Math.random() * 1.0 + 0.5) - stock.flow;
                detail = `${stockName}遭遇国际贸易摩擦，出口订单大幅减少，收入骤减，股价大幅下跌: ${eventEffect.toFixed(2)}元。`;
                break;
            case '空岛旅行会社':
                eventEffect = stock.fluctuation * stock.flow * (Math.random() * 1.2 + 0.8) - stock.flow;
                detail = `${stockName}的旅游区遭遇了天灾，游客量锐减，公司收入受到严重影响，股价大幅下跌: ${eventEffect.toFixed(2)}元。`;
                break;
            case '皇城地产控股':
                eventEffect = stock.fluctuation * stock.flow * (Math.random() * 1.5 + 1.0) - stock.flow;
                detail = `${stockName}遭遇房地产市场泡沫破裂，投资者纷纷撤资，股价大幅下跌: ${eventEffect.toFixed(2)}元。`;
                break;
            case '星之海托拉斯':
                eventEffect = stock.fluctuation * stock.flow * (Math.random() * 2.0 + 1.5) - stock.flow;
                detail = `${stockName}的海底资源逐渐枯竭，导致公司的开采成本激增，利润急剧下滑，股价大幅下跌: ${eventEffect.toFixed(2)}元。`;
                break;
        }
        stockPriceAfterEvent =  eventEffect;
    }

    // 展示详细事件信息
    showDetail();

    return stockPriceAfterEvent; // 返回两位小数的股价
}
        
function handleStockPurchase(stock) {
    const revokeSandIndex = scalpingState.gadgets.indexOf('唤神砂');
    // 再检查玩家精力
    if (scalpingState.playerEnergy <= 60) {
        if (revokeSandIndex !== -1) {
            handleItemTransaction(item, null, 'purchase');
            // 使用 splice 来删除 "唤神砂"
            scalpingState.gadgets.splice(revokeSandIndex, 1);
        } else {
            showMerchant('不要这么殚精竭虑，你需要好好休息一下！');
        }
        return;
    }
    
    // 检查用户的现金是否足够
    if (scalpingState.currentCash < stock.threshold && stock.quantity < 1) {
        showMerchant(`投资有风险，没有一定的本金抵御风险可不行！这支股票要求你的本金至少为${stock.threshold}元！`);
        return;
    }

    // 检查是否已经持有其他股票，避免同时投资多支股票
    //const hasActiveStock = stockList.some(s => s.quantity !== 0 && s.name !== stock.name);
    //if (hasActiveStock) {
        //showMerchant('目前你已经有一支股票在运作，不能再投资其他企业！');
        //return;
    //}
    
    if (stock.dealWeek > 0) {
        showInfoBox(`这支股票在投资后需要至少${stock.dealWeek}周后才能进行交易，确认请继续`,
           () => handleStockTransaction(stock, 'purchase'),
           null,'red');
    } else {
        handleStockTransaction(stock, 'purchase');
    }
}

function handleStockSell(stock) {
    const revokeSandIndex = scalpingState.gadgets.indexOf('唤神砂');
    // 再检查玩家精力
    if (scalpingState.playerEnergy <= 60) {
        if (revokeSandIndex !== -1) {
            handleItemTransaction(item, null, 'purchase');
            // 使用 splice 来删除 "唤神砂"
            scalpingState.gadgets.splice(revokeSandIndex, 1);
        } else {
            showMerchant('不要这么殚精竭虑，你需要好好休息一下！');
        }
        return;
    }

    if (stock.dealWeek > 0) {
        showMerchant(`你投资的企业还在建设中，需要${stock.dealWeek}周后才能交易！`);
        return;
    }
        
    handleStockTransaction(stock);
}

function handleStockTransaction(item, actionType) {
    // 判断行为类型：购买或出售
    const isPurchase = actionType === 'purchase';

    if (currentSlider) {
        document.body.removeChild(currentSlider);
        currentSlider = null;
    }

    // 获取或创建进度条
    let sliderContainer = document.getElementById(`${actionType}-slider-container`);
    if (!sliderContainer) {
        sliderContainer = document.createElement('div');
        sliderContainer.id = `${actionType}-slider-container`;
        sliderContainer.style = 'display: flex;position: fixed;top: 50%;left: 50%;transform: translate(-50%, -50%);width: 80%;max-height: 80%;min-height: 10%;z-index: 9999;font-size: 14px;padding: 10px 20px 5px;background-color: rgb(223, 191, 110);color: rgb(146, 52, 28);background-image: url(https://pic.imgdb.cn/item/663885620ea9cb14033e4f6e.png);background-repeat: repeat;background-size: auto;box-shadow: rgb(30, 46, 47) 0px 0px 0px 1px, rgb(111, 57, 28) 0px 0px 0px 1px inset;border: 1px solid rgb(235, 172, 59);overflow-y: auto;flex-direction: column;align-items: center;gap: 5px;';

        const sliderLabel = document.createElement('label');
        sliderLabel.innerText = `拖动${isPurchase ? '购买' : '出售'}数量：`;
        sliderContainer.appendChild(sliderLabel);

        const slider = document.createElement('input');
        slider.id = `${actionType}-slider`;
        slider.type = 'range';
        slider.min = 0;
        slider.max = 100;
        slider.value = 0;
        slider.style = 'width: 90%;appearance: none;border-radius: 20px;border: 1px groove #0475ff;box-shadow: inset 0px 0px 2px 1px #0475ff;';
        sliderContainer.appendChild(slider);

        const quantityLabel = document.createElement('div');
        quantityLabel.id = `${actionType}-quantity-label`;
        quantityLabel.innerText = `${isPurchase ? '购买' : '出售'}数量: 0, 预计金额: 0`;
        sliderContainer.appendChild(quantityLabel);

        const itemDescription = document.createElement('div');
        itemDescription.id = `${actionType}-item-description`;
        itemDescription.innerText = `企业说明: ${item.des}`;
        sliderContainer.appendChild(itemDescription);

        const confirmButton = document.createElement('button');
        confirmButton.id = `confirm-${actionType}-button`;
        confirmButton.style = 'border: 1px solid #6F391C;background: linear-gradient(to bottom, #E47F47, #CE6633, #963D1C);box-shadow: inset 0px 0px 2px 1px #87431F;font-size: 14px;border-radius: 5px;color: #F9DE9B;padding: 4px 6px;cursor: pointer;transition: transform 0.1s, box-shadow 0.1s;';
        confirmButton.innerText = `确认${isPurchase ? '购买' : '出售'}`;
        sliderContainer.appendChild(confirmButton);
        
        document.body.appendChild(sliderContainer);
    }
    
    sliderContainer.style.display = 'flex'; // 显示进度条
    const slider = document.getElementById(`${actionType}-slider`);
    const quantityLabel = document.getElementById(`${actionType}-quantity-label`);
    
    currentSlider = sliderContainer;

    let maxQuantity, price;

    if (isPurchase) {
        price = item.basePrice.toFixed(2); 
        maxQuantity = Math.floor(scalpingState.currentCash / price); // 最大可购买数量
    } else {
        price = item.basePrice.toFixed(2);
        maxQuantity = item.quantity || 0; // 最大可出售数量
    }

    // 监听进度条变化
    slider.addEventListener('input', (event) => {
        const percentage = event.target.value;
        const quantity = Math.floor((percentage / 100) * maxQuantity);
        const totalPrice = Math.floor(price * quantity);
    
        quantityLabel.innerText = `${isPurchase ? '购买' : '出售'} ${quantity} 手, 预计金额: ${totalPrice}元, ${isPurchase ? '' : `税费预估为${(totalPrice * 0.1).toFixed(2)}元`}`;
    });

    // 点击确认购买/出售
    document.getElementById(`confirm-${actionType}-button`).addEventListener('click', () => {
        const quantity = Math.floor((slider.value / 100) * maxQuantity);
        if (quantity > 0) {
            if (isPurchase) {
                // 执行购买逻辑
                const totalCost = quantity * price;
                scalpingState.currentCash -= Math.floor(totalCost);
                item.quantity += quantity;
     
                updateScalpingPanel();
                updateStockPanelDisplay();
            } else {
                // 执行出售逻辑
                const totalSaleValue = quantity * price;
                const kaimanzhizhao = scalpingState.gadgets.find(gadget => gadget === '开曼岛执照');
                
                let incomeAfterTaxRatio = 0.9;
                if (kaimanzhizhao) incomeAfterTaxRatio = 0.95;
                
                scalpingState.currentCash += Math.floor(totalSaleValue * incomeAfterTaxRatio);
                item.quantity -= quantity;

                if (item.quantity === 0) resetDealWeek(item);
                if (stockList.filter(s => s.quantity > 0).length === 1) {
                    document.getElementById('stock-info-display').innerText = `当前持有${item.quantity}手${item.name}的股票`;
                } else {
                    document.getElementById('stock-info-display').innerText = `当前总计持有${stockList.filter(s => s.quantity > 0).length}支股票`;
                }
                updateScalpingPanel();
                updateStockPanelDisplay();
            }
            sliderContainer.style.display = 'none'; // 完成后隐藏进度条
        } else if (currentSlider) {
                document.body.removeChild(currentSlider);
                currentSlider = null;
        }
    });
}
        
//倒买倒卖的逻辑
function openScalping(closeButton = false) {
    const scalpingWindow = document.getElementById('scalping-display');
    const isOpen = scalpingWindow.style.display === 'flex';
    const toggleWindow = () => {
        scalpingWindow.style.display = isOpen ? 'none' : 'flex'; // 根据状态切换显示
        updateScalpingPanel();
    };

    if (closeButton) {
        toggleWindow(); // 点击关闭按钮时，直接切换显示状态
        return;
    }

    showInfoBox(
        '你要花多长时间，才能赚到一个小目标？\n\n人生在世，利字当头。逐鹿沙场固然澎湃，商场沉浮亦令人执迷。\n\n在这个界面内，你将花费一年时间（52周）体验投资的经历 \n\n中途离开不会删除数据，但刷新页面会清空你的仓库和资产，请知悉 \n\n游戏中的现金可以无手续费兑换为金子，但尚未变现的资产（仓库货物）在游戏结束时将会以一定折扣进行变卖',
        toggleWindow  // 信息框确认后，执行窗口切换
    );
}

function showInfoScalping() {
    const comment = updateHighestAssetDisplay(highestAsset, false) || '目前你还没有收到任何评价！';
    const message = `
        欢迎来到自由经商的功能面板！当前你的最高记录是${highestAsset.toLocaleString('en-US')}元，商界人士对你的评价是：${comment}！
        
        1. 你可以在此处刷新商品，在低位时购入，高位时果断抛出。
        2. 每次经商时长为52周，每周会根据仓库容量收取一定租金。
        3. 每周市面上的道具和需求都会变化，还会有各种随机事件影响价格。
        4. 你可以在任何时刻补充你的启动资金。
        5. 使用法宝可以让你的经商之路更加顺利。
        6. 经商时间结束时，将无法再刷新道具。
        7. 仓库的货品、未出售的股票在游戏结束时，会作为未变现资产产生折扣
        7. 如果不想玩了，可以点击提前退市计算收益，但会受到一定的违约金惩罚。
        8. 现金积累到一定程度，可以尝试投资股票。
        9. 在经商面板购买的商品都只供销售使用哦。`;
    showMerchant(message);
}
        
function increaseInverstment() {
    if (goldAmount >= 50000) {
        showInfoBox(`\n在自由市场，1文金子=1元，每次最少投资50000元。\n\n当总资产到达20万或投资次数达到5次时，将不允许追加投资。\n\n你还可以投资${Math.max(0, 5-scalpingState.investmentCount)}次，准备好注资50000元了吗？`,
                   () => {
                       if (scalpingState.investmentCount >= 5) {
                           showMerchant('本年度投资次数已经耗尽！');
                           return;
                       }
                       
                       if (calculateNetAsset() >= 200000) {
                           showMerchant('当前总资产超过20万，不支持天使投资！');
                           return;
                       } else {
                           goldAmount -= 50000;
                           scalpingState.currentCash += 50000;
                           scalpingState.investmentCount ++;
                           updateScalpingPanel();
                           updateGoldDisplay(goldAmount);
                           showMerchant('注入一笔天使投资，祝你的生意做大做强！');
                       }
                   },
                   () => {
                       showMerchant('天使投资人，期待你的眼光能带来真正的价值！');
                   },
                   null,
                   'https://pic.imgdb.cn/item/66e32523d9c307b7e995cf28.png',
                   '88px * 88px');
    } else {
        showMerchant('你的启动资金还不足50两金子，尚不能成为天使投资人');
    }
}

function closeGagdetsPanel() {
    const gadgetsContainer = document.getElementById('gadgets-selector');
    gadgetsContainer.style.display = 'none';
}

function selectSaclpingGadgets() {
    const gadgets = jinnangItems.filter(item => item.description.includes('【经商法宝】') && item.quantity >= 1);
    const gadgetsWholeContainer = document.getElementById('gadgets-selector');
    const gadgetsContainer = document.getElementById('selected-gadgets');
    gadgetsContainer.innerHTML = ''; // 清空现有内容
    
    // 使用 gadgets 数组直接，不需要额外赋值给 selectedGadgets
    if (gadgets.length === 0) {
        showMerchant('暂时没有可用法宝，你可以在法宝商店使用经商积分进行购买');
    }
    gadgetsWholeContainer.style.display = 'flex';
    
    gadgets.forEach(gadget => {
        const gadgetElement = document.createElement('div');
        gadgetElement.className = 'selected-gadgets';
        gadgetElement.style = 'display: flex;justify-content: space-between;font-size: 14px;align-items: center;margin-bottom: 10px;border: 1px solid #6f391c;padding: 5px;';
        gadgetElement.innerHTML = `
            <div id="${gadget.name}-container" style="cursor: pointer;margin-right: 10px;width: 20%;height: 100%;">
                <img src="${gadget.url}" alt="${gadget.name}" style="width: 45px; height: 45px; border: 1px solid #6f391c" />
                <div>${gadget.displayName}</div>
            </div>
            <div id="description-${gadget.name}" style="width: 80%;height: 100%;text-align: start;">${gadget.description}，拥有：${gadget.quantity}个 </div>
        `;

        // 点击法宝时弹出应用面板
        gadgetElement.addEventListener('click', () => {
            const appliedGadgetsContainer = document.getElementById('applied-scalping-gadgets');
            // 修改为 < 3，避免等于3时继续添加
            if (scalpingState.gadgets.length < 3 && !scalpingState.gadgets.includes(gadget.displayName)) {
                scalpingState.gadgets.push(gadget.displayName);
                const appliedGadgetsElement = document.createElement('div');
                appliedGadgetsElement.style = 'display: flex;justify-content: space-between;align-items: center;font-size: 14px;';
                
                // 修复：只更新子元素，而不是整个 gadgetElement 的内容
                const imgElement = document.createElement('img');
                imgElement.src = gadget.url;
                imgElement.alt = gadget.name;
                imgElement.style = 'width: 25px; height: 25px; border: 1px solid #6f391c; cursor: pointer;';
                appliedGadgetsElement.appendChild(imgElement);
                imgElement.addEventListener('click',() => {
                    showMerchant(`${gadget.description}`);
                })
                
                appliedGadgetsContainer.appendChild(appliedGadgetsElement);
                gadgetsWholeContainer.style.display = 'none';
                useItem(`${gadget.name}`,1);
                showMerchant(`你成功应用了${gadget.displayName}!`);
                applyGadgetEffect(gadget);
                updateScalpingPanel();
            } else {
                showMerchant('当前法宝应用数量已达上限或已有同类法宝生效！');
            }
        });

        gadgetsContainer.appendChild(gadgetElement);
        
    });
}

function applyGadgetEffect(gadget) {
    const appliedGadget = scalpingState.gadgets.find(g => g === gadget.displayName);

    if (!appliedGadget) {
        console.error(`未找到法宝: ${gadget}`);
        return;
    }
    const gadgetEffects = {
        '续租契': () => {
            scalpingState.maxSellingWeek += 4;
            updateScalpingPanel();
        },
        '特许招商令': () => {
            scalpingState.investmentCount -= 1;
            updateScalpingPanel();
        },
        '资本运作': () => {
            stockList.forEach(stock => {
                if (stock.dealWeek > 1) {
                    stock.dealWeek -= 1;
                }
            });
            updateScalpingPanel();
        }
    };

    // 检查法宝是否有对应的效果并调用
    if (gadgetEffects[appliedGadget]) {
        gadgetEffects[appliedGadget]();
    } else {
        console.error(`没有找到 ${appliedGadget} 的效果定义`);
    }
}

function exchangeGadgets() {
    const storeElement = document.getElementById('gadget-store-panel');
    storeElement.style.display = 'flex';
    updateGadgetStorePanel();
}     

function updateGadgetStorePanel() {
    const gadgets = jinnangItems.filter(item => item.description.includes('【经商法宝】'));
    const gadgetItemsArea = document.getElementById('gadget-items');
    gadgetItemsArea.innerHTML = ''; // 清空现有内容

    const gadgetPrice = [
        {name: '八方来财', price: 6000},
        {name: '强身散', price: 4500},
        {name: '英雄令', price: 4500},
        {name: '续租契', price: 16000},
        {name: '珍宝案', price: 3000},
        {name: '特许招商令', price: 3000},
        {name: '国富论', price: 15000},
        {name: '唤神砂', price: 2000},
        {name: '乾坤袋', price: 2500},
        {name: '双喜临门', price: 3000},
        {name: '资本运作', price: 7000},
        {name: '开曼岛执照', price: 7000},
        {name: '家族信托', price: 8000},
        {name: '操盘巨擘', price: 18000},
        {name: '百达翡丽', price: 25000}
    ];

    // 对 gadgets 按照价格从低到高进行排序
    gadgets.sort((a, b) => {
        const priceA = gadgetPrice.find(p => p.name === a.displayName)?.price || 0;
        const priceB = gadgetPrice.find(p => p.name === b.displayName)?.price || 0;
        return priceA - priceB;
    });

    // 生成 gadget 元素
    gadgets.forEach(gadget => {
        const priceInfo = gadgetPrice.find(p => p.name === gadget.displayName);
        const price = priceInfo ? priceInfo.price : '未知'; // 如果找不到价格则显示"未知"

        const gadgetElement = document.createElement('div');
        gadgetElement.className = 'selected-gadgets';
        gadgetElement.style = 'display: flex; justify-content: space-between; font-size: 14px; align-items: center; margin-bottom: 10px; border: 1px solid rgb(111, 57, 28); padding: 5px;';
        gadgetElement.innerHTML = `
            <div id="${gadget.name}-container" style="cursor: pointer;margin-right: 10px;width: 20%;height: 100%;">
                <img src="${gadget.url}" alt="${gadget.name}" style="width: 45px; height: 45px; border: 1px solid #6f391c" />
                <div>${gadget.displayName}</div>
            </div>
            <div id="description-${gadget.name}" style="width: 80%;height: 100%;text-align: start;">${gadget.description}，售价：${price} 积分。</div>
        `;
        gadgetItemsArea.appendChild(gadgetElement);

        gadgetElement.addEventListener('click', () => {
            if (price === '未知') {
                showMerchant('此法宝无法购买，价格未知！');
                return;
            }

            showInfoBox(`是否花费${price}积分购买一个${gadget.displayName}？`,
                       () => {
                           if (scalpingScore < price) {
                               showMerchant('你的经商积分不足！请多多使用经商功能积累积分！');
                           } else {
                               scalpingScore -= price;
                               addItemToJinnang(gadget.name, 1);
                               showMerchant(`成功花费${price}积分购买一个${gadget.displayName}！剩余积分${scalpingScore}。`);
                               selectSaclpingGadgets();
                               updateScalpingPanel(); // 在成功购买后更新面板
                           }
                       },
                       null, null, 'https://pic.imgdb.cn/item/66e32523d9c307b7e995cf28.png', '88px * 88px');
        });
    });
}

        
document.getElementById('close-gagdet-store').addEventListener('click', () => {
    const storeElement = document.getElementById('gadget-store-panel');
    storeElement.style.display = 'none';
})
        
// 根据波动计算商品价格
function getScalpableItemsPrice(item, isSpecial = false) {
    let fluctuationRange = 0;
    let price = 0;
    const playerReputation = calculatePlayerReputation();
    const repBonus = playerReputation * 0.000001; //定义声望的正向影响
    if (isSpecial) {
        if (Math.random() < Math.min(0.8, 0.5 + repBonus)) {
            fluctuationRange = item.basePrice * item.fluctuation;
            price = Math.floor((item.basePrice + (Math.random() * (2 * fluctuationRange) - fluctuationRange)) * 0.2 * item.downRate);
            showMerchant(`${item.badEvent}`);
        } else {
            fluctuationRange = item.bonusPrice * item.fluctuation;
            price = item.bonusPrice + (Math.random() * (2 * fluctuationRange) - fluctuationRange);
            showMerchant(`${item.goodEvent}`);
        }
    } else {
        fluctuationRange = item.basePrice * item.fluctuation;
        price = item.basePrice + (Math.random() * (2 * fluctuationRange) - fluctuationRange);
    }

    return Math.floor(price);
}

function generateItemToDisplay() {
    if (scalpingState.currentSellingWeek !== 0) {
        showMerchant('正在本年度的商品运作中，无法更换商品！');
        return;
    }
    const selectedItems = scalpingItems.filter(i => i.itemActivate);
    const parentPanel = document.getElementById('scalping-display');
    const existingPanel = document.getElementById('select-scalping-item-panel');
    if (existingPanel) parentPanel.removeChild(existingPanel);

    const selectPanel = document.createElement('div');
    selectPanel.id = "select-scalping-item-panel";
    selectPanel.innerText = `请为你的企业选品 ${selectedItems.length} / 6`;
    selectPanel.style = "flex-flow: wrap;gap: 10px;position: fixed;top: 50%;left: 50%;transform: translate(-50%, -50%);width: 100%;display: flex;background: url('https://pic.imgdb.cn/item/66ea60acf21886ccc04b6877.jpg') center center / cover no-repeat rgba(0, 0, 0, 0.8);padding: 2px;border-radius: 2px;color: #fff;font-size: 16px;height: 100%;align-items: center;place-content: center;text-shadow: -1px -1px 0 black, 1px -1px 0 black, -1px 1px 0 black, 1px 1px 0 black;";

    const selectPanelContainer = document.createElement('div');
    selectPanelContainer.style = "display: grid;grid-template-columns: repeat(4, 1fr);align-content: space-between;width: 100%;justify-items: center;background-color: rgba(0, 0, 0, 0.1);height: 360px;overflow-y: scroll;";
    
    const closeBtn = document.createElement('button');
    closeBtn.style = 'border: 1px solid rgb(111, 57, 28);background: linear-gradient(rgb(228, 127, 71), rgb(206, 102, 51), rgb(150, 61, 28));box-shadow: rgb(135, 67, 31) 0px 0px 2px 1px inset;font-size: 14px;border-radius: 5px;color: rgb(249, 222, 155);padding: 4px;cursor: pointer;transition: transform 0.1s, box-shadow 0.1s;';
    closeBtn.innerText = '关闭窗口';
    closeBtn.addEventListener('click', () => {
        parentPanel.removeChild(selectPanel);
    });
    selectPanel.appendChild(closeBtn);
    
    scalpingItems.forEach(item => {
        // 创建容器
        const itemContainer = document.createElement('div');
        itemContainer.id = `${item.name}-option`;
        itemContainer.style = "display: flex;height: 100px;width: 80px;flex-flow: column;justify-content: space-between;padding: 5px;gap: 2px;align-items: center;";
        
        // 创建内部容器
        const innerContainer = document.createElement('div');
        innerContainer.style = "display: flex;flex-direction: column;align-items: center;align-content: center;justify-content: space-between;flex-wrap: wrap;text-wrap: nowrap;text-overflow: ellipsis;gap: 5px; font-size:14px;";
        
        // 创建图片元素
        const imgElement = document.createElement('img');
        imgElement.src = item.url;
        imgElement.alt = item.name;
        imgElement.style.width = "45px";
        imgElement.style.height = "45px";
        imgElement.style.cursor = "pointer";
        imgElement.style.border = "1px solid black";
        imgElement.style.boxShadow = `${item.itemActivate? '#f5fffa 0px 0px 2px 2px' : ''}`;
        imgElement.addEventListener('click', () => {
            showMerchant(`${item.name}: 单品均价${item.basePrice}元, 一般波动较${item.fluctuation <= 0.2 && item.downRate <= 1.5 ? '小' : '大'}。特殊情况下属于${item.bonusPrice >= item.basePrice * 3 ? '风投产品，风险与收益并存' : '一般产品，可用于资产保值'}。`);
        })
        
        // 创建文本元素
        const nameDiv = document.createElement('div');
        nameDiv.textContent = item.name;
        
        // 组装元素
        innerContainer.appendChild(imgElement);
        innerContainer.appendChild(nameDiv);
        itemContainer.appendChild(innerContainer);

        const activateBtn = document.createElement('button');
        activateBtn.id = `${item.name}-activate-button`;
        activateBtn.style = 'border: 1px solid rgb(111, 57, 28);background: linear-gradient(rgb(228, 127, 71), rgb(206, 102, 51), rgb(150, 61, 28));box-shadow: rgb(135, 67, 31) 0px 0px 2px 1px inset;fon;font-size: 14px;border-radius: 5px;color: rgb(249, 222, 155);padding: 4px;cursor: pointer;transition: transform 0.1s, box-shadow 0.1s;';
        activateBtn.innerText = `${item.itemActivate ? '取消' : '激活'}`;
        activateBtn.addEventListener('click', () => {
            if (!item.itemActivate && selectedItems.length < 6) {
                item.itemActivate = true;
                showMerchant(`已激活${item.name}。`);
                activateBtn.innerText = '取消';
                generateItemToDisplay();
            } else if (item.itemActivate) {
                item.itemActivate = false;
                showMerchant(`已取消售卖${item.name}。`);
                activateBtn.innerText = '激活';
                generateItemToDisplay();
            } else {
                showMerchant('只能同时运作6个商品！');
            }
        });
        itemContainer.appendChild(activateBtn);
        selectPanelContainer.appendChild(itemContainer);

    });
    selectPanel.appendChild(selectPanelContainer);
    parentPanel.appendChild(selectPanel);
}
        
// 生成随机商品并展示到市场板块
function getRandomScalpableItem() {    
    const marketPanel = document.getElementById('scalping-item-info');
    marketPanel.innerHTML = ''; // 清空现有内容
    let specialEvents = false;

    // 随机选择1到4个商品
    const itemsToDisplay = [];
    const wealthOfNations = scalpingState.gadgets.find(gadget => gadget === '国富论');
    let itemToAdd = 0;

    if (wealthOfNations) itemToAdd = 1;
    const numberOfItems = Math.min(5, Math.floor(Math.random() * 5) + 1 + itemToAdd);
    const selectedItems = scalpingItems.filter(i => i.itemActivate);

    
    while (itemsToDisplay.length < numberOfItems) {
        const randomItem = selectedItems[Math.floor(Math.random() * selectedItems.length)];
        if (!itemsToDisplay.includes(randomItem)) {
            itemsToDisplay.push(randomItem);
        }
    }

    // 生成HTML结构
    itemsToDisplay.forEach(item => {
        const originalPrice = document.getElementById(`price-${item.name}`) ? parseInt(document.getElementById(`price-${item.name}`).innerText) : item.basePrice;
        let price = getScalpableItemsPrice(item);
        let rareEventChance = 0.1;
        const rareEventBooster = scalpingState.gadgets.find(gadget => gadget === '八方来财');

        if (rareEventBooster) {
            rareEventChance = 0.2;
        }

        // 检查是否触发特殊事件
        if (Math.random() < rareEventChance && !specialEvents) {
            price = getScalpableItemsPrice(item, true);  // 特殊事件价格
            specialEvents = true;  // 标记已生成特殊事件
        }

        // 创建商品元素
        const itemElement = document.createElement('div');
        itemElement.className = 'scalping-item';
        itemElement.style = 'display: flex;justify-content: space-between;align-items: center;font-size: 14px;';
        itemElement.innerHTML = `
            <div id="${item.name}-container" style="cursor: pointer;">
                <img src="${item.url}" alt="${item.name}" style="width: 45px; height: 45px; border: 1px solid #6f391c" />
                <div>${item.name}</div>
            </div>
            <div id="price-${item.name}" style="color:${price > originalPrice? '#FF4500' : 'lime'};">${price}元 ${price > originalPrice? '↑' : '↓'}</div>
        `;

        // 点击商品时弹出购买进度条
        itemElement.addEventListener('click', () => {
            handleItemPurchase(item, price);
            });

        marketPanel.appendChild(itemElement);
    });
}

//构造的简便消息函数，仅用于倒买倒卖
function showMerchant(message) {
    const merchantUrl = 'https://pic.imgdb.cn/item/66e32523d9c307b7e995cf28.png';
    const merchantSize = '88px * 88px';

    showInfoBox(message,null,null,null,merchantUrl,merchantSize);
}

function getReputationAndShareEvent() {
    const reputation = calculatePlayerReputation();
    const repEvents = [
        {value: 1000, cashIn: 1000, description: '行走商场,小有名气,季度商场新人奖颁发给你'},
        {value: 5000, cashIn: 5000, description: '崭露头角的小商贩——不对,小商贩已经不能称呼你了,应该叫你老板先生'},
        {value: 10000, cashIn: 10000, description: '声望越来越高了,附近的商会特邀你作为本季度代言人'},
        {value: 15000, cashIn: 15000, description: '《三界商报》特别访谈了你的致富之道,你的精彩发言感染了在座的所有人'},
        {value: 20000, cashIn: 20000, description: '家业越来越大,在街头现身都会纷纷引来传闻"这家店被他光顾了,一定是个值得投资的优质资产"'},
        {value: 25000, cashIn: 30000, description: '商业帝国初具规模,各路商贾趋之若鹜,争相合作,希望能分得一杯羹'},
        {value: 30000, cashIn: 35000, description: '商海智者,为商场新人传道授业,言语间珠玑璀璨,博得满堂喝彩'},
        {value: 35000, cashIn: 40000, description: '三界商圣,产业遍布,商界传奇,后生楷模'},
        {value: 40000, cashIn: 45000, description: '商业版图不断扩张,各地竞相邀约投资,财富如涓涓细流汇成江河'},
        {value: 45000, cashIn: 50000, description: '三界首屈一指商业巨头,商业帝国巍然耸立,无人不晓'},
        {value: 50000, cashIn: 60000, description: '从针头到飞机,从日用到奢侈,商业触角无所不及,君临商界之巅'},
        {value: 100000, cashIn: 100000, description: '商业版图突破三界,跨界开疆拓土,开创全新商业时代'},
        {value: 200000, cashIn: 200000, description: '财富积累到了新的高度,荣登三界首富宝座,一举一动皆是焦点'},
        {value: 300000, cashIn: 300000, description: '商业帝国盖世无双,商界传奇名垂青史,故事被编入教科书广为流传'},
        {value: 400000, cashIn: 400000, description: '商业版图遍布已知未知,触角延伸至每一个角落,财富之多难以估量'},
        {value: 500000, cashIn: 500000, description: '商业帝国达到前所未有的高度,商界神话降世,万人景仰膜拜'},
        {value: 600000, cashIn: 600000, description: '财富超越想象,傲视群雄,成为传奇中的传奇,故事口口相传'},
        {value: 700000, cashIn: 700000, description: '商业疆域覆盖所有已知领域,财富积累到令人难以置信的地步'},
        {value: 800000, cashIn: 800000, description: '商业帝国化为传说,名字成为商业的代名词,妇孺皆知'},
        {value: 1000000, cashIn: 1000000, description: '财富积累到无人企及的高度,超凡脱俗,传说中的存在,故事流芳百世'}
    ];
    const hasOwnedStock = stockList.filter(s => s.quantity > 0);
    
    let dividend = 0;
    hasOwnedStock.forEach(stock => {
        dividend += Math.floor(stock.basePrice * stock.quantity * 0.05);
    });
    console.log(`当前股息分红为${dividend}`);
    scalpingState.currentCash += dividend;
    
    
    // 查找声望对应的事件，向下匹配最接近的事件
    let selectedEvent = null;
    for (let i = repEvents.length - 1; i >= 0; i--) {
        if (reputation >= repEvents[i].value) {
            selectedEvent = repEvents[i];
            break;
        }
    }
    
    // 如果找到了合适的事件，增加现金并显示事件
    if (!selectedEvent) {
        if (!currentInfoBox) {
            showMerchant(`本季度你按部就班地经营，较为低调${hasOwnedStock.length !== 0 ? `，你持有的${hasOwnedStock.length}支股票共计股息分红${dividend}元。` : '。'}`);
        } else {
            setTimeout(() => {
                showMerchant(`本季度你按部就班地经营，较为低调${hasOwnedStock.length !== 0 ? `，你持有的${hasOwnedStock.length}支股票共计股息分红${dividend}元。` : '。'}`);
            }, 1000);
        } 
    } else {
        if (!currentInfoBox) {
            scalpingState.currentCash += selectedEvent.cashIn;
            showMerchant(`本季度回顾：${selectedEvent.description}，声望奖励金${Math.min(selectedEvent.cashIn * 3, selectedEvent.cashIn + reputation)}元${hasOwnedStock.length !== 0 ? `,你持有的${hasOwnedStock.length}支股票共计股息分红${dividend}元。` : '。'}`);
        } else {
            setTimeout(() => {
                scalpingState.currentCash += selectedEvent.cashIn;
                showMerchant(`本季度回顾：${selectedEvent.description}，声望奖励金${Math.min(selectedEvent.cashIn * 3, selectedEvent.cashIn + reputation)}元${hasOwnedStock.length !== 0 ? `,你持有的${hasOwnedStock.length}支股票共计股息分红${dividend}元。` : '。'}`);
            }, 1000);
        }
    } 
    updateScalpingPanel();
}

function processSaleWeek(weekIncrement, energyCostRatio, cashCostRatio) {
    const refreshButton = document.getElementById('enter-next-week');
    const maxWeek = scalpingState.maxSellingWeek;
    const currentWeek = scalpingState.currentSellingWeek;

    // 计算花费
    const refreshCost = Math.max(0, Math.floor(scalpingState.maxWarehouseCapacity * 10 * cashCostRatio));
    const energyCost = Math.floor((Math.random() * 3 + 1) * energyCostRatio);

    const jiazuxintuo = scalpingState.gadgets.find(gadget => gadget === '家族信托');
    const timeMachine = scalpingState.gadgets.find(gadget => gadget === '百达翡丽');

    if (scalpingState.currentSellingWeek === 0 && scalpingState.currentCash === 0) {
        showMerchant(`开业第一天，没有一点启动资金可不行，目前最小的仓库每周租金${refreshCost}元，请确认你的账户资金充足`);
        return;
    }
    
    // 检查资金是否足够
    if (scalpingState.currentCash < refreshCost) {
        showMerchant(`本周店租为${refreshCost}元，你的现金不足以支付！`);
        return;
    }

    // 扣除周数
    if (scalpingState.currentSellingWeek + weekIncrement <= maxWeek) {
        if (timeMachine && Math.random() < 0.15) {
            const existingContainer = document.getElementById('baida-feili');
            if (existingContainer) document.getElementById('scalping-container').removeChild(existingContainer);
            
            const textContainer = document.createElement('p');
            textContainer.id = 'baida-feili';
            textContainer.style = 'display: flex;color: white;cursor:pointer;z-index: 1000;padding: 20px;gap: 10px;background-color: rgba(0, 0, 0, 0.8);border-radius: 2px;top: 50%;left: 50%;transform: translate(-50%, -50%);position: fixed;align-items: center;flex-direction: column-reverse;justify-content: center;font-style: italic;text-align: center;font-size: 14px;';
            textContainer.innerText = '百达翡丽拥有将时空凝滞的功能，在此次刷新中，时间没有增长';
            textContainer.addEventListener('click', () => {
                textContainer.style.display = 'none';
            })

            const imgElement = document.createElement('img');
            imgElement.src = 'https://pic.imgdb.cn/item/66ed55f0f21886ccc0145d08.png';
            imgElement.style = 'width: 240px;height: 144px;box-shadow: 0px 0px 2px 0px #fff;'
            textContainer.appendChild(imgElement);

            document.getElementById('scalping-container').appendChild(textContainer);
            setTimeout(() => {
                if (textContainer) {
                    document.getElementById('scalping-container').removeChild(textContainer);
                }
            },3000);
        } else {
            scalpingState.currentSellingWeek += weekIncrement;
            scalpingState.currentCash = Math.max(0, scalpingState.currentCash - (refreshCost * weekIncrement));
            scalpingState.playerEnergy = Math.max(0, scalpingState.playerEnergy - energyCost);
        }
        
        if (jiazuxintuo) scalpingState.currentCash += Math.floor(Math.random() * 5000 + 5000) * weekIncrement; //应用家族信托

        // 更新股票持有状态
        let stockOwned = stockList.filter(s => s.quantity > 0);
        
        stockOwned.forEach(s => {
            s.dealWeek = Math.max(0, s.dealWeek - weekIncrement);
        });

        // 更新 UI 和事件
        updateStockPrice();
        getRandomScalpableItem();

        // 更新按钮文字
        if (scalpingState.currentSellingWeek === maxWeek) {
            refreshButton.innerText = '结算收益';
        } else {
            refreshButton.innerText = '刷新一周';
        }

        // 执行声望事件每10周
        if (scalpingState.currentSellingWeek % 10 === 0) {
            getReputationAndShareEvent();
        }
        
        let randomEventRate = 1; //预留法宝位置
        if (!currentInfoBox && Math.random() < 0.2) {
            generateRandomEvents();
        }
        
    } else {
        showMerchant('已经到达最大周数，不能继续。');
    }
    updateScalpingPanel();
}

function finalizeScalping() {
    const goldGot = sellAssetsAndExchangeCash();
    const initialCost = scalpingState.investmentCount * 50000;
    const netAsset = calculateNetAsset();

    const doubleLuck = scalpingState.gadgets.includes('双喜临门');
    let scoreRatio = 1;
    if (doubleLuck) scoreRatio = 2;

    const scoreToAdd = Math.min(20000 * scoreRatio, Math.floor(goldGot.totalValue / 10000) * scoreRatio);

    // 修正赋值逻辑，生成换行的 recordMessage
    let recordMessage = '';
    if (scalpingState.achievements.length > 0) {
        recordMessage = generateRecordMessage().join('\n'); // 将数组拼接为字符串
    }

    if (highestAsset < netAsset) {
        highestAsset = netAsset;
        updateHighestAssetDisplay(highestAsset);
    }

    scalpingScore += scoreToAdd;
    goldAmount += goldGot.totalValue;
    updateGoldDisplay(goldAmount);

    showMerchant(`你经历${scalpingState.currentSellingWeek}周的商场鏖战，创造了不俗的经商业绩，经过核算：\n\n${recordMessage} \n\n未变现的资产缩水了${convertPrice(goldGot.assetShrinkValue)}金子，净利润为${convertPrice(Math.max(0, goldGot.totalValue - initialCost))}金子。\n\n所有资产已兑换为${convertPrice(goldGot.totalValue)}金子！\n\n本次经商你的积分增长了${scoreToAdd}，当前总积分为${scalpingScore}。`);
    resetScalping();
}

// 调整“修养两周”的事件监听器
document.getElementById('relax-byweek').addEventListener('click', () => {
    const heroToken = scalpingState.gadgets.find(gadget => gadget === '英雄令');
    const refreshCostRatio = heroToken ? 0.7 : 1;

    if (currentSlider) {
        document.body.removeChild(currentSlider);
        currentSlider = null;
    }
    
    if (scalpingState.maxSellingWeek - scalpingState.currentSellingWeek >= 2) {
        for (let i = 0; i < 2; i++) {
            processSaleWeek(1, 1, refreshCostRatio);// 休养两周
        }
        
        scalpingState.playerEnergy = 100;
        showMerchant('美美休息半个月，你的状态重回巅峰！');
        updateScalpingPanel();
    } else {
        showMerchant('你在市场的租期马上就要到了，不能执行休息动作了哦');
    }
});

// 调整 refreshSaleWeek 函数
function refreshSaleWeek() {
    const fitnessPowder = scalpingState.gadgets.find(gadget => gadget === '强身散');
    const heroToken = scalpingState.gadgets.find(gadget => gadget === '英雄令');
    const energyCostRatio = fitnessPowder ? 0.7 : 1;
    const refreshCostRatio = heroToken ? 0.7 : 1;
    const selectedItems = scalpingItems.filter(i => i.itemActivate);

    if (currentSlider) {
        document.body.removeChild(currentSlider);
        currentSlider = null;
    }

    if (selectedItems.length < 6) {
        showMerchant(`你需要选择激活6个商品才能在市场进行运作！还需要${6 - selectedItems.length}个待激活商品！`);
        generateItemToDisplay();
        return;
    }
        
    if (scalpingState.currentSellingWeek < scalpingState.maxSellingWeek) {
        processSaleWeek(1, energyCostRatio, refreshCostRatio);  // 常规更新一周
    } else {
        finalizeScalping();  // 达到最大周数时进行结算
    }
}


function recordAchivements() {
    const netAsset = calculateNetAsset(); // 获取当前资产
    let achivementsGoal = [
        {description: '你的资产第一次突破100万，初尝中产的滋味', type: 'netAsset', reqValue: '1000000'},
        {description: '你的资产突破500万，“彩票头奖亦不过如此”', type: 'netAsset', reqValue: '5000000'},
        {description: '你加入了千万富翁俱乐部', type: 'netAsset', reqValue: '10000000'},
        {description: '坐拥第一个三千万，小目标得以实现小半', type: 'netAsset', reqValue: '30000000'},
        {description: '在1亿小目标的半山腰睥睨尘世', type: 'netAsset', reqValue: '50000000'},
        {description: '你的资产第一次突破1亿，实现人生的小目标', type: 'netAsset', reqValue: '100000000'},
        {description: '你赚到了10亿，实现了人生的财富自由，开始追求更高阶的精神自由', type: 'netAsset', reqValue: '1000000000'},
        {description: '你投资的第一支股票开始产生收益，初尝资产配置的快感', type: 'stock', reqValue: '1'},
        {description: '你超越了过去的自己，财富积累达到了当前最高记录', type: 'highestScore', reqValue: '1'},
    ];

    const stillGoal = achivementsGoal.filter(goal =>
        !scalpingState.achievements.some(achi => achi.description === goal.description)
    );

    stillGoal.forEach(goal => {
        if (goal.type === 'netAsset' && parseInt(goal.reqValue) <= netAsset) {
            const achievedWeek = scalpingState.currentSellingWeek;
            const arrayOfAchievements = {description: goal.description, week: achievedWeek};
            scalpingState.achievements.push(arrayOfAchievements);
        }

        if (goal.type === 'stock' && stockList.find(s => s.quantity >= parseInt(goal.reqValue) && s.dealWeek === 0)) {
            const achievedWeek = scalpingState.currentSellingWeek;
            const arrayOfAchievements = {description: goal.description, week: achievedWeek};
            scalpingState.achievements.push(arrayOfAchievements);
        }

        if (goal.type === 'highestScore' && highestAsset < netAsset) {
            const achievedWeek = scalpingState.currentSellingWeek;
            const arrayOfAchievements = {description: goal.description, week: achievedWeek};
            scalpingState.achievements.push(arrayOfAchievements);
        }
        
    });
}

function generateRecordMessage() {
    let recordMessage = [];
    const achievements = scalpingState.achievements;

    if (achievements.length > 0) {
        achievements.forEach(achi => {
            const message = `第${achi.week}周时，${achi.description}`;
            recordMessage.push(message);
        });
    }

    return recordMessage;
}
        
function generateRandomEvents() {
    const randomEvent = [
        {
            unit: 1, 
            display: '新月村刘大爷想让你捐款50000，兴建一所村民小学，是否愿意？', 
            cost: 50000, 
            bias: 0.5, 
            goodEvent: '村民小学成功兴建，你在新月村声名远播（声望+3000），受到村政府表彰，奖励2万', 
            goodReward: 20000, 
            energyReward: 0,
            reputationReward: 3000,
            badEvent: '你的善款被开发商挪用，豆腐渣工程一阵风就吹倒了，你不得不再追加1万帮助修缮', 
            badPenalty: 10000,
            energyPenalty: 0,
            reputationPenalty: 0,
            img: 'https://pic.imgdb.cn/item/66eadcbdf21886ccc0e7f793.png'
        }, //刘大伯捐小学
        {
            unit: 2, 
            display: '听说黑色水域的大闸蟹很有养殖前景，宋柏邀请你投资入股10万元，是否应邀？', 
            cost: 100000, 
            bias: 0.5, 
            goodEvent: '作为天书第一批养螃蟹的人，你确实捞到了第一桶金，连本带利获得30万现金收入', 
            goodReward: 300000, 
            energyReward: 0,
            reputationReward: 0,
            badEvent: '黑色水域被毒蛇入侵，虽然螃蟹安然无恙，但是无人敢去捕捞，错过最佳捕蟹季节，损失3万', 
            badPenalty: 30000,
            energyPenalty: 0,
            reputationPenalty: 0,
            img: 'https://pic.imgdb.cn/item/66eadcbdf21886ccc0e7f787.png'
        }, //宋柏养螃蟹
        {
            unit: 3, 
            display: '黄一凡发来挑战书，“近来新学了几招刀法，邀请来与我一战！”，是否应战？', 
            cost: 0, 
            bias: 0.5, 
            goodEvent: '痛快的打完一架，反而精力充沛了起来（+20）', 
            goodReward: 0, 
            energyReward: 20,
            reputationReward: 0,
            badEvent: '长久伏案不曾活动，不慎在切磋中伤了筋骨，精力大减（-20）', 
            badPenalty: 0,
            energyPenalty: 20,
            reputationPenalty: 0,
            img: 'https://pic.imgdb.cn/item/66eadcbdf21886ccc0e7f762.png'
        }, //黄一凡打架
        {
            unit: 4, 
            display: '上官红新研制了一种可使宠物变色的无毒染剂，她异常兴奋地想要你给她投资20万元，承诺会给你超值的分红比例', 
            cost: 200000, 
            bias: 0.4, 
            goodEvent: '黑科技染料一经推出市场，顷刻间风靡各大养宠家庭，纷纷给自己的爱宠染上了五光十色。你在此次投资中获得50万的分红收益', 
            goodReward: 500000, 
            energyReward: 0,
            reputationReward: 0,
            badEvent: '由于未知添加物，染料未过朝云质监局，投资付诸东流，白费10点精力', 
            badPenalty: 0,
            energyPenalty: 10,
            reputationPenalty: 0,
            img: 'https://pic.imgdb.cn/item/66eadcbdf21886ccc0e7f770.png'
        }, //上官红拉投资
        {
            unit: 5, 
            display: '银月商会将要举办四年一届的三国贸易论坛，邀请你赞助20万元成为特约赞助商', 
            cost: 200000, 
            bias: 0.7, 
            goodEvent: '银月商会是三界最知名的贸易协定组织，在此次大会中，你的大名被赫然放在特别赞助商名单中，不少大商人见此纷纷与你磋商经贸之事(-10精力)，你的声望提高10000点', 
            goodReward: 0, 
            energyReward: -10,
            reputationReward: 10000,
            badEvent: '赞助商太多，无人在意，白费10点精力', 
            badPenalty: 0,
            energyPenalty: 10,
            reputationPenalty: 0,
            img: 'https://pic.imgdb.cn/item/66eadcbdf21886ccc0e7f753.png'
        }, //银月商会拉赞助
        {
            unit: 6, 
            display: '不留手鬼鬼祟祟地跟你说要去皇宫盗宝，想找你借1万现金打点禁卫', 
            cost: 10000, 
            bias: 0.3, 
            goodEvent: '不留手不愧是江洋大盗，连姜太后的贴身宝玉都能盗得，找了家不怕死的当铺典当之后，分得你30万元', 
            goodReward: 300000, 
            energyReward: 0,
            reputationReward: 0,
            badEvent: '贿赂失败，不留手在审问中供出了你的名字，不仅罚款惨重（-20万）还令你声望大减（-10000）', 
            badPenalty: 200000,
            energyPenalty: 0,
            reputationPenalty: 10000,
            img: 'https://pic.imgdb.cn/item/66eadcbdf21886ccc0e7f77b.png'
        }, //不留手盗宝
    ];
    
    // 修正随机选择逻辑
    const selectedRandomEvent = randomEvent[Math.floor(Math.random() * randomEvent.length)];
    const eventMessage = selectedRandomEvent.display;
    const imgUrl = selectedRandomEvent.img;

    // 确认按钮的处理函数
    const confirmAction = () => {
        // 扣除事件费用
        if (scalpingState.currentCash < selectedRandomEvent.cost) {
            showMerchant('你的现金不足！');
            return;
        }
        
        scalpingState.currentCash = Math.max(0, scalpingState.currentCash - selectedRandomEvent.cost);
        
        const playerReputation = calculatePlayerReputation();
        const repBonus = playerReputation * 0.000001; //定义声望的正向影响
        let extraBias = repBonus; //此处预留法宝的作用
        
        // 根据 bias 确定是好事件还是坏事件
        if (Math.random() < Math.min(0.8, selectedRandomEvent.bias + extraBias)) {
            // 好事件：给予奖励
            scalpingState.currentCash += selectedRandomEvent.goodReward;
            scalpingState.playerEnergy = Math.min(100, scalpingState.playerEnergy + selectedRandomEvent.energyReward);
            
            if (selectedRandomEvent.reputationReward) scalpingState.playerReputation += selectedRandomEvent.reputationReward;
            
            showMerchant(selectedRandomEvent.goodEvent);
        } else {
            // 坏事件：给予惩罚
            scalpingState.currentCash = Math.max(0, scalpingState.currentCash - selectedRandomEvent.badPenalty);
            scalpingState.playerEnergy = Math.max(0, scalpingState.playerEnergy - selectedRandomEvent.energyPenalty);
            
            if (selectedRandomEvent.reputationPenalty) scalpingState.playerReputation -= selectedRandomEvent.reputationPenalty;
            
            showMerchant(selectedRandomEvent.badEvent);
        }
        // 更新面板
        updateScalpingPanel();
    };

    // 显示事件信息，并传递确认操作
    showInfoBox(eventMessage, confirmAction, null, null, imgUrl, '88px * 88px');
}     

function updateHighestAssetDisplay(highestAsset, display = true) {
    const scalpingDisplayElement = document.getElementById('scalping-display');
    const commentsByAsset = [
        {value: 100000, comments: '虽不至于腰缠万贯，但也有一套独属于你的经商之道'},
        {value: 500000, comments: '经商有道，财富渐长，你的事业正在蒸蒸日上'},
        {value: 1000000, comments: '白手起家，积累了一定的财富，你已成为商界的新秀'},
        {value: 3000000, comments: '商海沉浮多年，你已是商界的中流砥柱，财富积累颇丰'},
        {value: 8000000, comments: '财富积累已达到一个新的高度，你的商业帝国正在崛起'},
        {value: 10000000, comments: '商业帝国初具规模，你的财富已经超过了大多数人一生的积累'},
        {value: 20000000, comments: '财富如山，商业版图遍布各地，你已成为商界的翘楚'},
        {value: 50000000, comments: '富可敌国，商业帝国盖世无双，你是当之无愧的商业巨头'},
        {value: 100000000, comments: '你的财富已经达到了常人难以想象的地步，传奇的商业人生谱写着新的篇章'},
        {value: 500000000, comments: '站在财富之巅，俯瞰商界，你已成为这个时代的商业传奇'},
        {value: 1000000000, comments: '你在一年之内积累了富可敌国的财富，索罗斯提到你时都会骄傲地挺胸告诉别人：他就是我的金融恩师！'}
    ];

    // 检查是否已经存在 recordOverlay，避免重复添加
    let selectedComment = null;
    for (let i = commentsByAsset.length - 1; i >= 0; i--) {
        if (highestAsset >= commentsByAsset[i].value) {
            selectedComment = commentsByAsset[i].comments;
            break;
        }
    }

    if (!display) return selectedComment;
    highestAsset = highestAsset.toLocaleString('en-US');
    
    const existingContainer = document.getElementById('scalping-record-overlay-container');
    if (existingContainer) {
        scalpingDisplayElement.removeChild(existingContainer);
    }

    const overlayContainer = document.createElement('div');
    overlayContainer.id = 'scalping-record-overlay-container';
    overlayContainer.style = 'position: fixed;top: 50%; left: 50%; transform: translate(-50% , -50%);width:100%;height:100%;';
    overlayContainer.addEventListener('click', () => {
        scalpingDisplayElement.removeChild(overlayContainer);
    })
    
    // 创建新的覆盖层
    const recordOverlay = document.createElement('div');
    recordOverlay.id = 'scalping-record-overlay';  // 给定唯一的 ID，方便管理
    recordOverlay.style.zIndex = '9999';
    recordOverlay.style.display = 'flex';
    recordOverlay.style.position = 'relative';
    recordOverlay.style.backgroundImage = 'url(https://pic.imgdb.cn/item/66e71037d9c307b7e9202eb7.png)';
    recordOverlay.style.backgroundSize = 'contain';
    recordOverlay.style.backgroundRepeat = 'no-repeat';
    recordOverlay.style.backgroundPosition = 'center';
    recordOverlay.style.width = '100%';
    recordOverlay.style.height = '100%';
    recordOverlay.style.flexDirection = 'column';
    recordOverlay.style.alignItems = 'center';
    recordOverlay.style.backgroundColor = 'rgba(0, 0, 0, 0.4)';
    recordOverlay.style.color = 'white';
    recordOverlay.style.fontSize = '24px';
    recordOverlay.style.fontWeight = 'bold';
    recordOverlay.style.justifyContent = 'center';  // 添加居中对齐

    const recordText = document.createElement('div');
    recordText.id = 'scalping-record-text';
    recordText.style = 'position: absolute;top: 50%; left: 50%; transform: translate(-50% , -50%); color: crimson; font-size: 24px; font-weight: bold; text-align: center;max-width:200px;';
    if (selectedComment) {
        recordText.innerText = `创造新的历史记录：${highestAsset}元！${selectedComment}！`;
    } else {
        recordText.innerText = `创造新的历史记录：${highestAsset}元！你的经商头脑无人能敌！`;
    }
    
    recordOverlay.appendChild(recordText);
    overlayContainer.appendChild(recordOverlay);
    scalpingDisplayElement.appendChild(overlayContainer);
    

    // 设置 20 秒后移除覆盖层
    setTimeout(() => {
        if (existingContainer) {
            scalpingDisplayElement.removeChild(existingContainer);
        }
    }, 20000);

}
        
function resetScalping() {
    const marketPanel = document.getElementById('scalping-item-info');
    const warehousePanel = document.getElementById('warehouse-item-info');
    const relaxButton = document.getElementById('relax-byweek');
    marketPanel.innerHTML = ''; // 清空现有内容
    warehousePanel.innerHTML = ''; // 清空现有仓库内容
    
    if (relaxButton.style.display !== 'none') {
        relaxButton.style.display = 'none';
    }
    
    scalpingState = {
        currentSellingWeek: 0,
        maxSellingWeek: 52,
        playerReputation: 0,
        playerEnergy: 100,
        currentCash: 0, // 示例初始现金
        netAsset: 0, 
        usedWarehouseCapacity: 0,
        maxWarehouseCapacity: 100, // 初始仓库容量
        warehouseUpdateCount: 0,
        investmentCount: 0,
        holdItems: {}, // 存放玩家购买的商品
        gadgets: [],
        achievements: []
    };

    if (isStock) openStockPanel();
    keyPhaseCount = 0;
    resetStockState();
    updateStockPanelDisplay();
    updateScalpingPanel();
    document.getElementById('enter-next-week').innerText = '刷新一周';
    document.getElementById('applied-scalping-gadgets').innerHTML = '';
}

function sellAssetsAndExchangeCash() {
    const netAssets = calculateNetAsset();
    const cash = scalpingState.currentCash;
    const treasureWood = scalpingState.gadgets.find(gadget => gadget === '珍宝案');
    
    let propertyRatio = 1;

    // 如果有"珍宝案"，提升资产价值
    if (treasureWood) {
        propertyRatio = 1.2;
    }

    // 现金部分
    let cashChangeNum = cash;

    // 计算原始未变现资产的总价值
    let originalAssetValue = netAssets - cash;

    // 计算资产波动系数
    let assetValue = Math.floor(originalAssetValue * (Math.min(1, Math.random() * 0.2 + 0.6) * propertyRatio));

    // 计算缩水值
    let shrinkValue = originalAssetValue - assetValue;
    let assetShrinkValue = Math.max(0, shrinkValue); // 确保缩水值不为负数

    // 总价值 = 现金 + 变动后资产的价值
    let totalValue = Math.max(0, cashChangeNum + assetValue);

    return { totalValue, assetShrinkValue }; // 返回总价值和缩水值
}
        
function quitScalping() {
    if (scalpingState.currentSellingWeek < scalpingState.maxSellingWeek) {
        showInfoBox('提前退市可以立即结算你的总资产，但是会带来20%的折损且不会获得经商积分，是否继续？',
                   () => {
                        const cash = sellAssetsAndExchangeCash();
                        const goldGot = Math.floor(cash.totalValue * 0.8);
                        goldAmount += goldGot;
                        updateGoldDisplay(goldAmount);
                        showMerchant(`所有商品已经结算完毕，你总计卖出了${convertPrice(goldGot)}金子！`);
                        resetScalping();
                   },
                   () => showMerchant('取消交易！'),
                   'red','https://pic.imgdb.cn/item/66e32523d9c307b7e995cf28.png','88px * 88px');
    } else {
        refreshSaleWeek();
    }
}
        
let currentSlider = null;
        
// 通用进度条创建和处理函数
function handleItemTransaction(item, itemInfo, actionType) {
    // 判断行为类型：购买或出售
    const isPurchase = actionType === 'purchase';

    if (currentSlider) {
        document.body.removeChild(currentSlider);
        currentSlider = null;
    }

    // 获取或创建进度条
    let sliderContainer = document.getElementById(`${actionType}-slider-container`);
    if (!sliderContainer) {
        sliderContainer = document.createElement('div');
        sliderContainer.id = `${actionType}-slider-container`;
        sliderContainer.style = 'display: flex;position: fixed;top: 50%;left: 50%;transform: translate(-50%, -50%);width: 80%;max-height: 80%;min-height: 10%;z-index: 9999;font-size: 14px;padding: 10px 20px 5px;background-color: rgb(223, 191, 110);color: rgb(146, 52, 28);background-image: url(https://pic.imgdb.cn/item/663885620ea9cb14033e4f6e.png);background-repeat: repeat;background-size: auto;box-shadow: rgb(30, 46, 47) 0px 0px 0px 1px, rgb(111, 57, 28) 0px 0px 0px 1px inset;border: 1px solid rgb(235, 172, 59);overflow-y: auto;flex-direction: column;align-items: center;gap: 5px;';

        const sliderLabel = document.createElement('label');
        sliderLabel.innerText = `拖动${isPurchase ? '购买' : '出售'}数量：`;
        sliderContainer.appendChild(sliderLabel);

        const slider = document.createElement('input');
        slider.id = `${actionType}-slider`;
        slider.type = 'range';
        slider.min = 0;
        slider.max = 100;
        slider.value = 0;
        slider.style = 'width: 90%;appearance: none;border-radius: 20px;border: 1px groove #0475ff;box-shadow: inset 0px 0px 2px 1px #0475ff;';
        sliderContainer.appendChild(slider);

        const quantityLabel = document.createElement('div');
        quantityLabel.id = `${actionType}-quantity`;
        quantityLabel.innerText = `${isPurchase ? '购买' : '出售'}数量: 0, 预计金额: 0`;
        sliderContainer.appendChild(quantityLabel);

        const itemDescription = document.createElement('div');
        itemDescription.id = `${actionType}-quantity`;
        itemDescription.innerText = `商品说明: ${item.description}`;
        sliderContainer.appendChild(itemDescription);

        const confirmButton = document.createElement('button');
        confirmButton.id = `confirm-${actionType}-button`;
        confirmButton.style = 'border: 1px solid #6F391C;background: linear-gradient(to bottom, #E47F47, #CE6633, #963D1C);box-shadow: inset 0px 0px 2px 1px #87431F;font-size: 14px;border-radius: 5px;color: #F9DE9B;padding: 4px 6px;cursor: pointer;transition: transform 0.1s, box-shadow 0.1s;';
        confirmButton.innerText = `确认${isPurchase ? '购买' : '出售'}`;
        sliderContainer.appendChild(confirmButton);
        
        document.body.appendChild(sliderContainer);
    }
    
    sliderContainer.style.display = 'flex'; // 显示进度条
    const slider = document.getElementById(`${actionType}-slider`);
    const quantityLabel = document.getElementById(`${actionType}-quantity`);
    
    currentSlider = sliderContainer;

    let maxQuantity, price;

    if (isPurchase) {
        // 获取 UI 上的固定价格
        const availableRoom = Math.max(0, scalpingState.maxWarehouseCapacity - scalpingState.usedWarehouseCapacity);
        price = parseInt(document.getElementById(`price-${item.name}`).innerText); 
        maxQuantity = Math.min(availableRoom, Math.floor(scalpingState.currentCash / price)); // 最大可购买数量
    } else {
        const itemInfo = scalpingState.holdItems[item.name];
        const itemName = scalpingItems.find(i => i.name === item.name);
        const marketItemPriceElement = document.getElementById(`price-${itemName.name}`);
        console.log({itemInfo, marketItemPriceElement, itemName});
        if (!marketItemPriceElement) {
            price = itemInfo.averagePrice;
            maxQuantity = itemInfo.quantity; // 最大可出售数量
        } else {
            price = parseInt(document.getElementById(`price-${item.name}`).innerText); // 获取市场价格
            maxQuantity = itemInfo.quantity; // 最大可出售数量
        }
    }

    // 监听进度条变化
    slider.addEventListener('input', (event) => {
        const percentage = event.target.value;
        const quantity = Math.floor((percentage / 100) * maxQuantity);
        quantityLabel.innerText = `${isPurchase ? '购买' : '出售'}数量: ${quantity}, 预计金额: ${price * quantity}`;
    });

    // 点击确认购买/出售
    document.getElementById(`confirm-${actionType}-button`).addEventListener('click', () => {
        const quantity = Math.floor((slider.value / 100) * maxQuantity);
        if (quantity > 0) {
            if (isPurchase) {
                // 执行购买逻辑
                const totalCost = quantity * price;
                if (scalpingState.usedWarehouseCapacity + quantity <= scalpingState.maxWarehouseCapacity) {
                    scalpingState.currentCash -= totalCost;
                    scalpingState.usedWarehouseCapacity += quantity;

                    if (!scalpingState.holdItems[item.name]) {
                        scalpingState.holdItems[item.name] = { averagePrice: price, quantity };
                    } else {
                        const currentHold = scalpingState.holdItems[item.name];
                        const newTotalQuantity = currentHold.quantity + quantity;
                        const newAveragePrice = Math.floor(((currentHold.averagePrice * currentHold.quantity) + (price * quantity)) / newTotalQuantity);
                        scalpingState.holdItems[item.name] = { averagePrice: newAveragePrice, quantity: newTotalQuantity };
                    }
                    
                    updateWarehouseItems();
                } else {
                    showMerchant('仓库容量不足，无法购买');
                }
            } else {
                // 执行出售逻辑
                const totalSaleValue = quantity * price;
                scalpingState.currentCash += totalSaleValue;
                itemInfo.quantity -= quantity;
                scalpingState.usedWarehouseCapacity -= quantity; // 更新仓库容量
                
                if (itemInfo.quantity === 0) {
                    delete scalpingState.holdItems[item.name]; // 移除卖完的物品
                }

                updateWarehouseItems();
            }
            sliderContainer.style.display = 'none'; // 完成后隐藏进度条
        } else if (currentSlider) {
                document.body.removeChild(currentSlider);
                currentSlider = null;
        }
    });
}
// 触发购买
function handleItemPurchase(item, price) {
    const revokeSandIndex = scalpingState.gadgets.indexOf('唤神砂');
    
    // 先检查仓库容量
    if (scalpingState.usedWarehouseCapacity === scalpingState.maxWarehouseCapacity) {
        showMerchant('你的仓库已满！');
        return;
    }

    // 再检查玩家精力
    if (scalpingState.playerEnergy <= 60) {
        if (revokeSandIndex !== -1) {
            handleItemTransaction(item, null, 'purchase');
            // 使用 splice 来删除 "唤神砂"
            scalpingState.gadgets.splice(revokeSandIndex, 1);
        } else {
            showMerchant('不要这么殚精竭虑，你需要好好休息一下！');
        }
        return;
    }
    
    // 若通过所有检查，处理购买
    handleItemTransaction(item, null, 'purchase');
}

// 触发出售
function handleItemSell(item, itemInfo) {
    // 查找是否有 "唤神砂"
    const revokeSandIndex = scalpingState.gadgets.indexOf('唤神砂');
    
    // 获取玩家持有的物品和市场中该物品的相关信息
    const holdItem = scalpingState.holdItems[item.name];
    const itemName = scalpingItems.find(i => i.name === item.name);
    const marketItemPriceElement = document.getElementById(`price-${itemName.name}`);

    // 检查玩家精力
    if (scalpingState.playerEnergy <= 60) {
        if (revokeSandIndex !== -1) {
            // 拥有 "唤神砂"，允许继续出售并删除 "唤神砂"
            handleItemTransaction(item, itemInfo, 'sell');
            scalpingState.gadgets.splice(revokeSandIndex, 1);  // 删除唤神砂
        } else {
            // 没有 "唤神砂"，提示玩家休息
            showMerchant('不要这么殚精竭虑，你需要好好休息一下！');
        }
        return;
    }

    const qianKunBagIndex = scalpingState.gadgets.indexOf('乾坤袋');
    // 检查市场中是否有该商品的销售渠道
    if (!marketItemPriceElement && qianKunBagIndex === -1) {
        showMerchant('市场目前没有该商品的销售渠道，无法出售');
        return;
    } else if (!marketItemPriceElement && qianKunBagIndex !== -1) {
        handleItemTransaction(item, itemInfo, 'sell');
        scalpingState.gadgets.splice(qianKunBagIndex, 1);
    } else {
        handleItemTransaction(item, itemInfo, 'sell');
    }
}

document.getElementById('player-reputation').addEventListener('click', () => {
    showMerchant('\n1. 声望是你在资本增长过程中积累的数值。 \n2. 声望越高，每个季度（每10周）回顾时会得到特殊奖励。 \n3. 声望还会对特殊事件的走向产生影响。');
});
        
document.getElementById('player-energy').addEventListener('click', () => {
    const energy = scalpingState.playerEnergy;
    const cash = scalpingState.currentCash;
    const recoverCostRatio = 100 - energy;
    const recoverCost = Math.pow(recoverCostRatio, 4);

    if (cash >= recoverCost) {
        showInfoBox(`\n1. 每周刷新时会扣除精力，精力低于60时将无法进行任何交易。\n\n2. 精力不足时可以选择休息两周或在此对话框内点击确认花费现金补充。 \n\n3. 你可以花费${recoverCost}元立即恢复到满精力状态，是否确认？`,
                    () => {
                        scalpingState.currentCash -= recoverCost;
                        scalpingState.playerEnergy = 100;
                        updateScalpingPanel();
                        showMerchant('一根上好的参汤进补，你又焕发了龙马精神');
                    },null,'crimson','https://pic.imgdb.cn/item/66e32523d9c307b7e995cf28.png','88px * 88px')
    } else {
        showMerchant(`当前需要${recoverCost}元来恢复精力，你的现金不足！`);
    }
});
        
// 更新仓库持有物品
function updateWarehouseItems() {
    const warehousePanel = document.getElementById('warehouse-item-info');
    warehousePanel.innerHTML = ''; // 清空现有仓库内容
    
    Object.keys(scalpingState.holdItems).forEach(itemName => {
        const itemInfo = scalpingState.holdItems[itemName];
        const item = scalpingItems.find(i => i.name === itemName);

        // 创建仓库物品元素
        const itemElement = document.createElement('div');
        itemElement.className = 'warehouse-item';
        itemElement.style = 'display: flex;justify-content: space-between;align-items: center;font-size: 14px;';
        itemElement.innerHTML = `
            <div id="${item.name}-warehouse-container" style="cursor: pointer;">
                <img src="${item.url}" alt="${item.name}" style="width: 45px; height: 45px; border: 1px solid #6f391c" />
                <div>${item.name}</div>
            </div>
            <div>${itemInfo.averagePrice} 元</div>
            <div>${itemInfo.quantity}个</div>
        `;
        
        // 点击物品进行出售
        itemElement.addEventListener('click', () => {
            handleItemSell(item, itemInfo);
        });

        warehousePanel.appendChild(itemElement);
    });
    updateScalpingPanel();
}

// 仓库扩展按钮逻辑
document.getElementById('enlarge-warehouse-button').addEventListener('click', () => {
    const upgradeCost = 10000 * Math.max(1, (Math.pow(scalpingState.warehouseUpdateCount , 2)));
    const refreshCost = Math.max(0, Math.floor(scalpingState.maxWarehouseCapacity * 20));
    showInfoBox(`你可以花费${upgradeCost}元开启100个仓库`,
               () => {
                    if (scalpingState.currentCash >= upgradeCost) {
                        scalpingState.currentCash -= upgradeCost;
                        scalpingState.maxWarehouseCapacity += 100;
                        scalpingState.warehouseUpdateCount++;
                        updateScalpingPanel();
                        showMerchant(`你的仓库扩充为${scalpingState.maxWarehouseCapacity}个了！现在每周需要支付${refreshCost}元场地租金哦！`);
                    } else {
                        showMerchant('现金不足！');
                    }
               },
               null,
               'red','https://pic.imgdb.cn/item/66e32523d9c307b7e995cf28.png','88px * 88px');
});
        
function calculateNetAsset() {
    let netAsset = 0;
    let itemsValue = 0;

    // 计算持有的物品的资产
    Object.keys(scalpingState.holdItems).forEach(itemName => {
        const itemInfo = scalpingState.holdItems[itemName];
        const item = scalpingItems.find(i => i.name === itemName);
        
        if (!item) {
            return; // 如果找不到该物品，跳过该商品
        }

        // 查找市场上是否存在该商品的价格元素
        const marketItemPriceElement = document.getElementById(`price-${itemName}`);
        let marketPrice = null;

        if (marketItemPriceElement) {
            // 从市场元素中获取价格
            marketPrice = parseInt(marketItemPriceElement.innerText);
        }

        // 计算当前商品的资产值，确保只使用市场价格或平均价格之一
        let itemAssetValue = 0;

        if (marketPrice) {
            // 使用市场价格
            itemAssetValue = itemInfo.quantity * marketPrice;
        } else if (itemInfo.averagePrice) {
            // 如果市场价格不存在，则使用平均价格
            itemAssetValue = itemInfo.quantity * itemInfo.averagePrice;
        } else {
            console.warn(`商品 ${itemName} 没有市场价格和平均价格，跳过计算`);
            return; // 没有价格的情况下跳过该商品的计算
        }

        // 累加到总资产
        itemsValue += itemAssetValue;
    });

    // 计算持有的股票的资产
    const stocksOwned = stockList.filter(s => s.quantity > 0);
    const kaimanzhizhao = scalpingState.gadgets.find(gadget => gadget === '开曼岛执照');
    let stockValue = 0;
    let tax = 0.9;
    if (kaimanzhizhao) tax = 0.95;

    stocksOwned.forEach(stock => {
        // 确保 stock.basePrice 是最新的市场价格
        if (typeof stock.basePrice !== 'number') {
            console.warn(`股票 ${stock.name} 的基础价格无效，跳过计算`);
            return;
        }
        // 计算股票价值并考虑税率
        stockValue += stock.quantity * stock.basePrice * tax;
    });
    
    // 将现金加入到总资产
    netAsset = Math.floor(scalpingState.currentCash + itemsValue + stockValue);

    return netAsset;
}


function calculatePlayerReputation() {
    const netAsset = calculateNetAsset();
    let reputation = 0;
    reputation = Math.max(0, Math.floor(Math.max(0, (netAsset - 200000) / 500)) + scalpingState.playerReputation);
    
    return reputation;
}
        
//用于更新细节，避免重复函数
function updateScalpingPanel() {
    const currentSellingWeek = document.getElementById('current-selling-week');
    const maxSellingWeek = document.getElementById('max-selling-week');
    const playerEnergy = document.getElementById('player-energy');
    const playerReputation = document.getElementById('player-reputation');
    const currentCash = document.getElementById('current-cash');
    const netAsset = document.getElementById('net-asset');
    const usedWarehouseCapacity = document.getElementById('used-warehouse-capacity');
    const maxWarehouseCapacity = document.getElementById('max-warehouse-capacity');
    const relaxButton = document.getElementById('relax-byweek'); 
    const gadgetButton = document.getElementById('add-scalping-gadgets');
    const scalpingScoreElement = document.getElementById('scalping-score');

    currentSellingWeek.innerText = scalpingState.currentSellingWeek;  // 例如更新当前周
    maxSellingWeek.innerText = scalpingState.maxSellingWeek;     // 更新最大周数
    playerEnergy.innerText = scalpingState.playerEnergy;
    playerReputation.innerText = calculatePlayerReputation();  // 更新声望
    currentCash.innerText = scalpingState.currentCash;      // 更新当前现金
    netAsset.innerText = calculateNetAsset();        // 更新总资产
    usedWarehouseCapacity.innerText = scalpingState.usedWarehouseCapacity;  // 更新已使用仓库容量
    maxWarehouseCapacity.innerText = scalpingState.maxWarehouseCapacity;  // 更新最大仓库容量
    scalpingScoreElement.innerText = scalpingScore;
    checkGagdetsState(); //更新法宝应用情况
    recordAchivements(); //更新实时记录
    checkStockPhaseAndDisplay();
    
    if (scalpingState.playerEnergy <= 60) {
        relaxButton.style.display = 'flex';
        document.getElementById('player-energy').innerText = `${scalpingState.playerEnergy} 补💉`;
        document.getElementById('player-energy').style.color = 'red';
    } else {
        relaxButton.style.display = 'none';
        document.getElementById('player-energy').innerText = scalpingState.playerEnergy;
        document.getElementById('player-energy').style.color = 'white';
    }

    if (scalpingState.gadgets.length === 3) {
        gadgetButton.style.display = 'none';
    } else {
        gadgetButton.style.display = 'flex';
    } 
}

function checkStockPhaseAndDisplay() {
    const stockInfo = document.getElementById('stock-info-display');
    const hasStock = stockList.filter(s => s.quantity > 0);
    
    if (hasStock.length === 0 && keyPhaseCount === 0) {
        stockInfo.innerText = '当前没有投资任何股票';
    } else if (hasStock.length === 0 && keyPhaseCount > 0) {
        stockInfo.innerText = `${calculateNetAsset() > 5000000 ? '【牛市周期】' : '【熊市周期】'}当前没有投资任何股票`;
    } 
    
    if (hasStock.length === 1) {
        if (keyPhaseCount === 0) {
            stockInfo.innerText = `当前持有${hasStock.find(h => h.quantity > 0).quantity}手${hasStock.find(h => h.quantity > 0).name}的股票`;
        } else {
            stockInfo.innerText = `${calculateNetAsset() > 5000000 ? '【牛】' : '【熊】'}当前持有${hasStock.find(h => h.quantity > 0).quantity}手${hasStock.find(h => h.quantity > 0).name}的股票`;
        }
    } else if (hasStock.length > 1) { 
        if (keyPhaseCount === 0) {
            stockInfo.innerText = `当前总计持有${hasStock.length}支股票`;
        } else {
            stockInfo.innerText = `${calculateNetAsset() > 5000000 ? '【牛】' : '【熊】'}当前总计持有${hasStock.length}支股票`;
        }
    }  
}
        
function checkGagdetsState() {
    const gadgetsElement = document.getElementById('applied-scalping-gadgets');

    // 确保 gadgetsElement 存在
    if (!gadgetsElement) {
        console.error('gadgetsElement not found');
        return;
    }

    // 获取 gadgetsElement 中的所有子元素 (包含 img 元素的 div)
    const appliedGadgetsDivs = Array.from(gadgetsElement.children);

    // 提取每个子元素的 img.alt 属性，并根据 alt 查找 jinnangItems 中对应的道具
    const existingGadgets = appliedGadgetsDivs.map(div => {
        const img = div.querySelector('img'); // 获取 div 中的 img 元素
        if (img && img.alt) {
            // 根据 img 的 alt 属性查找 jinnangItems 中对应的道具
            const jinnangItem = jinnangItems.find(item => item.name === img.alt);
            if (jinnangItem) {
                return jinnangItem.displayName; // 返回道具的中文映射 displayName
            }
        }
        return null; // 如果没有找到匹配的，返回 null
    }).filter(Boolean); // 过滤掉 null 值

    // 保留 stillExistingGadgets 中存在于 scalpingState.gadgets 的道具
    const stillExistingGadgets = scalpingState.gadgets.filter(gadget => {
        return existingGadgets.includes(gadget);
    });

    // 遍历 appliedGadgetsDivs，移除那些不再存在于 stillExistingGadgets 中的元素
    appliedGadgetsDivs.forEach(div => {
        const img = div.querySelector('img'); // 获取 img 元素
        if (img && img.alt) {
            const jinnangItem = jinnangItems.find(item => item.name === img.alt);
            if (jinnangItem && !stillExistingGadgets.includes(jinnangItem.displayName)) {
                // 如果道具不在 stillExistingGadgets 中，移除该元素
                gadgetsElement.removeChild(div);
            }
        }
    });
}
        
// 页面加载完成后初始化商店
let refreshCount = 0; // 全局计数器，记录刷新次数
let sSkillCount = 0;
let ssSkillCount = 0;
        
function refreshShop(auto = false) {
    if (!auto && goldAmount < 1000) {
        return showInfoBox("您的金子不足1两，无法刷新！");
    }

    if (!auto) {
        goldAmount -= 1000;
        updateGoldDisplay(goldAmount);
    }

    const shopItems = document.getElementById('shop-items');
    shopItems.innerHTML = '';

    refreshCount++; // 更新刷新计数器

    if (refreshCount === 20) {
        refreshCount = 0;
        const specialItems = generateSpecialItems();
        specialItems.forEach(item => addItemToShop(item, shopItems));
        return;
    }

    const numItems = auto ? getRandomInt(2, 18) : getRandomInt(10, 60);
    const probabilities = auto ? [0.8, 0.2] : [0.7, 0.3];
    let rareItemCount = 0;
    let commonBundleCount = 0;
    let rareBundleCount = 0;

    let items = [];

    const rareCounts = {
        item: 0,
        bundle: 0,
        sSkill: 0,
        ssSkill: 0,
        maxItems: numItems * probabilities[1] // 估算稀有物品的最大数量
    };

    for (let i = 0; i < numItems; i++) {
        let isRare = Math.random() < probabilities[1];
        if (!auto && isRare && rareItemCount >= 28) isRare = false;
        if (isRare) rareItemCount++;

        let item;
        if (isRare) {
            item = getRandomRareItem(rareCounts);
        } else {
            item = getRandomCommonItem();
        }

        if (item.name.includes('包裹')) {
            const bundleCount = isRare ? rareBundleCount : commonBundleCount;
            const maxBundles = isRare ? 3 : 3;

            if (bundleCount >= maxBundles) {
                i--;
                continue;
            }

            isRare ? rareBundleCount++ : commonBundleCount++;
        }

        items.push(item);
    }

    // 如果不是第20次刷新，按价格从高到低排序
    items.sort((a, b) => b.price - a.price);

    // 将排序后的商品添加到商店中
    items.forEach(item => addItemToShop(item, shopItems));
    sSkillCount = 0;
    ssSkillCount = 0;

    if (auto) startShopTimer();
}

function generateSpecialItems() {
    const allSSSkills = collectSkillsByRarity('SS');
    const allSSkills = collectSkillsByRarity('S');

    return [
        ...selectRandomItems(allSSSkills, 30),
        ...selectRandomItems(allSSkills, 30)
    ];
}

function collectSkillsByRarity(rarity) {
    return Object.values(pets).flatMap(pet =>
        pet.skills
            .filter(skill => skill.rarity === rarity)
            .map(skill => createSkillItem(pet.name, skill.name, rarity))
    );
}

function selectRandomItems(items, count) {
    const selectedItems = [];
    while (selectedItems.length < count && items.length) {
        const index = Math.floor(Math.random() * items.length);
        selectedItems.push(items.splice(index, 1)[0]);
    }
    return selectedItems;
}

function getRandomCommonItem() {
    const commonItems = [
        createItem('高级悟性丹', 20, 100, 'https://pic.imgdb.cn/item/66541c01d9c307b7e9208aea.png'),
        createItem('万化灵丹', 4000, 5000, 'https://pic.imgdb.cn/item/66541c01d9c307b7e9208add.png'),
        createItem('神兽还童丹', 4200, 5000, 'https://pic.imgdb.cn/item/6654a944d9c307b7e9ca6423.png'),
        createItem('还童金丹', 4000, 6220, 'https://pic.imgdb.cn/item/6655a92ad9c307b7e9c04265.png'),
        createItem('冰魄还童丹', 4990, 7299, 'https://pic.imgdb.cn/item/665ef0855e6d1bfa055800f4.png'),
        createItem('资质重生丹', 6880, 7288, 'https://pic.imgdb.cn/item/6654a944d9c307b7e9ca63f5.png'),
        createItem('精灵精炼石', 1888, 3880, 'https://pic.imgdb.cn/item/6669666cd9c307b7e991c04a.png'),
        createItem('精灵觉醒石', 3880, 6880, 'https://pic.imgdb.cn/item/6669666cd9c307b7e991bf78.png'),
        createItem('天地灵气', 6688, 13688, 'https://pic.imgdb.cn/item/666ab20bd9c307b7e96301f6.png'),
        createItem('分解符礼包', 18888, 38880, 'https://pic.imgdb.cn/item/66c60e7cd9c307b7e9ad57d3.png'),
        createItem('聚灵丹', 366, 688, 'https://pic.imgdb.cn/item/66c238b6d9c307b7e9e76c9a.png'),
        createItem('唤妖符', 366, 688, 'https://pic.imgdb.cn/item/66c238b6d9c307b7e9e76c26.png'),
        createItem('特级悟性丹', 1388, 1788, 'https://pic.imgdb.cn/item/665de3fd5e6d1bfa05564912.png'),
        createItem('宝石镶嵌符', 21388, 31788, 'https://pic.imgdb.cn/item/66d9e814d9c307b7e93afc79.png'),
        createItem('宝石摘除符', 21388, 31788, 'https://pic.imgdb.cn/item/66dc001bd9c307b7e9b8bb5c.png'),
        createItem('低级宝石合成符', 11388, 16788, 'https://pic.imgdb.cn/item/66db2caed9c307b7e9c66c55.png'),
        createItem('升级宝石礼包（极品）', 21388, 31788, 'https://pic.imgdb.cn/item/66dab9c1d9c307b7e921b767.png'),
        createItem('延寿露', 3888, 3999, 'https://pic.imgdb.cn/item/666d311dd9c307b7e996b5b7.png'),
        createItem('天山雪莲', 3888, 3999, 'https://pic.imgdb.cn/item/666d311dd9c307b7e996b5a8.png'),
        createItem('忘忧水', 1888, 1999, 'https://pic.imgdb.cn/item/666c0afbd9c307b7e9beef9c.png'),
        createItem('三花丸', 1888, 1999, 'https://pic.imgdb.cn/item/666c0afbd9c307b7e9beefcb.png')
    ];

    if (Math.random() < 0.8) {
        const item = selectRandomItems(commonItems, 1)[0];
        const quantity = getRandomInt(51, 200);
        return createBundleItem(item, quantity, false);
    }

    return selectRandomItems(commonItems, 1)[0];
}

function getRandomRareItem(rareCounts) {
    const rareItems = [
        createItem('灵异金丹', 6288, 12988, 'https://pic.imgdb.cn/item/66556068d9c307b7e9681672.png'),
        createItem('宠物寿命晶石', 11288, 16988, 'https://pic.imgdb.cn/item/66e726d8d9c307b7e9405457.png'),
        createItem('仙人醍醐', 86788, 169238, 'https://pic.imgdb.cn/item/6662eda05e6d1bfa0530b827.png'),
        createItem('修为灵丹（蓝）', 86788, 109238, 'https://pic.imgdb.cn/item/66c369f2d9c307b7e9650429.png'),
        createItem('宠物资质仙丹', 86788, 109238, 'https://pic.imgdb.cn/item/66c9d327d9c307b7e9682c26.png'),
        createItem('融会贯通', 86788, 109238, 'https://pic.imgdb.cn/item/66c9d328d9c307b7e9682dbc.png'),
        createItem('集中值（4点）', 86788, 129238, 'https://pic.imgdb.cn/item/66d1c3a5d9c307b7e9ddf3fa.png'),
        createItem('蓝色武装原料', 56788, 89238, 'https://pic.imgdb.cn/item/66d8732dd9c307b7e964497d.png'),
        createItem('任意打孔器', 116788, 159238, 'https://pic.imgdb.cn/item/66d9e814d9c307b7e93afc61.png'),
        createItem('宝石洗孔符', 26788, 39238, 'https://pic.imgdb.cn/item/666d688ed9c307b7e903cdfd.png'),
        createItem('高级宝石合成符', 56788, 69238, 'https://pic.imgdb.cn/item/66dbff82d9c307b7e9b75a35.png'),
        createItem('宝石袋盲盒', 56788, 69238, 'https://pic.imgdb.cn/item/66db2daed9c307b7e9c7508a.png'),
        createItem('升级宝石礼包（神品）', 116788, 159238, 'https://pic.imgdb.cn/item/66dab9eed9c307b7e92290c5.png'),
        createItem('橙色武装原料', 1419700, 2230950, 'https://pic.imgdb.cn/item/66d8732dd9c307b7e96449c0.png')
    ];

    const ssSkills = collectSkillsByRarity('SS');
    const sSkills = collectSkillsByRarity('S');

    const itemTypes = ['item', 'bundle'];

    if (sSkillCount < 1) {
        itemTypes.push('sSkill');
    }

    if (ssSkillCount < 2) {
        itemTypes.push('ssSkill');
    }

    const itemType = itemTypes[Math.floor(Math.random() * itemTypes.length)];

    let item;
    switch (itemType) {
        case 'item':
            item = selectRandomItems(rareItems, 1)[0];
            break;
        case 'bundle':
            item = createBundleItem(selectRandomItems(rareItems, 1)[0], getRandomInt(2, 100), true);
            break;
        case 'sSkill':
            item = selectRandomItems(sSkills, 1)[0];
            sSkillCount++;
            break;
        case 'ssSkill':
            item = selectRandomItems(ssSkills, 1)[0];
            ssSkillCount++;
            break;
    }

    rareCounts[itemType]++;
    return item;
}

function createItem(name, minPrice, maxPrice, url) {
    return { name, url, price: getRandomInt(minPrice, maxPrice) };
}

function createBundleItem(item, quantity, rare = false) {
    const url = rare 
        ? 'https://pic.imgdb.cn/item/6656a1b6d9c307b7e9baa85b.png' 
        : 'https://pic.imgdb.cn/item/6656a1b6d9c307b7e9baa881.png';

    return {
        ...item,
        name: `${item.name} 包裹 (${quantity})`,
        price: item.price * quantity,
        url: url
    };
}

function createSkillItem(petName, skillName, rarity) {
    const priceRange = rarity === 'SS' ? [221688, 535988] : [111288, 231988];
    const url = rarity === 'SS'
        ? 'https://pic.imgdb.cn/item/665af22fd9c307b7e910c815.png'
        : 'https://pic.imgdb.cn/item/665566e5d9c307b7e971236e.png';
    return createItem(`${petName}·${skillName}`, ...priceRange, url);
}

function addItemToShop(item, shopItems) {
    const itemDiv = document.createElement('div');
    itemDiv.classList.add('shop-item');
    itemDiv.dataset.name = item.name;
    itemDiv.dataset.price = item.price;
    itemDiv.innerHTML = `
        <img src="${item.url}" alt="${item.name}" style="border: 1px solid black;height: 45px;width: 45px;">
        <div class="item-text-container">
            <div class="item-text-top">${item.name}</div>
            <div class="item-text-bottom">${convertPrice(item.price)} 金</div>
        </div>`;

    itemDiv.addEventListener('click', () => {
        const infoBox = document.getElementById('shop-description');
        const itemName = item.name;
        const isPackage = itemName.includes('包裹');
        const itemBaseName = isPackage ? itemName.split(' 包裹 (')[0] : itemName;
        const itemQuantity = isPackage ? parseInt(itemName.split(' 包裹 (')[1].replace(')', ''), 10) : 1;

        // 特殊道具名称与其对应的ID映射
        const specialItems = {
            '高级悟性丹': 'high-grade-pill',
            '万化灵丹': 'transmutation-pill',
            '冰魄还童丹': 'bingpo-reborn-pill',
            '神兽还童丹': 'reborn-pill',
            '资质重生丹': 'quality-pill',
            '灵异金丹': 'miraculous-pill',
            '还童金丹': 'golden-reborn-pill'
        };

        let description = '';

        // 判断是否为特殊道具
        if (specialItems[itemBaseName]) {
            // 获取特殊道具的描述信息
            description = getTopBarItemDescription(specialItems[itemBaseName]);
        } else {
            // 查找1类商品的描述信息
            const matchingItem = jinnangItems.find(jItem => jItem.displayName === itemBaseName);
            const drugItem = drugInventory[itemBaseName];

            if (matchingItem) {
                // 1类商品，显示其描述信息
                description = matchingItem.description;
            } else if (drugItem) {
                description = `战斗中使用，${drugItem.description}`;
            } else {
                // 2类商品（宠物技能），显示默认描述信息
                description = '这是一个宠物技能，如果你有对应宠物，可以直接学会此技能。';
            }
        }

        // 更新选择的UI效果
        document.querySelectorAll('.shop-item').forEach(el => el.classList.remove('selected'));
        itemDiv.classList.add('selected');

        // 更新infoBox中的描述信息
        infoBox.innerText = `${item.name}，售价${convertPrice(item.price)}金。用途：${description}`;
    });

    shopItems.appendChild(itemDiv);
}

function buyItem() {
    const selectedItem = document.querySelector('.shop-item.selected');
    if (!selectedItem) {
        return showInfoBox("请选择一个商品进行购买！");
    }
    
    const originalPrice = parseInt(selectedItem.dataset.price, 10);
    let price = originalPrice;
    const itemName = selectedItem.dataset.name;
    const eightyDiscountCard = jinnangItems.find(i => i.name === 'eightyDiscountCard');
    
    // 获取当前称号的等级
    const titleElement = document.getElementById('personal-honor');
    const currentTitleIndex = titles.indexOf(titleElement.innerText);
    
    // 计算称号折扣
    const titleDiscount = 1 - (currentTitleIndex * 0.005);
    
    // 应用eightyDiscountCard的折扣
    if (eightyDiscountCard && eightyDiscountCard.quantity > 0) {
        price = Math.round(price * 0.8);
    }

    // 应用称号折扣
    price = Math.round(price * titleDiscount);

    if (goldAmount < price) {
        return showInfoBox("金子不足，购买失败！");
    }

    const isPackage = itemName.includes('包裹');
    const itemBaseName = isPackage ? itemName.split(' 包裹 (')[0] : itemName;
    const itemQuantity = isPackage ? parseInt(itemName.split(' 包裹 (')[1].replace(')', ''), 10) : 1;

    const itemHandlers = {
        '高级悟性丹': () => highGradePill += itemQuantity,
        '万化灵丹': () => transmutationPill += itemQuantity,
        '冰魄还童丹': () => bingpoRebornPill += itemQuantity,
        '神兽还童丹': () => rebornPill += itemQuantity,
        '资质重生丹': () => qualityPill += itemQuantity,
        '灵异金丹': () => miraculousPill += itemQuantity,
        '特级悟性丹': () => addItemToJinnang('tejiWisdomPill', itemQuantity),
        '精灵精炼石': () => addItemToJinnang('spiritRefreshStone', itemQuantity),
        '精灵觉醒石': () => addItemToJinnang('spiritAwakenStone', itemQuantity),
        '天地灵气': () => addItemToJinnang('earthlyEnergy', itemQuantity),
        '仙人醍醐': () => addItemToJinnang('ultraSkillBoomer', itemQuantity),
        '聚灵丹': () => addItemToJinnang('hailMonsterPill', itemQuantity),
        '唤妖符': () => addItemToJinnang('hailMonsterAmulet', itemQuantity),
        '修为灵丹（蓝）': () => addItemToJinnang('cultivationPill200', itemQuantity),
        '分解符礼包': () => addItemToJinnang('fragmentsPackage', itemQuantity),
        '宠物资质仙丹': () => addItemToJinnang('qualityEnhancePill', itemQuantity),
        '融会贯通': () => addItemToJinnang('towerGrass', itemQuantity),
        '集中值（4点）': () => addItemToJinnang('attentionValue', itemQuantity),
        '蓝色武装原料': () => addItemToJinnang('blueArmComponents', itemQuantity),
        '橙色武装原料': () => addItemToJinnang('orangeArmComponents', itemQuantity),
        '宝石镶嵌符': () => addItemToJinnang('inlayAmulet', itemQuantity),
        '宝石摘除符': () => addItemToJinnang('removeAmulet', itemQuantity),
        '任意打孔器': () => addItemToJinnang('punchHoleTool', itemQuantity),
        '宝石洗孔符': () => addItemToJinnang('refreshGemSlot', itemQuantity),
        '升级宝石礼包（极品）': () => addItemToJinnang('starGemPKG', itemQuantity),
        '升级宝石礼包（神品）': () => addItemToJinnang('starGemPlusPKG', itemQuantity),
        '高级宝石合成符': () => addItemToJinnang('mergeAmuletPlus', itemQuantity),
        '低级宝石合成符': () => addItemToJinnang('mergeAmulet', itemQuantity),
        '宝石袋盲盒': () => addItemToJinnang('gemLuckyBag', itemQuantity),
        '宠物寿命晶石': () => addItemToJinnang('lifeGem', itemQuantity),
        '还童金丹': () => goldenRebornPill += itemQuantity,
        '延寿露': () => addDrugToInventory('延寿露', itemQuantity),
        '天山雪莲': () => addDrugToInventory('天山雪莲', itemQuantity),
        '忘忧水': () => addDrugToInventory('忘忧水', itemQuantity),
        '三花丸': () => addDrugToInventory('三花丸', itemQuantity)
    };

    if (itemHandlers[itemBaseName]) {
        itemHandlers[itemBaseName]();
    } else if (!isPackage) {
        const [petName, skillName] = itemName.split('·');
        if (skillName) {
            if (document.getElementById('skills-area').children.length >= 12) {
                return showInfoBox("您的宠物已经达到技能上限，无法购买！");
            }
            if (petName !== currentPet.name) {
                return showInfoBox("您的当前宠物不会此技能，购买失败！");
            }
            if (document.getElementById('skills-area').innerText.includes(skillName)) {
                return showInfoBox("您的当前宠物已经拥有此技能，购买失败！");
            }
            addSkillToPet(skillName);
        } else {
            return showInfoBox("未知道具类型，购买失败！");
        }
    } else {
        return showInfoBox("未知包裹类型，购买失败！");
    }

    showInfoBox(`你花费了${convertPrice(price)}金购买${itemName}，本次消费为你节省了${convertPrice(originalPrice - price)}金`);
    updateTopBarItems();
    updateJinnangItems();
    goldAmount -= price;
    updateGoldDisplay(goldAmount);
    selectedItem.remove();
}


function addSkillToPet(skillName) {
    const skill = currentPet.skills.find(skill => skill.name === skillName);
    if (skill) {
        const skillDiv = document.createElement("div");
        skillDiv.innerText = `${skill.name} (${skill.rarity})`;
        skillDiv.onclick = () => deleteSkill(skill, skillDiv, document.getElementById("skills-area"));
        skillDiv.classList.add(skill.rarity.toLowerCase() + '-skill');
        document.getElementById("skills-area").appendChild(skillDiv);
    
        const currentSkills = Array.from(document.querySelectorAll("#skills-area div"))
            .map(div => {
                const [name, rarity] = div.innerText.split(" (");
                return { name, rarity: rarity.replace(")", "") };
            });
        updateSkillScore(currentSkills);
        updateTitle();
    }
}

function fulfillPetSkill() {
    const maxSkills = 12;
    const currentSkills = document.querySelectorAll("#skills-area div").length;

    if (currentSkills >= maxSkills) {
        showInfoBox("您的宠物已经达到技能上限，无法添加更多技能！");
        return;
    }

    const missingSkills = getMissingSkills(currentPet.skills);
    const skillsToAdd = Math.min(missingSkills.length, maxSkills - currentSkills);

    for (let i = 0; i < skillsToAdd; i++) {
        addSkillToPet(missingSkills[i].name);
    }

    if (skillsToAdd > 0) {
        showInfoBox(`成功为宠物添加${skillsToAdd}个技能，当前技能已满！`);
    } else {
        showInfoBox("没有找到可添加的技能，或所有技能已添加！");
    }
}

function getMissingSkills(allSkills) {
    const currentSkillNames = Array.from(document.querySelectorAll("#skills-area div"))
        .map(div => div.innerText.split(" (")[0]);

    return allSkills.filter(skill => !currentSkillNames.includes(skill.name) && !currentSkillNames.byLearned);
}
        
// 初始化商店和倒计时
document.addEventListener('DOMContentLoaded', initShop);

let currentMerchantIndex = 0;
let currentOffer = null;
let currentHerbs = 0;
let starwindMaxMultiplier = 1.8;
let starwindHaggleCount = 0;
let guanghanHaggleCount = 0;
let chaosMerchantHaggleCount = 0;
let hasDealed = false;

// 定义商人状态缓存
const merchantStates = {};

const merchants = [
    {
        name: '朝云富商',
        description: '立足物产丰盈之朝云国，资本积累硕果颇丰，富甲一方。可惜心气浮躁，容不得生意场上半点不快。',
        img: 'https://pic.imgdb.cn/item/668029b4d9c307b7e9ef5248.png',
        getOffer: (skillScore) => {
            let rating, multiplier;
            if (skillScore >= 5000000) {
                rating = '至臻';
                multiplier = 1.6;
            } else if (skillScore >= 4000000) {
                rating = '绝佳';
                multiplier = 1.4;
            } else if (skillScore >= 3000000) {
                rating = '完整';
                multiplier = 1.2;
            } else if (skillScore >= 2000000) {
                rating = '尚可';
                multiplier = 1.0;
            } else if (skillScore >= 1000000) {
                rating = '一般';
                multiplier = 0.8;
            } else {
                rating = '不佳';
                multiplier = 0.6;
            }
            const price = Math.floor((skillScore / 25) * multiplier);
            return { price, rating };
        },
        haggle: (firstOffer) => {
            const multiplier = Math.random() * (1.2 - 0.8) + 0.8;
            const newOffer = Math.floor(firstOffer * multiplier);
            return newOffer;
        },
        reset: () => {
            chaosMerchantHaggleCount = 0;
        }
    },
    {
        name: '星风游商',
        description: '来自黄土高地的游商，有道是行者无疆，收集天下奇珍异宝，遇到宝物可不惜一切代价。',
        img: 'https://pic.imgdb.cn/item/668029b4d9c307b7e9ef522a.png',
        getOffer: (skillScore) => {
            const multiplier = Math.random() * (1.8 - 0.4) + 0.4;
            const price = Math.floor((skillScore / 25) * multiplier);
            return { price, rating: null };
        },
        haggle: (firstOffer) => {
            starwindMaxMultiplier = Math.max(0.4, starwindMaxMultiplier - 0.1);
            const multiplier = Math.random() * (starwindMaxMultiplier - 0.4) + 0.4;
            const newOffer = Math.floor(firstOffer * multiplier);
            return newOffer;
        },
        reset: () => {
            starwindMaxMultiplier = 1.8;
            starwindHaggleCount = 0;
        }
    },
    {
        name: '广寒药商',
        description: '极北之地亦能生长万物滋养百姓，靠的是千万药商为生灵谋康健。尝得百草，固守一方田间黄金库。',
        img: 'https://pic.imgdb.cn/item/668029b4d9c307b7e9ef5241.png',
        getOffer: (skillScore) => {
            let herbs;
            if (skillScore >= 3000000) {
                herbs = 50;
            } else if (skillScore >= 1500000) {
                herbs = 30;
            } else if (skillScore >= 900000) {
                herbs = 25;
            } else {
                herbs = 20;
            }
            const price = Math.floor((skillScore / 25) * 0.2);
            return { price, herbs };
        },
        haggle: (currentHerbs, currentOffer) => {
            if (currentHerbs < 61) {
                currentHerbs += 1;
                currentOffer = Math.floor(currentOffer * 0.99);
            }
            return { currentHerbs, currentOffer };
        },
        reset: () => {
            guanghanHaggleCount = 0;
        }
    }
];

function switchMerchant() {
    const currentMerchant = merchants[currentMerchantIndex];
    // 保存当前商人的状态
    merchantStates[currentMerchant.name] = {
        currentOffer,
        currentHerbs,
        starwindMaxMultiplier,
        starwindHaggleCount,
        guanghanHaggleCount,
        chaosMerchantHaggleCount
    };

    currentMerchantIndex = (currentMerchantIndex + 1) % merchants.length;
    displayMerchant();
}

function displayMerchant() {
    const merchant = merchants[currentMerchantIndex];
    // 恢复当前商人的状态
    if (hasDealed) {
        const offerData = merchant.getOffer(skillScore);
        currentOffer = offerData.price;
        currentHerbs = offerData.herbs || 0;
        hasDealed = false;
    } else if (merchantStates[merchant.name]) {
        const state = merchantStates[merchant.name];
        currentOffer = state.currentOffer;
        currentHerbs = state.currentHerbs;
        starwindMaxMultiplier = state.starwindMaxMultiplier;
        starwindHaggleCount = state.starwindHaggleCount;
        guanghanHaggleCount = state.guanghanHaggleCount;
        chaosMerchantHaggleCount = state.chaosMerchantHaggleCount;
    } else {
        const offerData = merchant.getOffer(skillScore);
        currentOffer = offerData.price;
        currentHerbs = offerData.herbs || 0;
    }

    const merchantSection = document.getElementById('merchant-section');
    merchantSection.innerHTML = `
        <div style="display: flex; align-items: center; gap: 10px;">
            <img src="${merchant.img}" style="width: 65px; height: 65px; cursor: pointer;" onclick="switchMerchant()">
            <div style="margin-left: 10px;">
                <div style="font-size: 16px; font-weight: bold; color: white;">${merchant.name}</div>
                <div style="font-size: 14px; color: white;">${merchant.description}</div>
            </div>
        </div>
    `;

    const offerSection = document.getElementById('offer-section');
    offerSection.innerHTML = `
        ${merchant.name === '广寒药商' ? `<div style="font-size: 14px; color: white; font-weight: bold;">药商愿意给出金子：${convertPrice(currentOffer)}，草药：${currentHerbs}株，希望驭兽师大人成全。</div>` : `<div style="font-size: 14px; color: white; font-weight:bold;">在场商人看到你的宠物议论纷纷，其中你所询问的一位商人出价：${convertPrice(currentOffer)}金子，同意即可点击Deal交易。（提示：点击商人头像可更换议价对象）</div>`}
    `;
}

function haggle() {
    const merchant = merchants[currentMerchantIndex];
    const offerSection = document.getElementById('offer-section');

    if (merchant.name === '朝云富商') {
        if (chaosMerchantHaggleCount === 0) {
            chaosMerchantHaggleCount += 1;
            const newOffer = merchant.haggle(currentOffer);
            currentOffer = newOffer;
            const { rating } = merchant.getOffer(skillScore); // 获取正确的rating值
            offerSection.innerHTML = `<div style="font-size: 14px; color: white; font-weight: bold;">你的宠物在我眼里品相最多算个${rating}，不是什么千古未见的灵兽，没甚么好稀奇的！我再最后给你出价 ${convertPrice(currentOffer)} 金子！</div>`;
        } else {
            offerSection.innerHTML = `<div style="font-size: 14px; color: red; font-weight: bold;">老夫没有功夫和你掰扯这牛羊买卖之事！这1文金子和你做个一锤子买卖！</div>`;
            currentOffer = 1;
        }
    } else if (merchant.name === '星风游商') {
        if (starwindHaggleCount < 15) {
            starwindHaggleCount += 1;
            const newOffer = merchant.haggle(currentOffer);
            currentOffer = newOffer;
            offerSection.innerHTML = `<div style="font-size: 14px; color: white; font-weight: bold;">驭兽师，你的宠物我是越看越新生欢喜，你既有意割爱，我便愿意再出价${convertPrice(currentOffer)}金子，你考虑一下吧！</div>`;
        } else {
            offerSection.innerHTML = `<div style="font-size: 14px; color: red; font-weight: bold;">驯兽师，再不成交，天色就晚啦！我只能出到${convertPrice(currentOffer)}金子啦！</div>`;
        }
    } else if (merchant.name === '广寒药商') {
        if (guanghanHaggleCount < 10) {
            guanghanHaggleCount += 1;
            const result = merchant.haggle(currentHerbs, currentOffer);
            currentHerbs = result.currentHerbs;
            currentOffer = result.currentOffer;
            offerSection.innerHTML = `<div style="font-size: 14px; color: white; font-weight: bold;">驭兽人，我愿意出价金子：${convertPrice(currentOffer)}，和草药：${currentHerbs}株与你交换，你可愿意割爱？</div>`;
        } else {
            offerSection.innerHTML = `<div style="font-size: 14px; color: red; font-weight: bold;">驭兽人，因缘际会，若是实在无缘，老夫也只能黯然离开。（德高望重的药商离去后，在场商人都不愿和你交易，你只得到了来自司鬻部退还的1文代售手续费）</div>`;
            currentOffer = 1;
            currentHerbs = 1;
        }
    }
}

function deal() {
    const merchant = merchants[currentMerchantIndex];
    if (merchant.name === '广寒药商') {
        const drugKeys = Object.keys(drugInventory);
        for (let i = 0; i < currentHerbs; i++) {
            const randomDrug = drugKeys[Math.floor(Math.random() * drugKeys.length)];
            drugInventory[randomDrug].quantity += 1;
            logBattleEvent(`你获得了 ${randomDrug} x1`, 'pink');
        }
    }
    const petSelect = document.getElementById("pet-select");
    const selectedPetKey = petSelect.value;
    const petToDelete = currentPet.name;
    clearAdvancementStates(petToDelete); //处理清空宠物的技能加成
    // 从下拉菜单中移除当前宠物
    const optionToRemove = petSelect.querySelector(`option[value="${selectedPetKey}"]`);
        console.log(`出售的是:${selectedPetKey}`);
        if (optionToRemove) { 
            optionToRemove.remove();        
        }
        // 设置默认选择第一个宠物
        if (petSelect.options.length > 0) {
            petSelect.value = petSelect.options[0].value;
            changePet(true); // 更新宠物信息,跳过确认提示
        }
    updateDisplayContent();
    goldAmount += currentOffer;
    updateGoldDisplay(goldAmount);
    showInfoBox(`你在此交易中获得了${convertPrice(currentOffer)}金子`);
    deletePetData(petToDelete);
    // 重置所有商人的状态
    merchants.forEach(merchant => merchant.reset());
    hasDealed = true;
    closeMerchantModal();
    
    saveGameState();
}


// 显示商人交易界面
function showMerchantModal() {
    const merchantModal = document.createElement('div');
    merchantModal.style.position = 'fixed';
    merchantModal.style.top = '50%';
    merchantModal.style.left = '50%';
    merchantModal.style.transform = 'translate(-50%, -50%)';
    merchantModal.style.width = '300px';
    merchantModal.style.height = '400px';
    merchantModal.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
    merchantModal.style.borderRadius = '10px';
    merchantModal.style.padding = '20px';
    merchantModal.style.zIndex = '9999';
    merchantModal.style.display = 'flex';
    merchantModal.style.flexDirection = 'column';
    merchantModal.style.justifyContent = 'space-between';

    const merchantSection = document.createElement('div');
    merchantSection.id = 'merchant-section';
    merchantModal.appendChild(merchantSection);

    const offerSection = document.createElement('div');
    offerSection.id = 'offer-section';
    merchantModal.appendChild(offerSection);

    const buttonContainer = document.createElement('div');
    buttonContainer.style.marginTop = '60px';
    buttonContainer.style.textAlign = 'center';
    buttonContainer.style.display = 'grid';
    buttonContainer.style.gridTemplateColumns = 'repeat(2, 1fr)';

    const dealButton = document.createElement('button');
    dealButton.innerText = 'DEAL!';
    dealButton.style.marginRight = '20px';
    dealButton.style.padding = '10px 20px';
    dealButton.style.borderRadius = '10px';
    dealButton.style.border = '1px solid white';
    dealButton.style.backgroundColor = 'green';
    dealButton.style.color = 'white';
    dealButton.style.cursor = 'pointer';
    dealButton.addEventListener('click', deal);
    buttonContainer.appendChild(dealButton);

    const haggleButton = document.createElement('button');
    haggleButton.innerText = '讨价还价';
    haggleButton.style.padding = '10px 20px';
    haggleButton.style.borderRadius = '10px';
    haggleButton.style.border = '1px solid white';
    haggleButton.style.backgroundColor = 'orange';
    haggleButton.style.color = 'white';
    haggleButton.style.cursor = 'pointer';
    haggleButton.addEventListener('click', haggle);
    buttonContainer.appendChild(haggleButton);

    merchantModal.appendChild(buttonContainer);

    document.body.appendChild(merchantModal);

    displayMerchant();

    currentInfoBox = merchantModal;
}

// 关闭商人交易界面
function closeMerchantModal() {
    if (currentInfoBox) {
        document.body.removeChild(currentInfoBox);
        currentInfoBox = null;
    }
}

// 修改后的 sellPet 函数
function sellPet() {
    const skillScoreElement = document.getElementById("skill-score");
    skillScore = parseInt(skillScoreElement.innerText, 10);

    if (skillScore < 10000) {
        showInfoBox("宠物当前分数低于10000分，无法出售！");
        return;
    }

    const petSelect = document.getElementById("pet-select");
    const selectedPetKey = petSelect.value;

    if (petSelect.options.length <= 1) {
        showInfoBox("这是您的唯一爱宠了，请好好珍惜它！");
        return;
    }

    showInfoBox("\n1. 你的宠物会被运送至市场供商人出价，无论市场估价结果如何，宠物都会被出售。\n2.请注意首页下拉栏显示名称与你想出售的宠物一致，否则将错误地出售其他宠物！", () => {
        // 检查是否有五行符被当前宠物装备，遍历全局变量
        const petAmulet = wuxingStates.find(a => a.equipped && a.currentPetName === currentPet.name);
        
        if (petAmulet || qualityPillCount > 0) {
            showInfoBox('宠物身上还有没取下来的五行符或资质仙丹！', null, null, 'red');
            return;
        } else {
            showMerchantModal();
        }
    });
}

function resetPet() {

    // 重置宠物资质和属性
    currentPet.qualities.tier = '普通';
    currentPet.qualities.growthRate = 100;
    currentPet.qualities.mutated = false;

    // 重置当前资质为最小值
    currentPet.qualities.agility.current = currentPet.qualities.agility.min;
    currentPet.qualities.endurance.current = currentPet.qualities.endurance.min;
    currentPet.qualities.faith.current = currentPet.qualities.faith.min;
    currentPet.qualities.intelligence.current = currentPet.qualities.intelligence.min;
    currentPet.qualities.strength.current = currentPet.qualities.strength.min;

    // 重置基础属性为初始值，调用calculateAttribute
    baseAttributes = {
        agility: calculateAttribute(currentPet.qualities.agility.min, currentPet.qualities.growthRate / 100, petLevel, 0, false),
        endurance: calculateAttribute(currentPet.qualities.endurance.min, currentPet.qualities.growthRate / 100, petLevel, 0, false),
        faith: calculateAttribute(currentPet.qualities.faith.min, currentPet.qualities.growthRate / 100, petLevel, 0, false),
        intelligence: calculateAttribute(currentPet.qualities.intelligence.min, currentPet.qualities.growthRate / 100, petLevel, 0, false),
        strength: calculateAttribute(currentPet.qualities.strength.min, currentPet.qualities.growthRate / 100, petLevel, 0, false)
    };

    // 初始化等级和其他基础属性
    additionalPlayerCultivation = 0;
    qualityPillCount = 0;
    consumedPillCount = 0;
    armsOpened = false; // 武装上锁
    ascensionAttributes = {
        health: 0,
        mana: 0,
        magicAttack: 0,
        magicDefense: 0,
        physicalAttack: 0,
        physicalDefense: 0,
        speed: 0
    };
    ascensionEnabled = false; // 飞升之术关闭
    ascensionSkill = {
        name: '未开启',
        level: 1,
        effect: '未开启飞升技能'
    }; // 第一个飞升技能为空
    awakenAttributes = {
        agility: 0,
        endurance: 0,
        faith: 0,
        intelligence: 0,
        strength: 0
    };
    additionalAttributes = {
        agility: 0,
        endurance: 0,
        faith: 0,
        intelligence: 0,
        strength: 0
    };
    awakened = false;
    bonusAttributes = {
        agility: 0,
        endurance: 0,
        faith: 0,
        intelligence: 0,
        strength: 0
    };
    currentExp = 0; // 当前经验值
    currentSpecialization = null;
    currentWisdom = 0;
    defaultImageUrl = "https://pic.imgdb.cn/item/665d02afd9c307b7e903151b.png";
    divinedWeaponStatus = false;
    document.body.style.backgroundImage = "";
    document.getElementById("hallucination-level").innerText = `${hallucinationLevel}`;
    drugBonus0 = {
        health: 0,
        mana: 0,
        magicAttack: 0,
        magicDefense: 0,
        physicalAttack: 0,
        physicalDefense: 0,
        speed: 0
    }; // 药品增幅buff清空
    drugBonus = {
        health: 0,
        mana: 0,
        magicAttack: 0,
        magicDefense: 0,
        physicalAttack: 0,
        physicalDefense: 0,
        speed: 0
    }; // 药品增幅buff清空
    enemyCritDamage = 1.8; // 180%
    enemyCritRate = 0.6; // 60%
    evolutionLevel = 0;
    experienceTreasureOpenCount = 0;
    growthRate = 1;
    hallucinated = false;
    hallucinationLevel = 0;
    lockArms();
    maxExp = 208; // 经验值上限
    petAscended = false;
    petLevel = 1;
    petMaxLevel = 149;
    petWisdom = currentWisdom;
    playerCritDamage = 1.5; // 150%
    playerCritRate = 0.1; // 10%
    poisonSkillActivated = false; // 施毒之术关闭
    reenableAscension = false; // 第二个飞升之术关闭
    remainingPoints = 0;
    removeArmsAttributes();
    if (!onBattleState && enemyInitialState !== null) {
        restoreEnemyState();
    }
    secondAscensionSkill = {
        name: '未开启',
        level: 1,
        effect: '未开启飞升技能'
    }; // 第二个飞升技能为空
    setInnerText("agility-current", currentPet.qualities.agility.current);
    setInnerText("attribute-agility", baseAttributes.agility);
    setInnerText("attribute-endurance", baseAttributes.endurance);
    setInnerText("attribute-faith", baseAttributes.faith);
    setInnerText("attribute-intelligence", baseAttributes.intelligence);
    setInnerText("attribute-strength", baseAttributes.strength);
    setInnerText("current-wisdom", 0);
    setInnerText("endurance-current", currentPet.qualities.endurance.current);
    setInnerText("evolution-level", evolutionLevel);
    setInnerText("faith-current", currentPet.qualities.faith.current);
    setInnerText("growth-rate", currentPet.qualities.growthRate);
    setInnerText("intelligence-current", currentPet.qualities.intelligence.current);
    setInnerText("mutated", currentPet.qualities.mutated ? "是" : "否");
    setInnerText("pet-level", petLevel);
    setInnerText("skill-score", skillScore);
    setInnerText("strength-current", currentPet.qualities.strength.current);
    setInnerText("tier", currentPet.qualities.tier);
    setInnerText("train-count", 0);
    skillScore = 0; // 初始化评分
    spiritLevel = 1;
    spiritMultiplier = 1.00;
    trainingCount: 0;
    const secondSkillBox = document.getElementById('second-ascension-skill');
    secondSkillBox.style.display = 'none'; // 隐藏第二飞升技能面板
    const skillsArea = document.getElementById("skills-area");
    if (skillsArea) {
        skillsArea.innerHTML = ""; // 清空技能区域
    }

    resetArmsState(); //重置武装

    // 更新显示的各项数值
    updateAscensionButton();
    updateQualityDisplayWithPillBonus();
    updateAscensionDisplay();
    updateAscensionStatus();
    updateAttributePanel();
    updateAwakenStatus();
    updatePetInfo();
    updateQualityCard();
    updateTopBarItems();
}

function resetArmsState() {
    armsAttributes = [];
    armsAttributes = {
        horn: { type: "尖角", value: 0, attributes: ["physicalAttack", "magicAttack", "health", "mana"], url: "https://pic.imgdb.cn/item/666f194ed9c307b7e907bfb2.png", enduranceValue: 500, activated: false, description:'锐利无比的尖角，能轻易刺穿敌人的弱点' },
        fur: { type: "毛皮", value: 0, attributes: ["physicalDefense", "magicDefense", "health"], url: "https://pic.imgdb.cn/item/666f194dd9c307b7e907bf7b.png", enduranceValue: 500, activated: false, description:'手感非凡的护甲之物，能带来不俗的防御能力' },
        fang: { type: "獠牙", value: 0, attributes: ["physicalAttack", "speed", "magicAttack"], url: "https://pic.imgdb.cn/item/666f194dd9c307b7e907bed6.png", enduranceValue: 500, activated: false, description:'上古神兽曾用它噬铁碎骨' },
        claw: { type: "利爪", value: 0, attributes: ["physicalAttack", "speed", "magicAttack", "mana"], url: "https://pic.imgdb.cn/item/666f194dd9c307b7e907be47.png", enduranceValue: 500, activated: false, description:'利爪挥过，血流成河' },
        tailWhip: { type: "尾鞭", value: 0, attributes: ["physicalAttack", "speed", "magicAttack"], url: "https://pic.imgdb.cn/item/666f194cd9c307b7e907bdd1.png", enduranceValue: 500, activated: false, description:'虽不如毒鳌般凌厉，仍有破势之力' },
        husk: { type: "甲壳", value: 0, attributes: ["physicalDefense", "speed", "magicDefense"], url: "https://pic.imgdb.cn/item/667fc40cd9c307b7e941f3bd.png", enduranceValue: 500, activated: false, description:'自然之力形成的坚硬盔甲，可抵敌人中伤' }
    };
}
        
function setInnerText(id, value) {
    const element = document.getElementById(id);
    if (element) {
        element.innerText = value;
    } else {
        console.warn(`元素ID为 ${id} 的元素未找到。`);
    }
}

function toggleDrawer() {
    const drawer = document.getElementById('quality-drawer');
    const info = document.getElementById('quality-info');
    drawer.classList.toggle('open');
    info.classList.toggle('open');
}

function checkDrawerOpen() {
    const drawer = document.getElementById('quality-drawer');
    if (!drawer.classList.contains('open')) {
        const messageBox = document.createElement('div');
        messageBox.style = "padding: 20px; background: white; border: 1px solid black; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 1000;";
        messageBox.innerHTML = `<p>请先打开资质面板！</p>
                                <button onclick="document.body.removeChild(this.parentNode)">关闭</button>`;
        document.body.appendChild(messageBox);
        return false;
    }
    return true;
}

function upgradeWisdom() {
    let successRate;

    if (currentWisdom < 20) {
        if (highGradePill < 1) {
            showInfoBox("您的高级悟性丹已耗尽！");
            return;
        }

        highGradePill--;
        document.getElementById("high-grade-pill").innerText = highGradePill;

        if (currentWisdom < 7) successRate = 0.9;
        else if (currentWisdom < 13) successRate = 0.75;
        else if (currentWisdom < 18) successRate = 0.45;
        else successRate = 0.15;

        if (Math.random() < successRate) {
            currentWisdom = Math.min(currentWisdom + 1, 20);
        } else {
            if (currentWisdom > 0) {
                if (currentWisdom < 8) currentWisdom = Math.max(0, currentWisdom - 2);
                else if (currentWisdom < 13) currentWisdom = Math.max(8, currentWisdom - 2);
                else if (currentWisdom < 18) currentWisdom = Math.max(13, currentWisdom - 2);
                else currentWisdom = Math.max(15, currentWisdom - 2);
            }
        }
    } else {
        if (!awakened) {
            showInfoBox("您的宠物悟性已到上限！");
            return;
        }

        const tejiWisdomPillItem = jinnangItems.find(i => i.name === 'tejiWisdomPill');

        if (!tejiWisdomPillItem || tejiWisdomPillItem.quantity < 1) {
            showInfoBox("您的特级悟性丹已耗尽！");
            return;
        }

        tejiWisdomPillItem.quantity--;
        updateJinnangItems();

        if (currentWisdom == 20) successRate = 0.85;
        else if (currentWisdom == 21) successRate = 0.65;
        else if (currentWisdom == 22) successRate = 0.45;
        else if (currentWisdom == 23) successRate = 0.25;
        else successRate = 0.05;

        if (Math.random() < successRate) {
            currentWisdom = Math.min(currentWisdom + 1, 25);
        } else {
            currentWisdom = Math.max(20, currentWisdom - 2);
        }
    }

    document.getElementById("current-wisdom").innerText = currentWisdom;
    document.getElementById("attribute-wisdom").value = currentWisdom; // 更新输入框的值

    updateAttributePanel(); // 更新属性面板
}

function trainSkills() {
    const ultraSkillBoomer = jinnangItems.find(item => item.name === 'ultraSkillBoomer');
    
    if (ultraSkillBoomer && ultraSkillBoomer.quantity > 0) {
        showInfoBox("你拥有极为珍贵的仙人醍醐，可以直接让宠物醍醐灌顶，掌握大量技能，是否使用？", 
        () => {
            if (useItem('ultraSkillBoomer', 1)) {
                const selectedSkills = selectRandomSkills(10, 12, currentPet.skills.length);
                updateSkillsAndNotify(selectedSkills);
            } else {
                executeTransmutationPillLogic();
            }
        }, 
        () => {
            executeTransmutationPillLogic();
        });
    } else {
        executeTransmutationPillLogic();
    }
}

function executeTransmutationPillLogic() {
    if (transmutationPill < 1) {
        showInfoBox("您的道具不够，请刷新后重试！");
        return;
    }

    transmutationPill--;
    document.getElementById("transmutation-pill").innerText = transmutationPill;

    let skillNum;
    if (currentWisdom < 13) {
        skillNum = Math.min(getRandomSkillNum([0.80, 0.05, 0.05, 0.02, 0.02, 0.02]), 5, currentPet.skills.length);
    } else if (currentWisdom < 17) {
        skillNum = Math.min(getRandomSkillNum([0.80, 0.05, 0.05, 0.02, 0.02, 0.02]), 6, currentPet.skills.length);
    } else if (currentWisdom < 19) {
        skillNum = Math.min(getRandomSkillNum([0.80, 0.05, 0.05, 0.02, 0.02, 0.02]), 7, currentPet.skills.length);
    } else if (currentWisdom < 20) {
        skillNum = Math.min(getRandomSkillNum([0.80, 0.05, 0.05, 0.02, 0.02, 0.02]), 8, currentPet.skills.length);
    } else {
        skillNum = Math.max(3, Math.min(getRandomSkillNum([0.80, 0.05, 0.05, 0.02, 0.02, 0.02, 0.01, 0.01, 0.008, 0.002]), currentPet.skills.length));
    }

    const selectedSkills = selectRandomSkills(skillNum, skillNum, currentPet.skills.length);

    if (selectedSkills.length >= 8) {
        showInfoBox("你把技能洗爆了,点击确定查看!", () => {
            updateSkillsAndNotify(selectedSkills);
        });
        return;
    }

    updateSkillsAndNotify(selectedSkills);
}

// 封装技能随机选择逻辑，并确保不选中已学习的技能
function selectRandomSkills(minSkillNum, maxSkillNum, maxPossibleSkills) {
    const skillNum = Math.min(Math.floor(Math.random() * (maxSkillNum - minSkillNum + 1)) + minSkillNum, maxPossibleSkills);
    const selectedSkills = [];
    
    while (selectedSkills.length < skillNum) {
        const randomSkill = currentPet.skills[Math.floor(Math.random() * currentPet.skills.length)];
        // 添加 byLearned 检查，确保技能没有被学习
        if (!randomSkill.byLearned && !selectedSkills.includes(randomSkill)) {
            selectedSkills.push(randomSkill);
        }
    }
    return selectedSkills;
}

// 更新技能区域并显示通知
function updateSkillsAndNotify(selectedSkills) {
    updateSkillsArea(selectedSkills);
    updateSkillScore(selectedSkills);
    updateTitle();
}


function getRandomSkillNum(probabilities) {
    const total = probabilities.reduce((sum, prob) => sum + prob, 0);
    let rand = Math.random() * total;
    for (let i = 0; i < probabilities.length; i++) {
        if (rand < probabilities[i]) {
            return i + 1;
        }
        rand -= probabilities[i];
    }
    return 1;
}
        
function updateSkillsArea(selectedSkills) {
    const skillsArea = document.getElementById("skills-area");
    const existingSkills = Array.from(skillsArea.children).map(skillDiv => skillDiv.innerText.split(' ')[0]);
    skillsArea.innerHTML = "";
    selectedSkills.forEach(skill => {
        if (!existingSkills.includes(skill.name)) {
            const skillDiv = document.createElement("div");
            skillDiv.innerText = `${skill.name} (${skill.rarity})`;
            skillDiv.onclick = () => {
                deleteSkill(skill, skillDiv, skillsArea);
            };
            if (skill.rarity === 'S') {
                skillDiv.classList.add('s-skill');
            } else if (skill.rarity === 'SS') {
                skillDiv.classList.add('ss-skill');
            } else if (skill.rarity === 'SSS') {
                skillDiv.classList.add('sss-skill');
            }
            skillsArea.appendChild(skillDiv);
        }
    });
}

function createSkills(name, rarity, type, level, multiplier, description) {
    // 使用函数参数的实际值，而不是字符串
    const skillsArea = document.getElementById("skills-area");
    const skillDiv = document.createElement("div");
    const existingSkills = Array.from(skillsArea.children).map(skillDiv => skillDiv.innerText.split(' ')[0]);
    const sssSkills = currentPet.skills.filter(skill => {
        // 匹配 existingSkills 中的技能名称
        return existingSkills.includes(skill.name) && skill.rarity === 'SSS';
    });

    if (rarity === 'SSS' && sssSkills.length > 2) {
        showInfoBox('SSS技能最多只能同时拥有三个！',null,null,'red');
        return;
    }
    
    if (existingSkills.length >= 12) {
        showInfoBox('已超过可拥有的技能数量上限！',null,null,'red');
        return;
    }
    
    if (!existingSkills.includes(name)) {
        currentPet.skills.push({ 
            name: name, 
            rarity: rarity, 
            type: type, 
            level: level, 
            multiplier: multiplier, 
            description: description,
            byLearned: true
        });
    } else {
        showInfoBox('此技能你已经学会，无法重复学习！',null,null,'red');
        return;
    }
    
    const skill = currentPet.skills.find(s => s.name === name);
    skillDiv.innerText = `${name} (${rarity})`;  // 在页面上显示技能名称和稀有度
    showInfoBox(`成功学会${name}，技能效果：${description}`);
    skillDiv.onclick = () => {
        deleteSkill(skill, skillDiv, skillsArea);
    };
    if (rarity === 'S') {
        skillDiv.classList.add('s-skill');
    } else if (rarity === 'SS') {
        skillDiv.classList.add('ss-skill');
    } else if (rarity === 'SSS') {
        skillDiv.classList.add('sss-skill');
    }
    skillsArea.appendChild(skillDiv);
}

function deleteSkill(skill, skillDiv, skillsArea) {
    // 在 currentPet.skills 中找到与 skillDiv 对应的技能对象
    const matchingSkill = currentPet.skills.find(s => s.name === skill.name);
    const skillType = matchingSkill.type;

    if (matchingSkill) {
        let skillLevel = matchingSkill.level ? matchingSkill.level : 1;
        let skillMultiplier = calculateSkillLevelAndMultiplier(matchingSkill).skillMultiplier;

        const skillTypeMap = {
            "PA": "物理攻击技能，与物理攻击力相关",
            "PAE": "高级物理攻击技能，通常带有特殊效果或更高的技能伤害",
            "MA": "法术攻击技能，与法术攻击力相关",
            "MAE": "高级法术攻击技能，通常带有特殊效果或更高的技能伤害",
            "PP": "施毒技能，与法术攻击力和修为有关",
            "PPE": "高级施毒技能，通常带有更猛烈的战斗效果",
            "PH": "治疗技能，与法术攻击力和修为有关",
            "PHE": "高级治疗技能，通常带有加强或增益的效果",
            "PD": "防御技能，会根据技能系数增加防御的伤害抵消数值",
            "PDE": "高级防御技能，通常带有特殊效果",
            "SH": "智慧守护技能,在战斗中会根据等级消耗一定比例的法力值来抵消伤害",
            "HL": "法力回复技能，在战斗中会根据等级每回合回复一定比例的法力值",
            "FH": "复活技能，拥有该技能的宠物会根据技能等级计算在战局中的复活次数和恢复血量",
            "JK": "解除控制技能，拥有该技能的宠物会根据技能等级，按照一定概率解除来自敌人的控制效果",
            "JKE": "高级辅助技能，拥有该技能的宠物会根据技能等级，按照技能说明为玩家提供增益",
            "N": "被动属性加成技能，将会按照固定值为玩家提供二级属性",
            "NE": "高级被动技能，通常会增强宠物的专有属性，此类技能最高可升至6级",
            "TC": "十分罕见的必杀技！拥有这种技能的宠物能在战场所向披靡"
        };
        
        const skillDescription = matchingSkill.description;
        const skillTypeDescription = skillTypeMap[skillType] || "未知类型技能";

        // 定义确认删除技能的回调函数
        function onConfirm() {
            // 删除技能的DOM元素
            
            const matchingSkill = currentPet.skills.find(s => s.name === skill.name);
            matchingSkill.level = 1;
            const deleteResult = calculateSkillLevelAndMultiplier(matchingSkill);
            skillLevel = deleteResult.skillLevel;
            skillMultiplier = deleteResult.skillMultiplier;
            
            skillsArea.removeChild(skillDiv);

            // 获取当前技能列表并更新评分
            const remainingSkills = Array.from(skillsArea.children).map(div => {
                const [name, rarity] = div.innerText.split(' (');
                return { name, rarity: rarity.replace(')', '') };
            });

            updateSkillScore(remainingSkills);
        }

        // 定义取消删除技能的回调函数
        function onCancel() {
            console.log('取消删除技能');
        }

        // 显示信息框，展示对应技能的描述并传入回调函数
        showInfoBox(
            `\n${skill.name} ${skillLevel}级：${skillDescription}\n\n⚠️上述说明仅用于还原原版游戏内容，真实作用：\n\n这是一个${skillTypeDescription}，当前技能系数为${(skillMultiplier * 100).toFixed(0)}%\n\n你是否要删除此技能?`,
            () => {
                showInfoBox(`你确定要删除${skill.name}吗？该操作无法恢复！`,
                    onConfirm,
                    onCancel,
                    'red'
                );
            },
            onCancel,
            'black' // 可选的颜色参数
        );
    } else {
        console.error('未找到匹配的技能');
        // 可以考虑在UI中给出用户友好的提示
        showInfoBox('未找到匹配的技能，删除操作无法进行。', null, null, 'red');
    }
}


// 技能效果的定时器需要全局定义，计时器可以不定义，使用battleState.enemy[status]即可
let bleedingInterval = null;
let healingInterval = null;
        
function applySpecialSkillEffects(skill, value = null) {
    // skill是一个数组，不是一个单独的变量名
    // value参数用于传递各行动函数具备潜再处理的结果数值，比如再处理伤害数值、恢复数值等
    // 这个函数主要处理战斗事件，非战斗事件的NE技能将独立处理
    const skillDetail = calculateSkillLevelAndMultiplier(skill); //得到skillLevel, skillMultiplier
    // 定义特殊技能及其对应的效果
    const specialSkills = {
        "利爪猛击": () => {
            // 如果敌人已经出血，直接返回
            if (battleState.enemy.bleeding || bleedingInterval !== null) {
                return;
            }

            // 设定敌人为出血状态
            battleState.enemy.bleeding = true;
            const bleedingDuration = Math.max(100, skillDetail.skillLevel * 200);

            // 设置出血效果，每500ms对敌人造成一次伤害
            bleedingInterval = setInterval(() => {
                const bleedingDamage = Math.round(battleAttributes.physicalAttack * skillDetail.skillMultiplier * ((Math.random() * 0.1) + 1));
                battleState.enemy.health = Math.max(0, battleState.enemy.health - bleedingDamage);
                updateDamageValue(bleedingDamage, false, 'extra-damage', true);
                updateUI();
            }, 500);

            // 出血效果持续3秒
            setTimeout(() => {
                clearInterval(bleedingInterval);  // 停止出血伤害
                bleedingInterval = null;
                battleState.enemy.bleeding = false;  // 敌人不再出血
            }, bleedingDuration + 1000);
        },
        "火焰冲击": () => {
            if (battleState.enemy.corrode) {
                return;
            }
            
            battleState.enemy.corrode = true;
            const corrodegDuration = Math.max(100, skillDetail.skillLevel * 200);
            const originalEnemyPD = battleState.enemy.physicalDefense;
            const originalEnemyMD = battleState.enemy.magicDefense;
            const corrodedDefenseValue = Math.floor(skillDetail.skillMultiplier * 0.02 * (originalEnemyPD + originalEnemyMD));

            battleState.enemy.physicalDefense = Math.max(0, battleState.enemy.physicalDefense - corrodedDefenseValue);
            battleState.enemy.magicDefense = Math.max(0, battleState.enemy.magicDefense - corrodedDefenseValue);
            logBattleEvent(`带有灵力的火焰腐蚀了敌人的护甲，敌人双防降低了${corrodedDefenseValue}点`, 'purple');

            // 腐蚀效果持续3秒
            setTimeout(() => {
                battleState.enemy.corrode = false;  // 敌人不再腐蚀护甲
                if (!summonEnemy) {
                    battleState.enemy.physicalDefense = enemyInitialState.physicalDefense;
                    battleState.enemy.magicDefense = enemyInitialState.magicDefense;
                } else {
                    battleState.enemy.physicalDefense = originalEnemyPD;
                    battleState.enemy.magicDefense = originalEnemyMD;
                }

            }, corrodegDuration + 1000);
        },
        "天空守护": () => {
            if (battleState.player.healing || healingInterval !== null) {
                return;
            }
            
            battleState.player.healing = true;
            const healValuePerSec = Math.floor(Math.random() * battleAttributes.magicAttack + playerCultivation * 0.0000001 * battleAttributes.magicAttack * skillDetail.skillMultiplier);
            const healingDuration = 1000 + skillDetail.skillLevel * 100;
            healingInterval = setInterval(() => {
                if (battleState.player.healing) {
                    battleAttributes.health = Math.min(maxHealth, battleAttributes.health + healValuePerSec);
                    updateDamageValue(-healValuePerSec, true, 'extra-damage');
                }
            }, 1000);

            setTimeout(() => {
                clearInterval(healingInterval); 
                healingInterval = null;
                battleState.player.healing = false;  
            }, healingDuration);
        },
        "锁喉": () => {
            const decreaseValue = Math.max(1, Math.floor(value * Math.min(1, skillDetail.skillMultiplier * 0.25)));
            enemyMaxHealth = Math.max(0, enemyMaxHealth - decreaseValue);
        },
        "极阳罡气": () => {
            if (battleState.player.reflecting) {
                return;
            }
            
            const reflectDuration = skillDetail.skillLevel * 100 + 3000;
            battleState.player.reflecting = true;
            GQreflectPercentage = Math.min(30, Math.round(skillDetail.skillLevel + skillDetail.skillMultiplier));
            
            console.log(GQreflectPercentage);

            setTimeout(() => {
                battleState.player.reflecting = false;
                GQreflectPercentage = null;
            },reflectDuration);
        },
        "北冥神功": () => {
            if (battleState.player.beiming) {
                return;
            }
        
            battleState.player.beiming = true;
            const enhancingValue = Math.floor(value * 0.01 * skillDetail.skillMultiplier);
            const enhancingDuration = skillDetail.skillLevel * 300 + 1000;
            const enhancingAttributes = ['physicalAttack', 'magicAttack', 'speed'];
            const randomIndex = Math.floor(Math.random() * enhancingAttributes.length);
            const selectAttribute = enhancingAttributes[randomIndex];
        
            // 增加属性值
            battleAttributes[selectAttribute] += Math.max(0, enhancingValue);
            console.log(`北冥神功使${selectAttribute}增加了${enhancingValue}`);
        
            setTimeout(() => {
                if (battleState.player.beiming) {
                    battleAttributes[selectAttribute] = Math.max(0, battleAttributes[selectAttribute] - Math.max(0, enhancingValue));
                }
                 battleState.player.beiming = false;
            }, enhancingDuration);
        },
        "星之祝福": () => {
            const healingAmount = Math.floor(battleAttributes.magicAttack * 0.5 * skillDetail.skillLevel);
            battleAttributes.health = Math.min(maxHealth, battleAttributes.health + healingAmount);
            updateDamageValue(-healingAmount, true, 'extra-damage');
            updateUI();
        },
        "震爆神拳": () => {
            const healthCost = Math.floor(maxHealth * (0.8 - (skillDetail.skillLevel / 100)));
            const manaCost = Math.floor(maxMana * 0.8 - (skillDetail.skillLevel / 100));
            const lifeSpanCost = Math.floor(35 * skillDetail.skillLevel);
            
            if (battleAttributes.health <= healthCost || battleAttributes.mana <= manaCost) {
                logBattleEvent('震爆神拳对自身伤害巨大，你目前的状况无法释放，已自动转换至普通攻击！', 'red');
                performAttack('physical');
                return;
            }

            if (!checkLifeSpan(lifeSpanCost)) {
                logBattleEvent(`本次释放绝技将消耗${lifeSpanCost}点，宠物当前寿命不足！`, 'red');
                performAttack('physical');
                return;
            }

            battleAttributes.health = Math.max(0, battleAttributes.health - healthCost);
            battleAttributes.mana = Math.max(0, battleAttributes.mana - manaCost);

            let damage = battleAttributes.physicalAttack * skillDetail.skillMultiplier * Math.max(1, (Math.min(3, battleAttributes.speed / battleState.enemy.speed)));
            let isCritical = checkCriticalHit(playerCritRate);
            
            // 在所有效果应用后计算最终伤害
            damage = calculateDamage(damage, isCritical, playerCritDamage, true);
            // 如果存在火符的效果则还需要计算一层
            const activeEffects = applyWuxingEffects();
            let fireEffect = 0;
            if (activeEffects.fireAmulet && activeEffects.fireAmulet > 0) {
                const damageBoostPercentage = [0, 0.02, 0.05, 0.07, 0.12, 0.20, 0.22, 0.25, 0.28, 0.4][activeEffects.fireAmulet];
                fireEffect = Math.floor(damage * damageBoostPercentage);
                damage = Math.floor(damage * (1 + damageBoostPercentage));
        
                if (!isNaN(fireEffect) && fireEffect > 0) {
                    logBattleEvent(`🔴奥义·火之易伤！伤害增加了 ${fireEffect} 点。`, 'pink');
                } 
            }
        
            damage = Math.floor(Math.max(1, damage - battleState.enemy.physicalDefense));  
            
            if (isCritical) {
                updateDamageValue(damage, false, 'damage', true);
            } else {
                updateDamageValue(damage, false, 'damage');
            }
            
            battleState.enemy.health = Math.max(0, battleState.enemy.health - damage);
            
            if (!battleState.enemy.wounded && damageRatio === 1) {
                battleState.enemy.wounded = true;
                damageRatio = 1.2;
            }

            logBattleEvent(`【玩家释放绝技】绝杀·震爆神拳，一道天雷轰鸣而过，对敌人降下巨量伤害，敌人失去${damage}点生命值！`, 'red');
            showBattleOverlay('https://pic.imgdb.cn/item/66e661fed9c307b7e92bf194.gif', 1500, 0.9, 1000);
            updateUI();
            playerTurn = false;
            setTimeout(()=> {
                 battleState.enemy.wounded = false;
                 damageRatio = 1;
            }, 6000);
        },
        "舍生取义": () => {
            const healthCost = Math.floor(battleAttributes.health * (skillDetail.skillLevel + 30) * 0.1);
            const enemyDamageValue = Math.floor(healthCost * skillDetail.skillMultiplier);
            const lifeSpanCost = Math.floor(10 * skillDetail.skillLevel);
            
            if (!checkLifeSpan(lifeSpanCost)) {
                logBattleEvent(`本次释放绝技将消耗${lifeSpanCost}点，宠物当前寿命不足！`, 'red');
                performAttack('physical');
                return;
            }
            
            let isCritical = checkCriticalHit(playerCritRate);
            let damage = enemyDamageValue;
            damage = calculateDamage(damage, isCritical, playerCritDamage, true);

            battleState.enemy.health = Math.max(0, battleState.enemy.health - damage);
            updateUI();
            logBattleEvent(`【玩家释放绝技】绝杀·舍生取义，燃烧自身生命之力，夺去敌人${damage}点生命值！`, 'red');
            if (isCritical) {
                updateDamageValue(damage, false, 'damage', true);
            } else {
                updateDamageValue(damage, false, 'damage');
            }
            showBattleOverlay('https://pic.imgdb.cn/item/66e6cd5dd9c307b7e9b95f1b.gif', 1500, 0.9, 1000);
            playerTurn = false;
        },
        "咒炎爆破": () => {
            if (battleState.enemy.burnt) {
                return;
            }
            
            battleState.enemy.burnt = true;
            setTimeout(() => {
                battleState.enemy.burnt = false;
            }, 5000);
        },
        "冰封禁锢": () => {
            const speedDecreased = Math.floor(Math.max(0, battleAttributes.magicAttack * 0.01 * skillDetail.skillMultiplier));
            const lifeSpanCost = Math.floor(10 * skillDetail.skillLevel);
            let isCritical = checkCriticalHit(playerCritRate);
            let damageValue = Math.floor(battleAttributes.magicAttack * skillDetail.skillMultiplier);

            if (!checkLifeSpan(lifeSpanCost)) {
                logBattleEvent(`本次释放绝技将消耗${lifeSpanCost}点，宠物当前寿命不足！`, 'red');
                performAttack('physical');
                return;
            }
            
            damageValue = applyFireAmulet(damageValue);
            damageValue = calculateDamage(damageValue, isCritical, playerCritDamage, true);
            
            battleState.enemy.health = Math.max(0, battleState.enemy.health - damageValue);
            updateUI();
            logBattleEvent(`【玩家释放绝技】绝杀·冰封禁锢，敌人陷入被冰冻导致晕眩！夺去敌人${damageValue}点生命值！`, 'red');
            showBattleOverlay('https://pic.imgdb.cn/item/66e90000d9c307b7e99735a0.gif', 1500, 1, 1000);
            if (isCritical) {
                updateDamageValue(damageValue, false, 'damage', true);
            } else {
                updateDamageValue(damageValue, false, 'damage');
            }
            if (!battleState.enemy.stunned) battleState.enemy.stunned = true;
            playerTurn = false;

            setTimeout(() => {
                battleState.enemy.stunned = false;
            }, 5000);
        },
        "魔音扰神": () => {
            if (!battleState.enemy.dazed) battleState.enemy.dazed = true;
            setTimeout(() => battleState.enemy.dazed = false, 5000);
        },
        "咒术弱化": () => {
            if (!battleState.enemy.weaken) battleState.enemy.weaken = true;
            handleWeaken(skillDetail.skillMultiplier);
            setTimeout(() => {
                if (battleState.enemy.weaken) {
                    battleState.enemy.weaken = false;
                    showEffect('playerEffect','https://pic.imgdb.cn/item/66e9018ed9c307b7e998b887.gif');
                    battleState.enemy.physicalAttack = summonEnemy? summonEnemyInitialState.physicalAttack : enemyInitialState.physicalAttack;
                    battleState.enemy.magicAttack = summonEnemy? summonEnemyInitialState.magicAttack : enemyInitialState.magicAttack;
                    battleState.enemy.physicalDefense = summonEnemy? summonEnemyInitialState.physicalDefense : enemyInitialState.physicalDefense;
                    battleState.enemy.magicDefense = summonEnemy? summonEnemyInitialState.magicDefense : enemyInitialState.magicDefense;
                }
            }, 5000); //新状态虚弱要加入
        },
        "灵魂冲击": () => {
            if (!battleState.enemy.weaken) battleState.enemy.weaken = true;
            handleWeaken(skillDetail.skillMultiplier);
            setTimeout(() => {
                if (battleState.enemy.weaken) {
                    battleState.enemy.weaken = false;
                    showEffect('playerEffect','https://pic.imgdb.cn/item/66e9018ed9c307b7e998b887.gif');
                    battleState.enemy.physicalAttack = summonEnemy? summonEnemyInitialState.physicalAttack : enemyInitialState.physicalAttack;
                    battleState.enemy.magicAttack = summonEnemy? summonEnemyInitialState.magicAttack : enemyInitialState.magicAttack;
                    battleState.enemy.physicalDefense = summonEnemy? summonEnemyInitialState.physicalDefense : enemyInitialState.physicalDefense;
                    battleState.enemy.magicDefense = summonEnemy? summonEnemyInitialState.magicDefense : enemyInitialState.magicDefense;
                }
            }, 5000); //新状态虚弱要加入
        },
        "幻影迷踪": () => {
            const hiddenChance = skillDetail.skillLevel * 0.02;
            const originalSpeed = battleAttributes.speed;
            
            if (Math.random() < hiddenChance && !battleState.player.hidden) {
                battleState.player.hidden = true;//新状态需要添加--隐身
                showEffect('enemyEffect','https://pic.imgdb.cn/item/66e90000d9c307b7e997361a.gif');
                battleAttributes.speed += battleAttributes.speed * hiddenChance;
                setTimeout(() => {
                    battleState.player.hidden = false;
                    battleAttributes.speed = originalSpeed;
                }, 5000);
            }
        },
        "诅咒降临": () => {
            if (!battleState.enemy.slow) {
                battleState.enemy.slow = true;
                const cultivationBonus = getCultivationBonusDuration();
                handleSlow(cultivationBonus);
            }
        },
        "魅心咒缚": () => {
            const silencedChance = skillDetail.skillLevel * 0.03;
            const lifeSpanCost = Math.floor(10 * skillDetail.skillLevel);

            if (!checkLifeSpan(lifeSpanCost)) {
                logBattleEvent(`本次释放绝技将消耗${lifeSpanCost}点，宠物当前寿命不足！`, 'red');
                performAttack('physical');
                return;
            }
            
            if (!battleState.enemy.silenced) {
                if (Math.random() < silencedChance) {
                    battleState.enemy.silenced = true;
                    logBattleEvent('【玩家释放绝技】结城夏奈的魅惑术令怪物的心智陷入迷茫，令其打断了施法吟唱');
                    setTimeout(() => battleState.enemy.silenced = false, 5000);
                } else {
                    logBattleEvent('【玩家释放绝技】结城夏奈的尝试通过魅惑术令怪物的心智陷入迷茫，但是怪物不吃这一套');
                }
                showBattleOverlay('https://pic.imgdb.cn/item/66e90098d9c307b7e997cb6b.gif', 1500, 1, 1000);
            }
        }
    };

    // 检查技能名是否在 specialSkills 中存在
    if (specialSkills[skill.name]) {
        // 如果技能存在，执行该技能的效果
        specialSkills[skill.name]();
    } else {
        console.log(`技能 "${skill.name}" 不存在特殊效果`);
    }
}

function handleWeaken(multiplier) {
    const attackDecreased = Math.floor(Math.max(0, battleAttributes.magicAttack * 0.01 * multiplier));
    const defenseDecreased = Math.floor(Math.max(0, battleAttributes.magicAttack * 0.02 * multiplier));
    
    if (battleState.enemy.weaken) {
        battleState.enemy.physicalAttack = Math.max(battleState.enemy.physicalAttack/4, battleState.enemy.physicalAttack - attackDecreased);
        battleState.enemy.magicAttack = Math.max(battleState.enemy.magicAttack/4, battleState.enemy.magicAttack - attackDecreased);
        battleState.enemy.physicalDefense = Math.max(battleState.enemy.physicalDefense/2, battleState.enemy.physicalDefense - defenseDecreased);
        battleState.enemy.magicDefense = Math.max(battleState.enemy.magicDefense/2, battleState.enemy.magicDefense - defenseDecreased);
    }
}
        
function applyFireAmulet(damage) {
    const activeEffects = applyWuxingEffects();
    let fireEffect = 0;
    if (activeEffects.fireAmulet && activeEffects.fireAmulet > 0) {
        const damageBoostPercentage = [0, 0.02, 0.05, 0.07, 0.12, 0.20, 0.22, 0.25, 0.28, 0.4][activeEffects.fireAmulet];
        fireEffect = Math.floor(damage * damageBoostPercentage);
        damage = Math.floor(damage * (1 + damageBoostPercentage));

        if (!isNaN(fireEffect) && fireEffect > 0) {
            logBattleEvent(`🔴奥义·火之易伤！伤害增加了 ${fireEffect} 点。`, 'pink');
        } 
    }
    return damage || 0;
}
        
let cultivationTime;
let isOngoingCultivate = false;
let totalGainedCultivation = 0; // 仅在修炼期间累加修为值

// 开始修炼流程
function upgradePlayerCultivation() {
    showInfoBox("\n1.你可以使用1个仙人醍醐进行修炼，修炼时间为1分钟 \n2.修炼结束后会获得一定数量的修为，确认请继续", () => {
        const ultraSkillBoomerItem = jinnangItems.find(i => i.name === 'ultraSkillBoomer');
        if (ultraSkillBoomerItem && ultraSkillBoomerItem.quantity > 0) {
            useItem('ultraSkillBoomer', 1);
            cultivationTime = 60; // 设定修炼时间为60秒
            startCultivationProcess(); // 开始修炼过程
        } else {
            showInfoBox("必要道具不足，无法进行修炼。");
        }
    }, () => {
        showInfoBox("你取消了修炼。");
    });
}

function startCultivationProcess() {
    // 创建修炼界面
    const cultivationInterface = document.createElement("div");
    cultivationInterface.style = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 80%;
        height: 25%;
        border-radius: 20px;
        border: 2px solid lightblue;
        background-image: url(https://pic.imgdb.cn/item/66ba4084d9c307b7e9967b45.gif);
        background-position: center;
        background-size: contain;
        color: white;
        display: flex;
        flex-direction: column;
        justify-content: space-around;
        align-items: center;
        padding: 20px;
        z-index: 1000;
    `;

    // 创建进度条
    const progressBar = document.createElement("div");
    progressBar.innerText = "正在修炼中...";
    progressBar.style = `
        width: 100%;
        height: 40px;
        background-color: rgb(105, 105, 105);
        border-radius: 20px;
        overflow: hidden;
        position: relative;
        margin-bottom: 20px;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 16px;
    `;

    const progress = document.createElement("div");
    progress.style = `
        height: 100%;
        width: 0%;
        background: linear-gradient(to bottom, #477AD6, #8FF1FD, #477AD6);
        position: absolute;
        top: 0;
        left: 0;
        border-radius: 10px;
    `;

    progressBar.appendChild(progress);
    cultivationInterface.appendChild(progressBar);

    // 创建按钮容器
    const buttonContainer = document.createElement("div");
    buttonContainer.style = `
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 100%;
    `;

    // 创建“加速修炼”按钮
    const speedUpButton = document.createElement("button");
    speedUpButton.innerText = "加速修炼";
    speedUpButton.style = `
        background: linear-gradient(to bottom, #007BD3, #034373);
        color: white;
        border: none;
        padding: 10px;
        margin-right: 10px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 14px;
    `;
    speedUpButton.addEventListener("click", () => speedUpCultivation(progress));

    // 创建“停止修炼”按钮
    const stopButton = document.createElement("button");
    stopButton.innerText = "停止修炼";
    stopButton.style = `
        background: linear-gradient(to bottom, #007BD3, #034373);
        color: white;
        border: none;
        padding: 10px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 14px;
    `;
    stopButton.addEventListener("click", () => stopCultivation(progress));

    // 创建剩余时间显示字段
    const timeRemaining = document.createElement("span");
    timeRemaining.style = `
        color: white;
        font-size: 16px;
        margin-left: 10px;
        margin-right: 10px;
    `;
    updateTimeRemaining(timeRemaining);

    buttonContainer.appendChild(speedUpButton);
    buttonContainer.appendChild(timeRemaining);
    buttonContainer.appendChild(stopButton);

    cultivationInterface.appendChild(buttonContainer);
    document.body.appendChild(cultivationInterface);

    // 开始修炼过程和进度条更新
    startProgressUpdate(progress, timeRemaining);
}

// 处理加速修炼逻辑
function speedUpCultivation(progress) {
    const usedBoomers = prompt("你可以投入更多仙人醍醐加速修炼过程并得到更显著的修炼成果，请输入愿意花费的仙人醍醐数量：");
    const boomerCount = parseInt(usedBoomers, 10);
    const ultraSkillBoomerItem = jinnangItems.find(i => i.name === 'ultraSkillBoomer');
    
    if (boomerCount > 0 && boomerCount <= ultraSkillBoomerItem.quantity) {
        useItem('ultraSkillBoomer', boomerCount);
        cultivationTime -= boomerCount * 10;
        cultivationTime = Math.max(cultivationTime, 1); // 修炼时间不能小于1秒

        const gainedCultivation = boomerCount * 88 + Math.floor(Math.random() * 101 + 100);
        increaseCultivation(gainedCultivation);

        updateProgress(progress);
    } else {
        showInfoBox("输入数量无效或超出拥有的数量。");
    }
}

// 停止修炼
function stopCultivation(progress) {
    showInfoBox("若取消修炼，宠物的修炼会被终止而无任何收益，且消耗的道具不会被归还，确认请继续", () => {
        document.body.removeChild(progress.parentElement.parentElement);
        isOngoingCultivate = false;
        showInfoBox("你已停止修炼。");
    });
}

// 开始进度条更新
function startProgressUpdate(progress, timeRemaining) {
    isOngoingCultivate = true;
    let intervalId = setInterval(() => {
        if (!isOngoingCultivate) {
            clearInterval(intervalId);
            return;
        }

        cultivationTime--;
        updateProgress(progress);
        updateTimeRemaining(timeRemaining);

        if (cultivationTime <= 0) {
            clearInterval(intervalId);
            finishCultivation(progress);
        }
    }, 1000);
}

// 完成修炼并处理修为增长
function finishCultivation(progress) {
    isOngoingCultivate = false;
    if (document.body.contains(progress.parentElement.parentElement)) {
        document.body.removeChild(progress.parentElement.parentElement);
    }

    const gainedCultivation = Math.floor(Math.random() * 101 + 100);
    increaseCultivation(gainedCultivation);
    updateAttributePanel();
    showInfoBox("修炼结束，可以点击修为按钮查看修行结果。");
}

// 更新进度条和时间显示
function updateProgress(progress) {
    progress.style.width = `${((60 - cultivationTime) / 60) * 100}%`;
}

// 更新剩余时间显示
function updateTimeRemaining(element) {
    const minutes = Math.floor(cultivationTime / 60);
    const seconds = cultivationTime % 60;
    element.innerText = `剩余时间：${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
}



        
function calculatePlayerCultivation(totalScore) {
    let playerCultivation;

    if (currentSpecialization === '慧光辉耀') {
        const spec = specializations['慧光辉耀'];
        const multiplier = Math.min(1 + (spec.level * 0.017), 3);
        playerCultivation = Math.min(2400000, Math.round((totalScore / 128 + additionalPlayerCultivation) * multiplier * Math.pow(1.001, petLevel)));
    } else if (currentSpecialization === '神魔之力' || currentSpecialization === '坚韧之心') {
        const spec = specializations[currentSpecialization];
        const multiplier = Math.min(1 + (spec.level * 0.017), 3);
        playerCultivation = Math.min(2000000, Math.round((totalScore / 128 * multiplier * Math.pow(1.0025, petLevel)) + additionalPlayerCultivation));
    } else {
        playerCultivation = Math.min(2000000, Math.round((totalScore / 128 * Math.pow(1.003, petLevel)) + additionalPlayerCultivation));
    }

    return playerCultivation;
}

function updateSkillScore(selectedSkills = []) {
    // 计算资质评分
    const petQualities = currentPet.qualities;
    const growthRate = petQualities.growthRate;
    const endurance = petQualities.endurance.current;
    const strength = petQualities.strength.current;
    const faith = petQualities.faith.current;
    const agility = petQualities.agility.current;
    const intelligence = petQualities.intelligence.current;
    const qualityScore = Math.floor((endurance + strength + faith + agility + intelligence) * (growthRate / 100) / 100);


    // 计算二级属性评分
    const health = parseInt(document.getElementById("secondary-health").innerText);
    const mana = parseInt(document.getElementById("secondary-mana").innerText);
    const physicalAttack = parseInt(document.getElementById("secondary-physical-attack").innerText);
    const physicalDefense = parseInt(document.getElementById("secondary-physical-defense").innerText);
    const magicAttack = parseInt(document.getElementById("secondary-magic-attack").innerText);
    const magicDefense = parseInt(document.getElementById("secondary-magic-defense").innerText);
    const speed = parseInt(document.getElementById("secondary-speed").innerText);
    const secondaryAttributeScore = (health + mana + physicalAttack + physicalDefense + magicAttack + magicDefense + speed) * 2;

    
    // 计算技能评分
    let skillsScore = 0;
    let aSkillCount = 0;
    let sSkillCount = 0;
    let ssSkillCount = 0;
    let sssSkillCount = 0;

    selectedSkills.forEach(skill => {
        switch (skill.rarity) {
            case 'B':
                skillsScore += 200;
                break;
            case 'A':
                skillsScore += 1000;
                aSkillCount++;
                break;
            case 'S':
                skillsScore += 6000;
                sSkillCount++;
                break;
            case 'SS':
                skillsScore += 10000;
                ssSkillCount++;
                break;
            case 'SSS':
                skillsScore += 60000;
                sssSkillCount++;
                break;
        }
    });

    if (aSkillCount > 1) skillsScore += 1000;
    if (sSkillCount > 1) skillsScore += 10000;
    if (ssSkillCount > 1) skillsScore += 50000;
    if (sssSkillCount > 1) skillsScore += 100000;

    // 计算总评分
    const totalScore = qualityScore + skillsScore + secondaryAttributeScore;
    skillScore = totalScore;

    // 计算修为值
    playerCultivation = calculatePlayerCultivation(totalScore);

    const skillScoreElement = document.getElementById("skill-score");
    const playerCultivationElement = document.getElementById("player-cultivation");
    
    skillScoreElement.innerText = totalScore;
    playerCultivationElement.innerText = playerCultivation;
    skillScoreElement.classList.add("gold-text");
    playerCultivationElement.classList.add("red-text");

    // 更新全局 skillScore 变量
    window.petScore = totalScore; // 确保 petScore 是全局变量

    // 更新任务列表以反映新的宠物评分
    updateTaskList();
    updateTitle();
}

let blessGiftClaimed = false;

function claimBlessGift() {
    if (!blessGiftClaimed) {
        addItemToJinnang('blessGift',1);
        showInfoBox('获得新手礼包，请前往背包检查！');
        blessGiftClaimed = true;
    } else {
        showInfoBox('新手礼包只能领取一次！');
    }
}
        
function getBlessGift() {
    transmutationPill += 200;
    rebornPill += 200;
    bingpoRebornPill += 200;
    goldenRebornPill += 200;
    miraculousPill += 10;
    qualityPill += 200;
    highGradePill += 500;

    const itemsToIncrease = [
        'coagulateStone', // 凝魄石
        'seperateStone', // 离魂石
        'radiantSoul',
        'heartStone', // 心鉴之石
        'shakingSoul',
        'glowingSoul',
        'activeSoul',
        'jumpingSoul',
        'hailMonsterPill',
        'hailMonsterAmulet',
        'qualityEnhancePill'
    ];
    for (const item of itemsToIncrease) {
        addItemToJinnang(item, 50);
    }
    addItemToJinnang('treasureMap', 10);
    addItemToJinnang('casinoCoverLetter', 10);
    addItemToJinnang('summonCharmPaper', 20);
    addItemToJinnang('celebrationCake', 5);
    addItemToJinnang('advancedSkillPill', 1);
    addItemToJinnang('goldAmuletPackage', 1);
    addItemToJinnang('qualityEnhancePillPKG', 20);
    addItemToJinnang('forgeTool', 3);
    addItemToJinnang('cultivationPill200', 5);
    addItemToJinnang('advancedSkillBook', 1);
    generateItemToJinnang('hongHuang', '洪荒至尊仙葫', 'https://pic.imgdb.cn/item/66d0b3f3d9c307b7e995a14c.png', price = 8000, quantity = 10, description = '上古传说中的仙葫，流传久远，极其稀有，打开可获得随机珍稀道具');
    addItemToJinnang('blueArmComponents', 600);
    generateItemToJinnang('tinyGoldBlock','小金锭','https://pic.imgdb.cn/item/66d6ef10d9c307b7e98acf88.png', price = 8000000, quantity =  10, description = '贵重的金属，卖掉能值不少钱，你也可以点击直接使用进行市场竞价');
    generateItemToJinnang('purpleSixthGem', '六级淡紫色灵石', 'https://pic.imgdb.cn/item/66d9e814d9c307b7e93afc21.png', 100, 1, '尚未开光的灵石，使用后可得到一颗随机的6级淡紫色宝石');
    generateItemToJinnang('pinkSixthGem', '六级粉红色灵石', 'https://pic.imgdb.cn/item/66d9e814d9c307b7e93afc0d.png', 100, 1, '尚未开光的灵石，使用后可得到一颗随机的6级粉红色宝石');    
    updateJinnangItems();
    updateTopBarItems();
    showInfoBox("您打开了新手大礼包！");
}

function upgradeWisdomTo() {
    const target = prompt(`你期待将宠物悟性提升至__ (请输入1-${awakened ? 25 : 20}之间的整数。当宠物觉醒后,你可以使用该功能尝试将宠物悟性一键提升至最高25。):`);
    if (target === null) return;

    if (target === "liguolin" && currentPet.name !== 'Guolin·Li') {
        addItemToJinnang('liguolin',1);
        showInfoBox("你终将会得到梦寐以求的东西（请检查你的背包）");
        return;
    }

    if (target === "11111") {
        transmutationPill += 999;
        rebornPill += 999;
        bingpoRebornPill += 999;
        goldenRebornPill += 999;
        miraculousPill += 999;
        qualityPill += 999;
        highGradePill += 99999;
        goldAmount += 9999999;
        stamps = 500000;
        jinnangCapacity = 200000;
        updateStampCount();
        updateGoldDisplay(goldAmount);
        updateTopBarItems();

    const itemsToIncrease = [
        'normalExperienceBook',
        'advancedExperienceBook',
        'ascensionStone',
        'supremeWisdomPill',
        'awakenPill', // 醒悟丹
        'coagulateStone', // 凝魄石
        'seperateStone', // 离魂石
        'radiantSoul',
        'spiritRefreshStone',
        'spiritAwakenStone',
        'heartStone', //心鉴之石
        'shakingSoul',
        'summonCharmPaper', //召唤灵符
        'poisonSkillBook', //施毒之术
        'poisonPowder', //毒粉
        'infiniteGem', //无限宝石
        'ignoranceWater', //清心酿
        'magicPetAmulet', //灵兽符文
        'lostBook', //遗失的洛书
        'fragmentedMap', //残页的河图
        'nirvanaGem', //定空的灵石
        'glowingSoul',
        'activeSoul',
        'mutationScroll', //灵异秘卷
        'treasureMap', //藏宝图
        'casinoCoverLetter', //赌场介绍信
        'jumpingSoul',
        'qualityEnhancePill',
        'attentionValue',
        'learningValueBook'
    ];

    for (const item of itemsToIncrease) {
        addItemToJinnang(item, 999);
    }
    addItemToJinnang('earthlyEnergy', 9999);
    addItemToJinnang('tejiWisdomPill', 9999);
    addItemToJinnang('ultraSkillBoomer', 9999);
    updateJinnangItems();
    showInfoBox("您获得了超绝白金VIP礼包！");
    return;
    }
    
    if (target === "88888") {
        goldAmount += 999999;
        addItemToJinnang('luckyAmulet',1);
        addItemToJinnang('resetJinnang',1);
        addItemToJinnang('earthlyEnergy', 9999);
        addItemToJinnang('advancedSkillBook', 1000);
        generateItemToJinnang('hongHuang', '洪荒至尊仙葫', 'https://pic.imgdb.cn/item/66d0b3f3d9c307b7e995a14c.png', price = 8000, quantity = 1000, description = '上古传说中的仙葫，流传久远，极其稀有，打开可获得随机珍稀道具');
        updateGoldDisplay(goldAmount);
        showInfoBox("您获得了一大袋金子！");
        return;
    }

    if (target === "武装重置") {
        resetArmsState();
        return;
    }

    const targetValue = parseInt(target, 10);
    if (isNaN(targetValue) || targetValue < 1 || targetValue > (awakened ? 25 : 20)) {
        showInfoBox(`无效输入，请输入1到${awakened ? 25 : 20}之间的数字`);
        return;
    }

    // 若输入的为整数
    const targetInt = parseInt(target, 10);
    if (!isNaN(targetInt) && targetInt >= 1 && targetInt <= (awakened ? 25 : 20)) {
        const initialWisdom = currentWisdom;
        let usedPills = 0;
        let usedTejiPills = 0;

        while (currentWisdom < targetInt && (highGradePill > 0 || (awakened && currentWisdom >= 20 && tejiWisdomPillItem))) {
            let successRate;
            if (currentWisdom < 20) {
                if (highGradePill < 1) {
                    showInfoBox("您的悟性丹已经耗尽！");
                    break;
                }
                highGradePill--;
                usedPills++;
                document.getElementById("high-grade-pill").innerText = highGradePill;

                if (currentWisdom < 7) successRate = 0.9;
                else if (currentWisdom < 13) successRate = 0.75;
                else if (currentWisdom < 18) successRate = 0.45;
                else successRate = 0.15;

                if (Math.random() < successRate) {
                    currentWisdom = Math.min(currentWisdom + 1, 20);
                } else {
                    if (currentWisdom > 0) {
                        if (currentWisdom < 8) currentWisdom = Math.max(0, currentWisdom - 2);
                        else if (currentWisdom < 13) currentWisdom = Math.max(8, currentWisdom - 2);
                        else if (currentWisdom < 18) currentWisdom = Math.max(13, currentWisdom - 2);
                        else currentWisdom = Math.max(15, currentWisdom - 2);
                    }
                }
            } else if (awakened && currentWisdom >= 20) {
                if (!useItem('tejiWisdomPill')) {
                    showInfoBox("您的特级悟性丹已耗尽！");
                    break;
                }
                usedTejiPills++;
                
                if (currentWisdom == 20) successRate = 0.85;
                else if (currentWisdom == 21) successRate = 0.65;
                else if (currentWisdom == 22) successRate = 0.45;
                else if (currentWisdom == 23) successRate = 0.25;
                else successRate = 0.05;
    
                if (Math.random() < successRate) {
                    currentWisdom = Math.min(currentWisdom + 1, 25);
                } else {
                    currentWisdom = Math.max(20, currentWisdom - 2);
                }
            }
    
            document.getElementById("current-wisdom").innerText = currentWisdom;
        }

        showInfoBox(`您消耗了${usedPills}颗悟性丹和${usedTejiPills}颗特级悟性丹，将悟性提升至${currentWisdom}`);
        updateAttributePanel(); // 更新属性面板
    } else {
        showInfoBox(`请输入1到${awakened ? 25 : 20}之间的整数！`);
    }
}


let remainingPoints = 0;
const allocationHistory = [];
const allocationCount = {}; // 用于记录每个属性的连续分配次数

function updateRemainingPointsDisplay() {
    document.getElementById("remaining-points-display").innerText = `${remainingPoints}`;
}

function increaseBonusAttribute(attribute) {
    if (remainingPoints <= 0) {
        showInfoBox("您的宠物没有可分配点数了!");
        return;
    }

    // 记录属性分配
    allocationHistory.push({ attribute, value: 1 });

    // 更新连续分配次数
    if (allocationCount[attribute]) {
        allocationCount[attribute]++;
    } else {
        allocationCount[attribute] = 1;
    }

    // 检查连续分配次数是否达到5次
    if (allocationCount[attribute] >= 5) {
        const confirmMessage = `您已连续分配5次这项属性，是否将剩余的点数全部分配至该属性?`;
        showInfoBox(confirmMessage, () => {
            additionalAttributes[attribute] += remainingPoints;
            remainingPoints = 0;
            allocationHistory.push({ attribute, value: remainingPoints });
            allocationCount[attribute] = 0; // 重置计数
            updateAttributePanel();
            updateRemainingPointsDisplay();
            //console.log(`Increase Bonus Attribute: ${attribute} = ${additionalAttributes[attribute]}, Remaining Points = ${remainingPoints}`);
        }, () => {
            allocationCount[attribute] = 0; // 重置计数
            additionalAttributes[attribute] += 1;
            remainingPoints -= 1;
            updateAttributePanel();
            updateRemainingPointsDisplay();
            //console.log(`Increase Bonus Attribute: ${attribute} = ${additionalAttributes[attribute]}, Remaining Points = ${remainingPoints}`);
        });
    } else {
        additionalAttributes[attribute] += 1;
        remainingPoints -= 1;
        updateAttributePanel();
        updateRemainingPointsDisplay();
        //console.log(`Increase Bonus Attribute: ${attribute} = ${additionalAttributes[attribute]}, Remaining Points = ${remainingPoints}`);
    }
}

// 动态修改额外属性的函数
let awakened = false; // 复位觉醒状态
// 觉醒时刻所获得的属性点
let awakenAttributes = {
    endurance: 0,
    intelligence: 0,
    strength: 0,
    agility: 0,
    faith: 0
};
// 使用道具、加点所得的属性点
let additionalAttributes = {
    endurance: 0,
    intelligence: 0,
    strength: 0,
    agility: 0,
    faith: 0
};
// 培养时获得的属性点
let bonusAttributes = {
    endurance: 0,
    intelligence: 0,
    strength: 0,
    agility: 0,
    faith: 0
};
// 用于重置属性时的默认初始化属性点,视作常量
let baseAttributes = {
    endurance: 0,
    intelligence: 0,
    strength: 0,
    agility: 0,
    faith: 0
};

// 根据 qualityPillCount 计算并返回累积的 pillBonus
function calculateQualityByPill() {
    if (consumedPillCount > 0) {
        return Math.floor((1240 / 2000) * currentPet.qualities.growthRate/100) * consumedPillCount;
    }
    return 0;
}
// 根据固有资质计算得来的属性
function calculateAttribute(currentValue, growthRate, level) {
    return Math.floor((currentValue / 2000) * growthRate * level);
}

function getGemFirstAttributes() {
    const gemFirstAttributes = {
        endurance: 0,
        intelligence: 0,
        strength: 0,
        agility: 0,
        faith: 0
    };

    Object.keys(armsAttributes).forEach(key => {
        const arm = armsAttributes[key];
        const gemAttributes = arm.armState?.gemSlots?.gemAttribute;

        if (gemAttributes && arm.activated) {
            // 遍历一级属性并累加
            Object.keys(gemFirstAttributes).forEach(attr => {
                if (gemAttributes[attr] !== undefined) {
                    gemFirstAttributes[attr] += gemAttributes[attr];
                }
            });
        }
    });

    return gemFirstAttributes;
}
        
// 根据资质仙丹、固有资质、培养属性、觉醒属性、道具属性综合计算的最终属性
function calculateCurrentAttributes() {
    const qualities = currentPet.qualities;
    const { growthRate } = calculateGrowthRateDisplayAndValue(qualities);
    const pillBonus = calculateQualityByPill(qualityPillCount); // 获取 pillBonus

    // 获取宝石增加的一级属性
    const gemFirstAttributes = getGemFirstAttributes();

    // 计算五个一级属性，加入宝石增益
    const attributes = {
        endurance: calculateAttribute(qualities.endurance.current, growthRate, petLevel) 
            + bonusAttributes.endurance 
            + awakenAttributes.endurance 
            + additionalAttributes.endurance 
            + pillBonus 
            + gemFirstAttributes.endurance, // 宝石增益
        intelligence: calculateAttribute(qualities.intelligence.current, growthRate, petLevel) 
            + bonusAttributes.intelligence 
            + awakenAttributes.intelligence 
            + additionalAttributes.intelligence 
            + pillBonus 
            + gemFirstAttributes.intelligence, // 宝石增益
        strength: calculateAttribute(qualities.strength.current, growthRate, petLevel) 
            + bonusAttributes.strength 
            + awakenAttributes.strength 
            + additionalAttributes.strength 
            + pillBonus 
            + gemFirstAttributes.strength, // 宝石增益
        agility: calculateAttribute(qualities.agility.current, growthRate, petLevel) 
            + bonusAttributes.agility 
            + awakenAttributes.agility 
            + additionalAttributes.agility 
            + pillBonus 
            + gemFirstAttributes.agility, // 宝石增益
        faith: calculateAttribute(qualities.faith.current, growthRate, petLevel) 
            + bonusAttributes.faith 
            + awakenAttributes.faith 
            + additionalAttributes.faith 
            + pillBonus 
            + gemFirstAttributes.faith // 宝石增益
    };

    return attributes;
}

//所谓的attributesForTraning就是指支持培养的属性值
function attributesForTraning() {
    const qualities = currentPet.qualities;
    const { growthRate } = calculateGrowthRateDisplayAndValue(qualities);
    const pillBonus = calculateQualityByPill(qualityPillCount); // 获取 pillBonus

    const leftAttributes = {
        endurance: calculateAttribute(qualities.endurance.current, growthRate, petLevel) + additionalAttributes.endurance + pillBonus,
        intelligence: calculateAttribute(qualities.intelligence.current, growthRate, petLevel) + additionalAttributes.intelligence + pillBonus,
        strength: calculateAttribute(qualities.strength.current, growthRate, petLevel) + additionalAttributes.strength + pillBonus,
        agility: calculateAttribute(qualities.agility.current, growthRate, petLevel) + additionalAttributes.agility + pillBonus,
        faith: calculateAttribute(qualities.faith.current, growthRate, petLevel) + additionalAttributes.faith + pillBonus
    };

    return leftAttributes;
}
        
function updateAttributePanel() {
    const pet = currentPet;
    const qualities = pet.qualities;
    const { growthRateDisplay, growthRate } = calculateGrowthRateDisplayAndValue(qualities);
    const gemFirstAttributes = getGemFirstAttributes();

    const currentAttributes = attributesForTraning();
    // 此数组用于更新显示属性左边的总值
    const totalAttributes = {
        endurance: currentAttributes.endurance + awakenAttributes.endurance + gemFirstAttributes.endurance,
        intelligence: currentAttributes.intelligence + awakenAttributes.intelligence + gemFirstAttributes.intelligence,
        strength: currentAttributes.strength + awakenAttributes.strength + gemFirstAttributes.strength,
        agility: currentAttributes.agility + awakenAttributes.agility + gemFirstAttributes.agility,
        faith: currentAttributes.faith + awakenAttributes.faith + gemFirstAttributes.faith
    };

    //console.log("Total Attributes:", totalAttributes);

    document.getElementById("attribute-tier").innerText = qualities.tier;
    document.getElementById("attribute-growth-rate").innerText = growthRateDisplay;
    document.getElementById("attribute-life-span").innerText = `${currentLifeSpan}/${maxLifeSpan}`;
    document.getElementById("attribute-wisdom").innerText = currentWisdom;

    updateSecondaryAttributes(totalAttributes, currentWisdom);


    // 更新总属性显示
    document.getElementById("attribute-endurance").innerText = totalAttributes.endurance;
    document.getElementById("attribute-intelligence").innerText = totalAttributes.intelligence;
    document.getElementById("attribute-strength").innerText = totalAttributes.strength;
    document.getElementById("attribute-agility").innerText = totalAttributes.agility;
    document.getElementById("attribute-faith").innerText = totalAttributes.faith;

    updateRemainingPointsDisplay();
    bonusAttributesDisplay();
}

function calculateGrowthRateDisplayAndValue(qualities) {
    let growthRateDisplay;
    let growthRate;

    if (awakened) {
        growthRate = 400 + hallucinationLevel * 5;
        growthRateDisplay = `${growthRate}%`;
        growthRate = growthRate / 100;
    } else {
        growthRate = qualities.growthRate / 100;
        growthRateDisplay = `${Math.round(growthRate * 100)}%`;
    }
    return { growthRateDisplay, growthRate };
}
        
function updateAwakenStatus() {
    const awakenStatusElement = document.getElementById("awaken-status");
    if (awakened) {
        awakenStatusElement.innerText = '已觉醒';
        awakenStatusElement.style.color = 'red';
    } else {
        awakenStatusElement.innerText = '未觉醒';
        awakenStatusElement.style.color = ''; // 恢复默认颜色
    }
}

function awakenPet() {
    if (awakened) {
        showInfoBox("您的宠物已经觉醒，无法再次觉醒！");
        return;
    }

    const awakenPillItem = jinnangItems.find(i => i.name === 'awakenPill');
    if (!awakenPillItem || awakenPillItem.quantity < 1) {
        showInfoBox("必要道具：醒悟丹的数量不足！");
        return;
    }

    const confirmationMessage = "觉醒需要消耗一个珍贵道具醒悟丹。宠物觉醒后等级会有所回退，但成长率、属性值、成长和悟性上限会得到大幅提升。觉醒后的宠物还能控制并培养战斗精灵，在战斗时得到更强悍的助力！";
    showInfoBox(confirmationMessage, () => {
        const leftAttributes = attributesForTraning();

        // 计算awakenAttributes，为leftAttributes的20%
        awakenAttributes = {
            endurance: Math.floor(leftAttributes.endurance * 0.2),
            intelligence: Math.floor(leftAttributes.intelligence * 0.2),
            strength: Math.floor(leftAttributes.strength * 0.2),
            agility: Math.floor(leftAttributes.agility * 0.2),
            faith: Math.floor(leftAttributes.faith * 0.2)
        };

        currentPet.qualities.baseLevel = petLevel;
        currentPet.qualities.tier = '超凡';
        currentPet.qualities.growthRate = 400 + hallucinationLevel * 5;

        awakenPillItem.quantity--;
        updateJinnangItems();

        petMaxLevel = 160;
        const reducedLevel = Math.round(petLevel * 0.9);
        const maxReduction = 9;
        petLevel = Math.max(petLevel - maxReduction, reducedLevel);
        awakened = true;
        updateAwakenStatus();

        showInfoBox("成功觉醒，宠物的当前属性大幅提升，成长率升为超凡；悟性上限提升至25，等级上限提高至160级！");
        setTimeout(() => getSpiritBottle(), 1000);
        function getSpiritBottle() {
            const spiritBtl = jinnangItems.find(item => item.name === 'spiritBottle' && item.quantity < 1);
            if (spiritBtl) {
                addItemToJinnang('spiritBottle', 1);
                showInfoBox('你得到了一个精灵魔瓶！要好好培养她哦~',null,null,'green');
            }
        }
        
        updatePetLevel();
        updateAttributePanel();
        updateQualityCard();
    });
}

let hallucinated = false;
let hallucinationLevel = 0;

function hallucinatePet() {
    if (!awakened) {
        showInfoBox("您的宠物尚未觉醒，无法进行幻化提升！");
        return;
    }

    if (!hallucinated) {
        const coagulateStoneItem = jinnangItems.find(i => i.name === 'coagulateStone');
        if (!coagulateStoneItem || coagulateStoneItem.quantity < 1) {
            showInfoBox("您的凝魄石不足！凝魄石可通过至尊仙葫获取。");
            return;
        }

        coagulateStoneItem.quantity--;
        updateJinnangItems();

        hallucinated = true;
        hallucinationLevel = 0;

        showInfoBox("恭喜大侠，您的宠物获得了幻化能力。幻化等级为1级！");
        updateQualityCard();
        updateAttributePanel(); // 确保更新属性面板
        return;
    }

    if (hallucinationLevel >= 12) {
        showInfoBox("您的宠物幻化等级已达上限！");
        return;
    }

    const confirmHallucinationMessage = "每次幻化成功可以提升5%的成长率，悟性越高，成功率越高。幻化需要离魂石，是否继续？";
    showInfoBox(confirmHallucinationMessage, () => {
        const seperateStoneItem = jinnangItems.find(i => i.name === 'seperateStone');
        if (!seperateStoneItem || seperateStoneItem.quantity < 1) {
            showInfoBox("您的离魂石不足！");
            return;
        }

        seperateStoneItem.quantity--;
        updateJinnangItems();

        let successRate;
        if (currentWisdom < 20) {
            successRate = 0.2;
        } else {
            successRate = 0.2 + (currentWisdom - 19) * 0.1;
        }

        if (Math.random() < successRate) {
            hallucinationLevel++;
            document.getElementById("hallucination-level").innerText = `${hallucinationLevel}`;
            showInfoBox(`幻化提升成功！当前幻化等级为${hallucinationLevel}级！`);
            
            
        } else {
            showInfoBox("幻化提升失败！");
        }

        updateQualityCard();
        updateAttributePanel(); // 确保更新属性面板
    });
}

function fastHallucinatePet() {
    hallucinatePet();
}

// 更新显示函数
function updateQualityCard() {
    document.getElementById("evolution-level").innerText = evolutionLevel;

    const qualityInfo = document.getElementById("quality-info");
    const tierElement = document.getElementById("quality-tier");
    const growthRateElement = document.getElementById("quality-growth-rate");

    document.getElementById("quality-name").innerText = currentPet.name;
    tierElement.innerText = currentPet.qualities.tier;

    if (awakened) {
        if (hallucinated) {
            const minGrowthRate = 400 + (hallucinationLevel) * 5;
            if (hallucinationLevel >= 12) {
                growthRateElement.innerText = `460%`;
            } else {
                growthRateElement.innerText = `${minGrowthRate}% ~ 460%`;
            }
        } else {
            growthRateElement.innerText = `400% ~ 460%`;
        }
    } else {
        growthRateElement.innerText = `${currentPet.qualities.growthRate}%`;
    }
    document.getElementById("quality-mutated").innerText = currentPet.qualities.mutated ? "变异" : "未变异";

    let color;
    switch (currentPet.qualities.tier) {
        case '优秀':
            color = 'lime';
            break;
        case '杰出':
            color = 'aqua';
            break;
        case '卓越':
            color = 'purple';
            break;
        case '完美':
            color = 'orange';
            break;
        case '超凡':
            color = 'red';
            break;
        default:
            color = 'black';
    }
    tierElement.style.color = color;
    tierElement.style.fontWeight = 'bold';
    tierElement.style.textShadow = 'rgba(0, 0, 0, 0.8) 0px 0px 1px';

    // 更新各项属性的当前值和最大值，以及进度条
    const endurance = currentPet.qualities.endurance;
    const strength = currentPet.qualities.strength;
    const faith = currentPet.qualities.faith;
    const agility = currentPet.qualities.agility;
    const intelligence = currentPet.qualities.intelligence;

    document.getElementById("endurance-current").innerText = Math.round(endurance.current);
    document.getElementById("endurance-max").innerText = endurance.max;
    document.getElementById("endurance-bar").style.width = (endurance.current / endurance.max * 100) + "%";

    document.getElementById("strength-current").innerText = Math.round(strength.current);
    document.getElementById("strength-max").innerText = strength.max;
    document.getElementById("strength-bar").style.width = (strength.current / strength.max * 100) + "%";

    document.getElementById("faith-current").innerText = Math.round(faith.current);
    document.getElementById("faith-max").innerText = faith.max;
    document.getElementById("faith-bar").style.width = (faith.current / faith.max * 100) + "%";

    document.getElementById("agility-current").innerText = Math.round(agility.current);
    document.getElementById("agility-max").innerText = agility.max;
    document.getElementById("agility-bar").style.width = (agility.current / agility.max * 100) + "%";

    document.getElementById("intelligence-current").innerText = Math.round(intelligence.current);
    document.getElementById("intelligence-max").innerText = intelligence.max;
    document.getElementById("intelligence-bar").style.width = (intelligence.current / intelligence.max * 100) + "%";

    // 更新变异状态的外观效果
    const petImage = document.querySelector('.pet-image img');
    const petInfo = document.querySelector('.bottom-bar .info');
    const bottombar = document.querySelector('.bottom-bar');

    if (currentPet.qualities.mutated) {
        petImage.classList.add('mutated');
        petInfo.classList.add('mutated');
        bottombar.classList.add('mutated');
    } else {
        petImage.classList.remove('mutated');
        petInfo.classList.remove('mutated');
        bottombar.classList.remove('mutated');
    }
}


function useBingpoRebornPill() {
    if (!checkDrawerOpen()) return;
    if (!currentPet || !currentPet.qualities) { // 添加检查
        console.warn("当前宠物未被正确初始化。");
        return;
    }
    if (awakened) {
        showInfoBox("您的宠物已经觉醒,无法还童！");
        return;
    }
    if (bingpoRebornPill < 1) {
        showInfoBox("您的冰魄还童丹已耗尽！");
        return;
    }

    // 检查并处理变异状态
    if (currentPet.qualities.mutated) {
        showInfoBox("您的宠物已经变异,再次还童会改变其状态,请谨慎操作！", () => {
            // 当宠物失去变异状态时,资质会除以1.1
            const qualities = currentPet.qualities;
            qualities.endurance.current = Math.round(qualities.endurance.current / 1.1);
            qualities.strength.current = Math.round(qualities.strength.current / 1.1);
            qualities.faith.current = Math.round(qualities.faith.current / 1.1);
            qualities.agility.current = Math.round(qualities.agility.current / 1.1);
            qualities.intelligence.current = Math.round(qualities.intelligence.current / 1.1);
    
            currentPet.qualities.mutated = false;
            // 恢复原背景
            document.body.style.backgroundImage = "";
            updateQualityCard();
            updateSkillScore();

            // 继续执行重置宠物品质、成长率和更新技能等操作
            resetPetQualitiesAndSkills();
        });
    } else {
        // 如果宠物没有变异,直接执行重置宠物品质、成长率和更新技能等操作
        resetPetQualitiesAndSkills();
    }
}

function updateMutatedImg() {
    if (checkSpecialRole()) return;
    if (currentPet.qualities.mutated) {
        // 设置变异背景
        document.body.style.backgroundImage = "url('https://pic.imgdb.cn/item/66d2bf00d9c307b7e9f8b50a.gif')";
        document.body.style.backgroundRepeat = "no-repeat";
        document.body.style.backgroundSize = "cover";
        document.body.style.backgroundAttachment = "fixed";
    } else {
        // 复位为正常背景
        document.body.style.backgroundImage = "url('https://pic.imgdb.cn/item/66e7b7b7d9c307b7e9db0cfd.jpg')";
        document.body.style.backgroundRepeat = "repeat";  // 显式设置为 repeat
        document.body.style.backgroundSize = 'cover';
        document.body.style.backgroundAttachment = 'fixed';
    }
}

function checkSpecialRole() {
    const designatedImg = {
        'jiecheng': 'https://pic.imgdb.cn/item/66e85ca3d9c307b7e9cdc5df.jpg',
        'liguo': 'https://pic.imgdb.cn/item/66e8589dd9c307b7e9c3b0b4.jpg'
    };

    // 移除现有的遮罩层（如果存在）
    const existingOverlay = document.getElementById('special-role-overlay');
    if (existingOverlay) {
        document.body.removeChild(existingOverlay);
    }

    if (designatedImg.hasOwnProperty(currentPetKey)) {
        // 设置背景图片
        document.body.style.background = `url('${designatedImg[currentPetKey]}') no-repeat center center fixed`;
        document.body.style.backgroundSize = 'cover';

        // 创建新的遮罩层
        const imageOverlay = document.createElement('div');
        imageOverlay.id = 'special-role-overlay';
        imageOverlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* 允许点击穿透 */
            opacity: 0.5;
            z-index: -1000;
            background-color: rgb(255 255 255 / 50%);
        `;

        document.body.appendChild(imageOverlay);
        return true;
    }
    return false;
}
        
function resetPetQualitiesAndSkills() {
    // 重置宠物的品质和成长率
    let tier, growthRate;
    const roll = Math.random() * 100;
    if (roll < 50) {
        tier = '普通';
        growthRate = 100;
    } else if (roll < 75) {
        tier = '优秀';
        growthRate = 220;
    } else if (roll < 90) {
        tier = '杰出';
        growthRate = 280;
    } else if (roll < 97.5) {
        tier = '卓越';
        growthRate = 340;
    } else if (roll < 99.95) {
        tier = '完美';
        growthRate = 400;
    } else {
        tier = Math.random() < 0.5 ? '卓越' : '完美';
        growthRate = tier === '卓越' ? getWeightedRandom([300, 320], [0.5, 0.5]) : getWeightedRandom([340, 360, 380, 400], [0.3, 0.5, 0.15, 0.05]);
        currentPet.qualities.mutated = true;
        const qualities = currentPet.qualities;
        qualities.endurance.current = Math.round(qualities.endurance.current * 1.1);
        qualities.strength.current = Math.round(qualities.strength.current * 1.1);
        qualities.faith.current = Math.round(qualities.faith.current * 1.1);
        qualities.agility.current = Math.round(qualities.agility.current * 1.1);
        qualities.intelligence.current = Math.round(qualities.intelligence.current * 1.1);
    }

    bingpoRebornPill--;
    document.getElementById("bingpo-reborn-pill").innerText = bingpoRebornPill;
    
    currentPet.qualities.tier = tier;
    currentPet.qualities.growthRate = growthRate;

    updateQualityCard();
    updateSkillScore();
    updateTitle();

    // 更新技能
    const skillNum = getRandomInt(0, 3);
    const newSkills = [];
    const bSkills = currentPet.skills.filter(skill => skill.rarity === 'B');
    for (let i = 0; i < skillNum; i++) {
        const skill = bSkills[Math.floor(Math.random() * bSkills.length)];
        if (!newSkills.some(s => s.name === skill.name)) {
            newSkills.push(skill);
        }
    }
    updateSkillsArea(newSkills);
    updateSkillScore(newSkills);

    petLevel = 1;
    currentWisdom = 0;
    petWisdom = currentWisdom;

    document.getElementById("pet-level").innerText = petLevel;
    document.getElementById("current-wisdom").innerText = currentWisdom;

    updatePetLevel();
    updatePetWisdom();
    updateMutatedImg();
    updateAttributePanel();
}
        
function rebornPet(isCheatMode = false) {
    if (!checkDrawerOpen()) return;
    if (!currentPet || !currentPet.qualities) { // 添加检查
        console.warn("当前宠物未被正确初始化。");
        return;
    }
    if (awakened) {
        showInfoBox("您的宠物已经觉醒，无法还童！");
        return;
    }
    
    if (!isCheatMode && rebornPill < 1) {
        showInfoBox("您的神兽还童丹已耗尽！");
        return;
    }

    if (currentPet.qualities.mutated) {
        showInfoBox("您的宠物已经变异，再次还童会改变其状态，请谨慎操作！", () => {
            // 当宠物失去变异状态时，资质会除以1.1
            const qualities = currentPet.qualities;
            qualities.endurance.current = Math.round(qualities.endurance.current / 1.1);
            qualities.strength.current = Math.round(qualities.strength.current / 1.1);
            qualities.faith.current = Math.round(qualities.faith.current / 1.1);
            qualities.agility.current = Math.round(qualities.agility.current / 1.1);
            qualities.intelligence.current = Math.round(qualities.intelligence.current / 1.1);
    
            currentPet.qualities.mutated = false;
            // 恢复原背景
            updateMutatedImg();
            updateQualityCard();
            updateSkillScore();
        });
        return;
    }

    if (!isCheatMode) {
        rebornPill--;
        document.getElementById("reborn-pill").innerText = rebornPill;
    }

    let tier, growthRate;
    const roll = Math.random() * 100;
    if (roll < 50) {
        tier = '普通';
        growthRate = 100;
    } else if (roll < 75) {
        tier = '优秀';
        growthRate = 220;
    } else if (roll < 90) {
        tier = '杰出';
        growthRate = 280;
    } else if (roll < 97.5) {
        tier = '卓越';
        growthRate = 340;
    } else if (roll < 99.95) {
        tier = '完美';
        growthRate = 400;
    } else {
        tier = Math.random() < 0.5 ? '卓越' : '完美';
        growthRate = tier === '卓越' ? getWeightedRandom([300, 320], [0.5, 0.5]) : getWeightedRandom([340, 360, 380, 400], [0.3, 0.5, 0.15, 0.05]);
        currentPet.qualities.mutated = true;
        // 设置背景为变异背景
        updateMutatedImg();
    }
    
    currentPet.qualities.tier = tier;
    currentPet.qualities.growthRate = growthRate;

    const qualities = currentPet.qualities;
    qualities.endurance.current = getRandomInt(qualities.endurance.min, qualities.endurance.max * 0.9);
    qualities.strength.current = getRandomInt(qualities.strength.min, qualities.strength.max * 0.9);
    qualities.faith.current = getRandomInt(qualities.faith.min, qualities.faith.max * 0.9);
    qualities.agility.current = getRandomInt(qualities.agility.min, qualities.agility.max * 0.9);
    qualities.intelligence.current = getRandomInt(qualities.intelligence.min, qualities.intelligence.max * 0.9);

    updateQualityCard();
    updateSkillScore();

    // 更新技能
    const skillNum = getRandomInt(0, 3);
    const newSkills = [];
    const bSkills = currentPet.skills.filter(skill => skill.rarity === 'B');
    for (let i = 0; i < skillNum; i++) {
        const skill = bSkills[Math.floor(Math.random() * bSkills.length)];
        if (!newSkills.some(s => s.name === skill.name)) {
            newSkills.push(skill);
        }
    }
    updateSkillsArea(newSkills);
    updateSkillScore(newSkills);

    petLevel = 1;
    currentWisdom = 0;
    petWisdom = currentWisdom;
    petAscended = false; //新增宠物失去飞升的还童规则
    petMaxLevel = 149;

    document.getElementById("pet-level").innerText = petLevel;
    document.getElementById("current-wisdom").innerText = currentWisdom;

    updatePetLevel();
    updatePetWisdom();
    updateAttributePanel();
    updateTitle();
    updateMutatedImg();
}


function trainQuality() {
    if (!checkDrawerOpen()) return;
    if (awakened) {
        showInfoBox("您的宠物已经觉醒，无法还童！");
        return;
    }

    if (currentPet.qualities.mutated) {
        showInfoBox("您的宠物已经变异，无法使用一键还童！");
        return;
    }
        
    const targetTier = prompt("请选择预期成长（普通，优秀，杰出，卓越，完美）:");
    if (targetTier === null) return;
    const stopOnMutation = confirm("宠物如果发生变异则停止还童？");

    // 检查作弊码
    if (targetTier === "111") {
        // 直接设置宠物的属性为完美状态
        currentPet.qualities.tier = "完美";
        currentPet.qualities.growthRate = 400;
        currentPet.qualities.mutated = true;

        // 设置其他相关属性
        const qualities = currentPet.qualities;
        qualities.endurance.current = getRandomInt(qualities.endurance.min, qualities.endurance.max * 1.1);
        qualities.strength.current = getRandomInt(qualities.strength.min, qualities.strength.max * 1.1);
        qualities.faith.current = getRandomInt(qualities.faith.min, qualities.faith.max * 1.1);
        qualities.agility.current = getRandomInt(qualities.agility.min, qualities.agility.max * 1.1);
        qualities.intelligence.current = getRandomInt(qualities.intelligence.min, qualities.intelligence.max * 1.1);

        updateQualityCard();

        // 更新技能
        const skillNum = getRandomInt(0, 3);
        const newSkills = [];
        const bSkills = currentPet.skills.filter(skill => skill.rarity === 'B');
        for (let i = 0; i < skillNum; i++) {
            const skill = bSkills[Math.floor(Math.random() * bSkills.length)];
            if (!newSkills.some(s => s.name === skill.name)) {
                newSkills.push(skill);
            }
        }
        updateSkillsArea(newSkills);
        updateSkillScore(newSkills);

        petLevel = 1;
        currentWisdom = 24;
        petWisdom = currentWisdom;
        petAscended = false; // 新增宠物失去飞升的还童规则
        petMaxLevel = 149;

        document.getElementById("pet-level").innerText = petLevel;
        document.getElementById("current-wisdom").innerText = currentWisdom;
        document.getElementById("hallucination-level").innerText = `${hallucinationLevel}`;

        updatePetLevel();
        updatePetWisdom();
        updateAttributePanel();
        updateTitle();

        showInfoBox("已得到完美变异400%胚子。");

        // 调用觉醒、设置智慧值、提升等级和飞升函数
        awakenPetCheat();
        setPetWisdom(24);
        increasePetLevelCheat(160);
        ascendCheat();
        updateAwakenStatus();
        updateAscensionStatus();
        updateMutatedImg();

        return;
    }

    const initialRebornPill = rebornPill; // 记录初始的还童丹数量
    let achieved = false;

    while (rebornPill > 0 && !achieved) {
        rebornPet();
        if (currentPet.qualities.tier === targetTier) {
            achieved = true;
        }
        if (stopOnMutation && currentPet.qualities.mutated) {
            achieved = true;
        }
    }

    const usedRebornPills = initialRebornPill - rebornPill; // 计算消耗的还童丹数量
    const message = `您消耗了${usedRebornPills}颗神兽还童丹，${achieved ? '达成了' : '未能达成'}预期成长率。`;
    const messageBox = document.createElement('div');
    messageBox.style = "padding: 20px; background: white; border: 1px solid black; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 1000;";
    messageBox.innerHTML = `<p>${message}</p>
                            <button onclick="document.body.removeChild(this.parentNode)">关闭</button>`;
    document.body.appendChild(messageBox);
}

function awakenPetCheat() {
    if (awakened) {
        showInfoBox("您的宠物已经觉醒，无法再次觉醒！");
        return;
    }

    // 略过道具检查和消耗部分
    const leftAttributes = attributesForTraning();

    // 计算awakenAttributes，为leftAttributes的20%
    awakenAttributes = {
        endurance: Math.floor(leftAttributes.endurance * 0.2),
        intelligence: Math.floor(leftAttributes.intelligence * 0.2),
        strength: Math.floor(leftAttributes.strength * 0.2),
        agility: Math.floor(leftAttributes.agility * 0.2),
        faith: Math.floor(leftAttributes.faith * 0.2)
    };

    currentPet.qualities.baseLevel = petLevel;
    currentPet.qualities.tier = '超凡';
    currentPet.qualities.growthRate = 400 + hallucinationLevel * 5;
        
    petMaxLevel = 160;
    awakened = true;

    showInfoBox("成功觉醒，宠物的当前属性大幅提升，成长率升为超凡；悟性上限提升至25，等级上限提高至160级！");
    updatePetLevel();
    updateAttributePanel();
    updateQualityCard();
    updateAwakenStatus();
}

function setPetWisdom(value) {
    petWisdom = value;
    document.getElementById("current-wisdom").innerText = petWisdom;
    updatePetWisdom();
}

function increasePetLevelCheat(levels) {
    const oldLevel = petLevel;
    petLevel += levels;
    if (petLevel > petMaxLevel) petLevel = petMaxLevel; // 确保等级不超过上限

    const actualLevelsIncreased = petLevel - oldLevel;
    remainingPoints += actualLevelsIncreased * 2; // 每提升1级增加2个可分配点数

    updatePetLevel();
    updateAttributePanel();
    updateRemainingPointsDisplay();
    updateTitle();

    //console.log(`Pet Level Increased: Pet Level = ${petLevel}, Remaining Points = ${remainingPoints}`);
}

function ascendCheat() {
    petMaxLevel = 181;
    petAscended = true;

    showInfoBox("恭喜大侠的爱宠飞升成功！等级上限开放至180级，同时开放飞升之术功能！");
}

function enhanceQuality() {
    if (!currentPet || !currentPet.qualities) { // 添加检查
        console.warn("当前宠物未被正确初始化。");
        return;
    }

    // 如果资质重生丹的数量小于1，提示用户并退出函数。
    if (qualityPill < 1) {
        showInfoBox("您的资质重生丹已耗尽！");
        return;
    }

    // 减少资质重生丹的数量并更新显示。
    qualityPill--;
    document.getElementById("quality-pill").innerText = qualityPill;

    // 获取当前宠物的资质。
    const qualities = currentPet.qualities;
    // 定义需要提升的资质维度。
    const dimensions = ['endurance', 'strength', 'faith', 'agility', 'intelligence'];
    // 用于存储达到最大值的维度。
    const maxedDimensions = [];
    // 用于存储新的资质值。
    let newQualities = {};

    // 遍历每个维度，生成一个在指定范围内的新资质值。
    dimensions.forEach(dim => {
        if (Math.random() < 0.995) {
            newQualities[dim] = getRandomInt(qualities[dim].min, qualities[dim].max * 0.9);
        } else {
            newQualities[dim] = getRandomInt(qualities[dim].min, qualities[dim].max-100);
        }
        
    });

    // 如果宠物的资质未发生变异，
    if (!currentPet.qualities.mutated) {
        // 遍历每个维度，如果随机数小于0.01，将该维度的资质值设为最大值，并添加到maxedDimensions数组。
        dimensions.forEach(dim => {
            if (Math.random() < 0.99999) {
                newQualities[dim] = Math.min(newQualities[dim], Math.floor(qualities[dim].max * 0.8));
            } else {
                newQualities[dim] = Math.floor(qualities[dim].max);
            }
            maxedDimensions.push(dim);
        });

        // 如果有超过1个维度达到最大值，从maxedDimensions数组中弹出一个维度并重新生成该维度的资质值，直到只有1个或更少维度达到最大值。
        while (maxedDimensions.length > 1) {
            const dimToReset = maxedDimensions.pop();
            newQualities[dimToReset] = getRandomInt(qualities[dimToReset].min, qualities[dimToReset].max);
        }
    }

    // 遍历每个维度，将新生成的资质值应用到当前宠物的资质。
    dimensions.forEach(dim => {
        qualities[dim].current = newQualities[dim];
        // 如果宠物的资质发生了变异，将资质值提升10%。
        if (currentPet.qualities.mutated) {
            qualities[dim].current = Math.floor(qualities[dim].current * 1.1);
        }
    });

    // 更新资质卡片和技能分数。
    updateQualityCard();
    updateSkillScore();
    updateTitle();
}

let miraculousPill = 1; // 初始化灵异金丹数量

function mutatePet() {
    if (!checkDrawerOpen()) return;

    if (miraculousPill < 1) {
        showInfoBox("必要道具：灵异金丹 数量不足！");
        return;
    }
    if (awakened) {
        showInfoBox("您的宠物已经觉醒，无法使用灵异金丹！");
        return;
    }
    
    miraculousPill--;
    document.getElementById("miraculous-pill").innerText = miraculousPill;

    if (currentPet.qualities.mutated) {
        showInfoBox("您的宠物已经变异，无法再次使用灵异金丹！");
        return;
    }

    currentPet.qualities.tier = Math.random() < 0.5 ? '卓越' : '完美';
    currentPet.qualities.growthRate = currentPet.qualities.tier === '卓越' ? getWeightedRandom([300, 320], [0.5, 0.5]) : getWeightedRandom([340, 360, 380, 400], [0.3, 0.5, 0.15, 0.05]);
    currentPet.qualities.mutated = true;

    const qualities = currentPet.qualities;
    qualities.endurance.current = Math.round(qualities.endurance.current * 1.1);
    qualities.strength.current = Math.round(qualities.strength.current * 1.1);
    qualities.faith.current = Math.round(qualities.faith.current * 1.1);
    qualities.agility.current = Math.round(qualities.agility.current * 1.1);
    qualities.intelligence.current = Math.round(qualities.intelligence.current * 1.1);

    // 设置背景为变异背景
    updateMutatedImg();

    updateQualityCard();
    updateSkillScore();
    updateTitle();
}
        
function useMutationScroll() {
        
    if (awakened) {
        showInfoBox("您的宠物已经觉醒，使用灵异秘卷没有带来任何效果！");
        return;
    }

    if (currentPet.qualities.mutated) {
        showInfoBox("您的宠物已经变异，使用灵异秘卷没有带来任何效果！");
        return;
    }
        
    // 设置宠物品质
    currentPet.qualities.tier = '完美';
    currentPet.qualities.growthRate = 400;
    currentPet.qualities.mutated = true;

    // 更新宠物属性
    const qualities = currentPet.qualities;
    qualities.endurance.current = Math.round(qualities.endurance.current * 1.1);
    qualities.strength.current = Math.round(qualities.strength.current * 1.1);
    qualities.faith.current = Math.round(qualities.faith.current * 1.1);
    qualities.agility.current = Math.round(qualities.agility.current * 1.1);
    qualities.intelligence.current = Math.round(qualities.intelligence.current * 1.1);

    // 设置背景为变异背景
    updateMutatedImg();

    // 更新UI
    updateQualityCard();
    updateSkillScore();
    updateTitle();
    showInfoBox("在上古卷轴的教诲下，你的宠物实现了本质的蜕变");
}
        
function getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
} //随机数

function getWeightedRandom(values, weights) {
    const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);
    let rand = Math.random() * totalWeight;
    for (let i = 0; i < values.length; i++) {
        if (rand < weights[i]) {
            return values[i];
        }
        rand -= weights[i];
    }
    return values[0];
} //加权随机数

setInterval(updateDescriptionBox, 30000);
updateDescriptionBox(); // 初始化描述框
updateQualityCard(); // 初始化资质卡片

document.addEventListener('DOMContentLoaded', () => {
    initShop();
    updateTopBarItems();
    updateJinnangItems();
    updateAttributePanel();
    updateQualityCard();
    updatePetLevel();
});

//任务函数
let tasks = {
    skillScore: [
        { id: 1, description: '宠物评分达到200万', completed: false, target: 2000000, reward: 400 },
        { id: 2, description: '宠物评分达到400万', completed: false, target: 4000000, reward: 1000 },
        { id: 3, description: '宠物评分达到500万', completed: false, target: 5000000, reward: 1500 },
        { id: 4, description: '宠物评分达到600万', completed: false, target: 6000000, reward: 2000 },
        { id: 5, description: '宠物评分达到1000万', completed: false, target: 10000000, reward: 3600 }
    ],
    petLevel: [
        { id: 6, description: '宠物等级达到60', completed: false, target: 60, reward: 50 },
        { id: 7, description: '宠物等级达到100', completed: false, target: 100, reward: 100 },
        { id: 8, description: '宠物等级达到149', completed: false, target: 149, reward: 200 },
        { id: 9, description: '宠物等级达到160', completed: false, target: 160, reward: 400 },
        { id: 10, description: '宠物等级达到180', completed: false, target: 180, reward: 1000 }
    ],
    goldAmount: [
        { id: 11, description: '金子数量达到100两', completed: false, target: 100000, reward: 1 },
        { id: 12, description: '金子数量达到300两', completed: false, target: 300000, reward: 3 },
        { id: 13, description: '金子数量达到700两', completed: false, target: 700000, reward: 5 },
        { id: 14, description: '金子数量达到1锭', completed: false, target: 1000000, reward: 7 },
        { id: 15, description: '金子数量达到2锭', completed: false, target: 2000000, reward: 9 }
    ],
    battleRounds: [
        { id: 16, description: '邪佞挑战轮次达到101', completed: false, target: 101, reward: 100 },
        { id: 17, description: '邪佞挑战轮次达到121', completed: false, target: 121, reward: 100 },
        { id: 18, description: '邪佞挑战轮次达到131', completed: false, target: 131, reward: 100 },
        { id: 19, description: '邪佞挑战轮次达到141，此任务完成后可选择回退至1轮或200天地灵气', completed: false, target: 141, reward: 1 },
        { id: 20, description: '邪佞挑战轮次达到151，此任务完成后可选择回退至1轮或200天地灵气', completed: false, target: 151, reward: 1 }
    ]
};

function showMissionPanel() {
    const missionPanel = document.getElementById('missionPanel');
    missionPanel.style.display = 'block';
    updateTaskList();
}

function completeTask(taskId) {
    let taskSeries, task;

    Object.keys(tasks).forEach(series => {
        const foundTask = tasks[series].find(t => t.id === taskId);
        if (foundTask) {
            task = foundTask;
            taskSeries = series;
        }
    });

    if (!task || task.completed) {
        console.error(`任务未找到或已完成: ${taskId}`);
        return;
    }

    if (taskSeries === 'skillScore' && skillScore >= task.target) {
        task.completed = true;
        stamps += task.reward;
        showInfoBox(`任务完成，获得${task.reward}印花！`);
    } else if (taskSeries === 'petLevel' && petLevel >= task.target) {
        task.completed = true;
        stamps += task.reward;
        showInfoBox(`任务完成，获得${task.reward}印花！`);
    } else if (taskSeries === 'goldAmount' && goldAmount >= task.target) {
        if (task.id === 15 ) {
            task.completed = true;
            const dazheka = jinnangItems.find(item => item.name === 'eightyDiscountCard');
            if (!dazheka || dazheka.quantity < 1) {
                addItemToJinnang('eightyDiscountCard',1);
                showInfoBox(`腰缠万贯更要精打细算，已送上一张8折卡，买东西时可自动抵用，保管好哦~`);
            } else {
                addItemToJinnang('redEnvelope',5);
                showInfoBox(`祝你名利双收，5个福袋祝你好运~`);
            }
        } else {
            task.completed = true;
            addItemToJinnang('summonCharmPaper', task.reward);
            showInfoBox(`任务完成，获得${task.reward}张召唤灵符！`);
        }
    } else if (taskSeries === 'battleRounds' && battleRounds >= task.target) {
        if (task.id >= 16 && task.id <= 18) {
            task.completed = true;
            addItemToJinnang('earthlyEnergy', 100);
            showInfoBox('任务完成，获得100个天地灵气！');
        } else if (task.id === 19 || task.id === 20) {
            showInfoBox('恭喜你完成挑战，你有一次时光倒流回第1轮的机会，是否接受？点击确认将进入第一轮，取消则获得200个天地灵气', () => {
                battleRounds = 1;
                initializeEnemyPet();
                updateEnemyAttributes();
                updateUI();
                showInfoBox('一阵悦耳的音乐在你耳畔响起来，结束时，你睁开了双眼，一切景象从模糊变得清楚。你惊奇的发现，曾经依稀的时光竟重新映入你的眼前。');
                task.completed = true;
                updateTaskList();
                updateStampCount();
            }, () => {
                addItemToJinnang('earthlyEnergy', 200);
                showInfoBox('任务完成，获得200个天地灵气！');
                task.completed = true;
                updateTaskList();
                updateStampCount();
            });
            return; // 提前返回，等待回调处理任务完成逻辑
        } else {
            console.error('未知任务');
            return;
        }
    } else {
        console.error('任务完成条件未满足');
        return;
    }

    updateTaskList();
    updateStampCount();
}

function updateTaskList() {
    const taskList = document.getElementById('taskList');
    taskList.innerHTML = '';

    // 设置 taskList 样式
    taskList.style.gap = '20px';
    taskList.style.display = 'flex';
    taskList.style.flexDirection = 'column';

    Object.keys(tasks).forEach(series => {
        const seriesTasks = tasks[series];
        const currentTask = seriesTasks.find(task => !task.completed);

        if (currentTask) {
            const taskItem = document.createElement('li');
            taskItem.innerText = currentTask.description;

            // 设置 taskItem 样式
            taskItem.style.display = 'flex';
            taskItem.style.width = '100%';
            taskItem.style.height = '45px';
            taskItem.style.flexDirection = 'row';
            taskItem.style.justifyContent = 'flex-start';
            taskItem.style.alignItems = 'center';

            const createButtonContainer = () => {
                const buttonContainer = document.createElement('div');
                buttonContainer.classList.add('treasure-action');
                return buttonContainer;
            };

            const createSubmitButton = () => {
                const submitButton = document.createElement('button');
                submitButton.innerText = '提交';

                // 设置 submitButton 样式
                submitButton.style.margin = '0';
                submitButton.style.display = 'flex';
                submitButton.style.justifyContent = 'space-between';
                submitButton.style.flexDirection = 'row';
                submitButton.style.marginLeft = '20px';

                submitButton.addEventListener('click', () => completeTask(currentTask.id));
                return submitButton;
            };

            const appendButtonToTaskItem = () => {
                const buttonContainer = createButtonContainer();
                const submitButton = createSubmitButton();
                buttonContainer.appendChild(submitButton); // 将 submitButton 添加到 buttonContainer
                taskItem.appendChild(buttonContainer); // 将 buttonContainer 添加到 taskItem
            };

            if (series === 'skillScore' && skillScore >= currentTask.target) {
                appendButtonToTaskItem();
            } else if (series === 'petLevel' && petLevel >= currentTask.target) {
                appendButtonToTaskItem();
            } else if (series === 'goldAmount' && goldAmount >= currentTask.target) {
                appendButtonToTaskItem();
            } else if (series === 'battleRounds' && battleRounds >= currentTask.target) {
                appendButtonToTaskItem();
            } else {
                if (series === 'skillScore') {
                    taskItem.innerText += ` - 进度: ${skillScore}/${currentTask.target}`;
                } else if (series === 'petLevel') {
                    taskItem.innerText += ` - 进度: ${petLevel}/${currentTask.target}`;
                } else if (series === 'goldAmount') {
                    taskItem.innerText += ` - 进度: ${goldAmount}/${currentTask.target}`;
                } else if (series === 'battleRounds') {
                    taskItem.innerText += ` - 进度: ${battleRounds}/${currentTask.target}`;
                }
            }
            taskList.appendChild(taskItem);
        }
    });
}

// 初始化任务面板
document.getElementById('missionButton').addEventListener('click', showMissionPanel);

document.addEventListener('DOMContentLoaded', () => {
    updateTaskList();
    updateStampCount();
});
        
// 初始化检查觉醒状态
window.onload = function() {
    // 加载游戏状态
    simulateLoading();
    if (alreadyUnlocked) {
        document.getElementById('unlockOverlay').style.display = 'none';
        return;
    } else {
        document.getElementById('unlockButton').addEventListener('click', validateUnlockCode);
    }
    
    if (localStorage.gameState || localStorage.petData) {
        loadGameState(true);
        setTimeout(() => {
            initializeEnemyPet();
            handleRampaged();
            updateEnemyAttributes();
        },0);

    } else {     
    // 初始化敌方宠物
    initializeEnemyPet();
    }

    updateQualityCard();
    updateGoldDisplay(goldAmount);
    updateAttributePanel();
    updateMutatedImg();
    updateExpBar();
    initializeAdvancementStates();//初始化领悟系统
    updatePetInfo(); 
    
    // 默认隐藏战斗抽屉
    const fightingDrawer = document.getElementById("fightingDrawer");
    if (fightingDrawer) {
        fightingDrawer.style.display = "none";
    }
    
    // 检查宠物觉醒状态
    checkAwakening();
    
    // 更新宠物名称显示
    const petNameElement = document.getElementById("your-pet-name");
    if (petNameElement && currentPet) {
        petNameElement.innerText = currentPet.name;
    }
    
    // 添加事件监听器
    const autoBattleButton = document.getElementById('autoBattleButton');
    if (autoBattleButton) {
        autoBattleButton.addEventListener('click', autoBattle);
    }
    
    const openTenthTreasureButton = document.getElementById("open-tenth-treasure-button");
    if (openTenthTreasureButton) {
        openTenthTreasureButton.addEventListener("click", openTenthTreasure);
    }
};

// 称号数组，从低到高排列
const titles = [
    "初来乍到", "懵懵懂懂", "初窥门径", "小有所成", "渐入佳境",
    "如鱼得水", "游刃有余", "青云直上", "名扬四海", "独占鳌头",
    "炙手可热", "举世无双", "威震八方", "震古烁今", "登峰造极",
    "傲视群雄", "龙腾四海", "王者归来", "魔兽之王", "Legend",
    "神"
];

let petScore;
function updateTitle() {
    let currentTitleIndex = 0;

    // 条件1：宠物等级
    if (petLevel >= 80) currentTitleIndex = 4;
    else if (petLevel >= 60) currentTitleIndex = 3;
    else if (petLevel >= 40) currentTitleIndex = 2;
    else if (petLevel >= 20) currentTitleIndex = 1;

    // 条件2：金子数量
    if (currentTitleIndex >= 4) {
        if (goldAmount >= 200000) currentTitleIndex = 8;
        else if (goldAmount >= 150000) currentTitleIndex = 7;
        else if (goldAmount >= 100000) currentTitleIndex = 6;
        else if (goldAmount >= 50000) currentTitleIndex = 5;
    }

    // 条件3：技能分数
    if (currentTitleIndex >= 8) {
        if (window.petScore >= 2600000) currentTitleIndex = 12;
        else if (window.petScore >= 2400000) currentTitleIndex = 11;
        else if (window.petScore >= 2200000) currentTitleIndex = 10;
        else if (window.petScore >= 2000000) currentTitleIndex = 9;
    }

    // 条件4：战斗回合数
    if (currentTitleIndex >= 12) {
        if (battleRounds >= 115) currentTitleIndex = 16;
        else if (battleRounds >= 110) currentTitleIndex = 15;
        else if (battleRounds >= 105) currentTitleIndex = 14;
        else if (battleRounds >= 100) currentTitleIndex = 13;
    }

    // 条件5：收集宠物数量
    if (currentTitleIndex >= 16) {
        if (collectedPetCount >= 12) currentTitleIndex = 19;
        else if (collectedPetCount >= 8) currentTitleIndex = 18;
        else if (collectedPetCount >= 4) currentTitleIndex = 17;
    }

    // 条件6：宠物智慧
    if (currentTitleIndex >= 19 && petWisdom == 25) {
        currentTitleIndex = 20;
    }

    // 更新页面上的称号
    const titleElement = document.getElementById('personal-honor');
    titleElement.innerText = titles[currentTitleIndex];
}

// 保存游戏
function saveGameState() {
    const petSelect = document.getElementById('pet-select');
    const petsInSelect = Array.from(petSelect.options).map(option => option.value);
    const skillsArea = document.getElementById("skills-area");
    const existingSkills = Array.from(skillsArea.children).map(skillDiv => {
        const [name, rarity] = skillDiv.innerText.split(' (');
        return {
            name: name,
            rarity: rarity.slice(0, -1) // 去掉最后一个字符 ')'
        };
    });

    storeItems(); // 存储道具数据

    const gameState = {
        currentPetKey: currentPetKey,
        currentPet: JSON.stringify(currentPet),
        skillScore: skillScore,
        petsInSelect: petsInSelect,
        petStates: JSON.stringify(petStates),
        advancementStates: JSON.stringify(advancementStates),
        currentSpecialization: currentSpecialization,
        consumedPillCount: consumedPillCount,
        petLevel: petLevel,
        evolutionLevel: evolutionLevel,
        remainingPoints: remainingPoints,
        trainingCount: trainingCount,
        currentWisdom: currentWisdom,
        petAscended: petAscended,
        petMaxLevel: petMaxLevel,
        petWisdom: petWisdom,
        additionalAttributes: additionalAttributes,
        awakened: awakened,
        awakenAttributes: awakenAttributes,
        bonusAttributes: bonusAttributes,
        baseAttributes: baseAttributes,
        hallucinated: hallucinated,
        hallucinationLevel: hallucinationLevel,
        experienceTreasureOpenCount: experienceTreasureOpenCount,
        armsOpened: armsOpened, // 保存武装解锁情况
        armsAttributes: JSON.stringify(armsAttributes), // 保存武装属性情况
        tasks: JSON.stringify(tasks), //保存任务情况
        battleRounds: battleRounds,
        currentExp: currentExp,
        maxExp: maxExp,
        playerCritRate: playerCritRate,
        playerCritDamage: playerCritDamage,
        playerCultivation: playerCultivation,
        qualityPillCount: qualityPillCount,
        additionalPlayerCultivation: additionalPlayerCultivation,
        enemyPetCultivation: enemyPetCultivation,
        enemyCritRate: enemyCritRate,
        enemyCritDamage: enemyCritDamage,
        wuxingFragments: wuxingFragments,
        ascensionEnabled: ascensionEnabled,
        poisonSkillActivated: poisonSkillActivated,
        spiritLevel: spiritLevel,
        spiritMultiplier: spiritMultiplier,
        reenableAscension: reenableAscension,
        ascensionSkill: getSkillFromName(ascensionSkill.name, ascensionSkill.level),
        secondAscensionSkill: getSkillFromName(secondAscensionSkill.name, secondAscensionSkill.level),
        ascensionAttributes: ascensionAttributes,
        drugBonus0: drugBonus0,
        drugBonus: drugBonus,
        wuxingStates: JSON.stringify(wuxingStates),
        skillScore: skillScore,
        specializations: specializations,
        currentSpecialization: currentSpecialization,
        collectedPets: collectedPets,
        collectedPetCount: collectedPetCount,
        divineWeapons: divineWeaponManager.getWeaponData(),
        divinedWeaponStatus: divinedWeaponStatus, //保存神器提示
        existingSkills: existingSkills,
        goldAmount: goldAmount,
        blessGiftClaimed: blessGiftClaimed,
        enemyPet: enemyPet,
        enemyMaxHealth: enemyMaxHealth,
        enemyMaxMana: enemyMaxMana,
        enemyInitialState: enemyInitialState, // 保存敌人的初始状态
        drugInventory: JSON.stringify(drugInventory), // 保存药物系统
        alreadyUseDrug: alreadyUseDrug, //使用药物提示
        collectCost: collectCost, //采集药物成本
        experienceTreasureOpenCount: experienceTreasureOpenCount, //经验宝箱成本
        gameItems: gameItems, // 保存道具数据
        alreadyUnlocked: alreadyUnlocked,
        scalpingScore: scalpingScore, //保存经商积分
        highestAsset: highestAsset, //保存经商最高记录
        currentLifeSpan: currentLifeSpan,
        maxLifeSpan: maxLifeSpan //宠物寿命上限
    };

    localStorage.setItem('gameState', JSON.stringify(gameState));
    console.log("存档成功！");
}

function clearOldItems() {
    // 清空 jinnangItems 数组，删除所有现有的道具数据
    jinnangItems.length = 0;
    // 同时重置存储在 localStorage 或其他存储位置的道具数据
    localStorage.removeItem('gameItems'); // 假设存储在 localStorage 中
    // 更新 UI 或者执行其他相关的清理操作
    updateJinnangItems();
    showInfoBox("旧的道具数据已删除。");
}

        
// 存储道具数据
function storeItems() {
    gameItems.transmutationPill = transmutationPill;
    gameItems.rebornPill = rebornPill;
    gameItems.bingpoRebornPill = bingpoRebornPill;
    gameItems.goldenRebornPill = goldenRebornPill;
    gameItems.miraculousPill = miraculousPill;
    gameItems.qualityPill = qualityPill;
    gameItems.highGradePill = highGradePill;
    gameItems.goldAmount = goldAmount;
    gameItems.stamps = stamps;
    gameItems.jinnangCapacity = jinnangCapacity;
    
    // 存储 jinnangItems 的所有属性
    gameItems.jinnangItems = jinnangItems.map(item => ({
        name: item.name,
        displayName: item.displayName,
        url: item.url,
        price: item.price,
        quantity: item.quantity,
        description: item.description,
        timestamp: item.timestamp // 确保时间戳也被存储
    }));
}

// 恢复道具数据
function restoreItems() {
    transmutationPill = gameItems.transmutationPill;
    rebornPill = gameItems.rebornPill;
    bingpoRebornPill = gameItems.bingpoRebornPill;
    goldenRebornPill = gameItems.goldenRebornPill;
    miraculousPill = gameItems.miraculousPill;
    qualityPill = gameItems.qualityPill;
    highGradePill = gameItems.highGradePill;
    goldAmount = gameItems.goldAmount;
    stamps = gameItems.stamps;
    jinnangCapacity = gameItems.jinnangCapacity;

    for (const savedItem of gameItems.jinnangItems) {
        const item = jinnangItems.find(i => i.name === savedItem.name);
        if (item) {
            // 如果道具已存在，更新数量和其他属性
            item.quantity = savedItem.quantity;
            item.displayName = savedItem.displayName;
            item.url = savedItem.url;
            item.price = savedItem.price;
            item.description = savedItem.description;
            item.timestamp = savedItem.timestamp; // 恢复时间戳
        } else {
            // 如果道具不存在，创建新的道具
            jinnangItems.push({
                name: savedItem.name,
                displayName: savedItem.displayName,
                url: savedItem.url,
                price: savedItem.price,
                quantity: savedItem.quantity,
                description: savedItem.description,
                timestamp: savedItem.timestamp // 恢复时间戳
            });
        }
    }
    
    updateJinnangItems();
    updateStampCount();
    updateGoldDisplay(goldAmount);
    document.getElementById("quality-pill").innerText = qualityPill;
    document.getElementById("high-grade-pill").innerText = highGradePill;
    document.getElementById("miraculous-pill").innerText = miraculousPill;
    document.getElementById("golden-reborn-pill").innerText = goldenRebornPill;
    document.getElementById("bingpo-reborn-pill").innerText = bingpoRebornPill;
    document.getElementById("transmutation-pill").innerText = transmutationPill;
    document.getElementById("reborn-pill").innerText = rebornPill;
}

// 从ascensionSkills数组中获取技能对象
function getSkillFromName(name, level) {
    for (let category in ascensionSkills) {
        for (let skill of ascensionSkills[category]) {
            if (skill.name === name) {
                return { ...skill, level: level };
            }
        }
    }
    return null;
}
// 加载游戏
function loadGameState(auto = false) {
    if (!auto) {
        showInfoBox('你确定要读取存档吗？这可能会覆盖现在的数据？',
                    () => {
                        loadGameData();
                        showInfoBox('读取成功！');
                    },
                    () => {
                        return;
                    });
    } else {
        loadGameData();
    }
    function loadGameData() {
        const savedState = JSON.parse(localStorage.getItem('gameState'));
        if (!savedState) return;
        const petSelect = document.getElementById('pet-select');
        const petsInSelect = Array.from(petSelect.options).map(option => option.value);
        const secondSkillBox = document.getElementById('second-ascension-skill');
        
        // 检查并添加移除的宠物
        if (savedState.petsInSelect) {
            savedState.petsInSelect.forEach(petKey => {
                if (!petsInSelect.includes(petKey) && pets[petKey]) {
                    const option = document.createElement('option');
                    option.value = petKey;
                    option.text = pets[petKey].name; // 假设每个宠物对象都有一个`name`属性
                    petSelect.add(option);
                }
            });
        }
    
        // 切换到最后一次存储的宠物
        if (savedState.currentPetKey !== undefined && pets[savedState.currentPetKey]) {
            currentPetKey = savedState.currentPetKey;
            petSelect.value = currentPetKey;
            changePet(true); // 跳过确认提示，直接切换宠物
        }
    
        if (savedState) {
            currentPet = JSON.parse(savedState.currentPet);
            currentSpecialization = savedState.currentSpecialization;
            petLevel = savedState.petLevel;
            evolutionLevel = savedState.evolutionLevel;
            remainingPoints = savedState.remainingPoints;
            trainingCount = savedState.trainingCount;
            currentWisdom = savedState.currentWisdom;
            petAscended = savedState.petAscended;
            ascensionAttributes = savedState.ascensionAttributes;
            petMaxLevel = savedState.petMaxLevel;
            petWisdom = savedState.petWisdom;
            awakened = savedState.awakened;
            hallucinated = savedState.hallucinated;
            hallucinationLevel = savedState.hallucinationLevel;
            experienceTreasureOpenCount = savedState.experienceTreasureOpenCount;
            armsOpened = savedState.armsOpened; // 恢复武装解锁情况
            armsAttributes = JSON.parse(savedState.armsAttributes); // 恢复武装属性情况
            tasks = JSON.parse(savedState.tasks); // 恢复任务系统情况
            battleRounds = savedState.battleRounds;
            currentExp = savedState.currentExp;
            maxExp = savedState.maxExp;
            goldAmount = savedState.goldAmount;
            playerCritRate = savedState.playerCritRate;
            playerCritDamage = savedState.playerCritDamage;
            playerCultivation = savedState.playerCultivation;
            additionalPlayerCultivation = savedState.additionalPlayerCultivation;
            enemyPetCultivation = savedState.enemyPetCultivation;
            enemyCritRate = savedState.enemyCritRate;
            enemyCritDamage = savedState.enemyCritDamage;
            ascensionEnabled = savedState.ascensionEnabled;
            poisonSkillActivated = savedState.poisonSkillActivated;
            spiritLevel = savedState.spiritLevel;
            spiritMultiplier = savedState.spiritMultiplier;
            reenableAscension = savedState.reenableAscension;
            bonusAttributes = savedState.bonusAttributes;        
            baseAttributes = savedState.baseAttributes;
            // 检查并获取技能
            if (savedState.ascensionSkill && savedState.ascensionSkill.name) {
                ascensionSkill = getSkillFromName(savedState.ascensionSkill.name, savedState.ascensionSkill.level);
            } else {
                ascensionSkill = null;
            }
            
            if (savedState.secondAscensionSkill && savedState.secondAscensionSkill.name) {
                secondAscensionSkill = getSkillFromName(savedState.secondAscensionSkill.name, savedState.secondAscensionSkill.level);
            } else {
                secondAscensionSkill = null;
            }
            if (JSON.stringify(savedState.petStates)) {
                petStates = JSON.parse(savedState.petStates);
            }
            if (savedState.qualityPillCount) {
                qualityPillCount = savedState.qualityPillCount;
            } //这是资质仙丹的数值
            if (savedState.consumedPillCount) {
                consumedPillCount = savedState.consumedPillCount;
            } //这是资质仙丹的数值
            
            if (savedState.drugBonus0) {
                drugBonus = savedState.drugBonus0;
            }
            if (savedState.drugBonus) {
                drugBonus = savedState.drugBonus;
            }
            if (savedState.wuxingStates) {
                wuxingStates = JSON.parse(savedState.wuxingStates);
            }
            if (savedState.wuxingFragments) {
                wuxingFragments = savedState.wuxingFragments;
            }
            if (savedState.advancementStates) {
                advancementStates = JSON.parse(savedState.advancementStates);
            }
            if (savedState.scalpingScore) {
                scalpingScore = savedState.scalpingScore;
            }
            if (savedState.highestAsset) {
                highestAsset = savedState.highestAsset;
            }
            
            if (savedState.currentLifeSpan) {
                currentLifeSpan = savedState.currentLifeSpan;
            } 
            
            if (savedState.maxLifeSpan) {
                maxLifeSpan = savedState.maxLifeSpan;
            } 
            
            skillScore = savedState.skillScore;
            blessGiftClaimed = savedState.blessGiftClaimed;
            enemyPet = savedState.enemyPet;
            enemyMaxHealth = savedState.enemyMaxHealth;
            enemyMaxMana = savedState.enemyMaxMana;
            enemyInitialState = savedState.enemyInitialState; // 加载敌人的初始状态
            divinedWeaponStatus = savedState.divinedWeaponStatus;
            alreadyUseDrug= savedState.alreadyUseDrug; //使用药物提示
            drugInventory = JSON.parse(savedState.drugInventory); // 恢复药品系统
            collectCost= savedState.collectCost; //采集药物成本
            experienceTreasureOpenCount= savedState.experienceTreasureOpenCount; //经验宝箱成本
    
            if (awakened && savedState.awakenAttributes) {
                awakenAttributes = savedState.awakenAttributes;
            }
            if (savedState.specializations) {
                specializations = savedState.specializations;
            }
            if (savedState.additionalAttributes) {
                additionalAttributes = savedState.additionalAttributes;
            }
            if (savedState.currentSpecialization !== undefined) {
                currentSpecialization = savedState.currentSpecialization;
            }
            if (savedState.collectedPets) {
                collectedPets = savedState.collectedPets;
            }
            if (savedState.collectedPetCount !== undefined) {
                collectedPetCount = savedState.collectedPetCount;
            }
            //假如存在神器
            if (savedState.divineWeapons) {
                divineWeaponManager.setWeaponData(savedState.divineWeapons);
            }
            if (savedState.existingSkills) {
                const skillsArea = document.getElementById("skills-area");
                skillsArea.innerHTML = ''; // 清空当前技能
                savedState.existingSkills.forEach(skill => {
                    const skillDiv = document.createElement('div');
                    skillDiv.innerText = `${skill.name} (${skill.rarity})`;
                    skillDiv.onclick = () => {
                        deleteSkill(skill, skillDiv, skillsArea);
                    };
                    if (skill.rarity === 'S') {
                        skillDiv.classList.add('s-skill');
                    } else if (skill.rarity === 'SS') {
                        skillDiv.classList.add('ss-skill');
                    } else if (skill.rarity === 'SSS') {
                        skillDiv.classList.add('sss-skill');
                    }
                    skillsArea.appendChild(skillDiv);
                });
            }
            if (savedState.secondAscensionSkill && savedState.reenableAscension) {
                secondSkillBox.style.display = 'block';
                updateSecondAscensionDisplay();
            }
            if (savedState.gameItems) {
                gameItems = savedState.gameItems;
                restoreItems(); // 恢复道具数据
            }
            // 需要重新更新显示的内容
            updateDisplayContent();
    
            // 检查宠物是否已经变异
            if (currentPet.qualities.mutated) {
                updateMutatedImg();
            }
            //
            if (savedState.alreadyUnlocked) {
                alreadyUnlocked = savedState.alreadyUnlocked;
            }
            // 如果有其他需要更新的显示内容，也需要在这里添加
        }
        alreadyLoadGameState = true;
        updateWuxingBonusState();
        console.log("读档成功！");
    }
}

function updateDisplayContent() {
    updatePetInfo();
    updateQualityDisplayWithPillBonus();
    updatePetDisplay();
    updateMutatedImg();
    updateQualityCard();
    updateAttributePanel();
    updateTopBarItems();
    updateAscensionStatus();
    updateAscensionDisplay();
    updateAwakenStatus();
    updateAscensionButton();
    // restoreEnemyState();暂时不重置数据
    checkSecondAscensionEnabled();
    updateGoldDisplay(goldAmount); // 调用更新金子显示的函数
    updateExpBar();

    setInnerText("hallucination-level", hallucinationLevel);
    setInnerText("skill-score", skillScore);
    setInnerText("current-wisdom", currentWisdom);
    setInnerText("train-count", trainingCount);
    setInnerText("pet-level", petLevel);
    setInnerText("evolution-level", evolutionLevel);
    // ...
}

    const fullscreenBtn = document.getElementById('fullscreenBtn');

    fullscreenBtn.addEventListener('click', function() {
        if (!document.fullscreenElement &&    // W3C 标准
            !document.mozFullScreenElement && // Firefox
            !document.webkitFullscreenElement && // Chrome, Safari and Opera
            !document.msFullscreenElement) { // IE/Edge

            // 当前未处于全屏状态，尝试Skills for Your Lovely Pet
            if (document.documentElement.requestFullscreen) {
                document.documentElement.requestFullscreen();
            } else if (document.documentElement.mozRequestFullScreen) { /* Firefox */
                document.documentElement.mozRequestFullScreen();
            } else if (document.documentElement.webkitRequestFullscreen) { /* Chrome, Safari and Opera */
                document.documentElement.webkitRequestFullscreen();
            } else if (document.documentElement.msRequestFullscreen) { /* IE/Edge */
                document.documentElement.msRequestFullscreen();
            }

            fullscreenBtn.textContent = "Click to Resume Screen"; // 更新按钮文本
        } else {
            // 当前处于全屏状态，尝试Click to Resume Screen
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.mozCancelFullScreen) { /* Firefox */
                document.mozCancelFullScreen();
            } else if (document.webkitExitFullscreen) { /* Chrome, Safari and Opera */
                document.webkitExitFullscreen();
            } else if (document.msExitFullscreen) { /* IE/Edge */
                document.msExitFullscreen();
            }

            fullscreenBtn.textContent = "Skills for Your Lovely Pet"; // 更新按钮文本
        }
    });

    // 监听全屏状态变化事件，以确保按钮文本始终与全屏状态同步
    document.addEventListener('fullscreenchange', onFullscreenChange);
    document.addEventListener('webkitfullscreenchange', onFullscreenChange);
    document.addEventListener('mozfullscreenchange', onFullscreenChange);
    document.addEventListener('MSFullscreenChange', onFullscreenChange);
    const correctHashedCode = CryptoJS.MD5("boy").toString();

    function onFullscreenChange() {
        if (document.fullscreenElement || 
            document.mozFullScreenElement || 
            document.webkitFullscreenElement || 
            document.msFullscreenElement) {
            fullscreenBtn.textContent = "Click to Resume Screen";
        } else {
            fullscreenBtn.textContent = "Skills for Your Lovely Pet";
        }
    }
    </script>
</body>
</html>
